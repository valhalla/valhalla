{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<pre><code> \u2588\u2588\u2592   \u2588\u2593 \u2584\u2584\u2584       \u2588\u2588\u2593     \u2588\u2588\u2591 \u2588\u2588  \u2584\u2584\u2584       \u2588\u2588\u2593     \u2588\u2588\u2593    \u2584\u2584\u2584\n\u2593\u2588\u2588\u2591   \u2588\u2592\u2592\u2588\u2588\u2588\u2588\u2584    \u2593\u2588\u2588\u2592    \u2593\u2588\u2588\u2591 \u2588\u2588\u2592\u2592\u2588\u2588\u2588\u2588\u2584    \u2593\u2588\u2588\u2592    \u2593\u2588\u2588\u2592   \u2592\u2588\u2588\u2588\u2588\u2584\n \u2593\u2588\u2588  \u2588\u2592\u2591\u2592\u2588\u2588  \u2580\u2588\u2584  \u2592\u2588\u2588\u2591    \u2592\u2588\u2588\u2580\u2580\u2588\u2588\u2591\u2592\u2588\u2588  \u2580\u2588\u2584  \u2592\u2588\u2588\u2591    \u2592\u2588\u2588\u2591   \u2592\u2588\u2588  \u2580\u2588\u2584\n  \u2592\u2588\u2588 \u2588\u2591\u2591\u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588 \u2592\u2588\u2588\u2591    \u2591\u2593\u2588 \u2591\u2588\u2588 \u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588 \u2592\u2588\u2588\u2591    \u2592\u2588\u2588\u2591   \u2591\u2588\u2588\u2584\u2584\u2584\u2584\u2588\u2588\n   \u2592\u2580\u2588\u2591   \u2593\u2588   \u2593\u2588\u2588\u2592\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2591\u2593\u2588\u2592\u2591\u2588\u2588\u2593 \u2593\u2588   \u2593\u2588\u2588\u2592\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2593\u2588   \u2593\u2588\u2588\u2592\n   \u2591 \u2590\u2591   \u2592\u2592   \u2593\u2592\u2588\u2591\u2591 \u2592\u2591\u2593  \u2591 \u2592 \u2591\u2591\u2592\u2591\u2592 \u2592\u2592   \u2593\u2592\u2588\u2591\u2591 \u2592\u2591\u2593  \u2591\u2591 \u2592\u2591\u2593  \u2591\u2592\u2592   \u2593\u2592\u2588\u2591\n   \u2591 \u2591\u2591    \u2592   \u2592\u2592 \u2591\u2591 \u2591 \u2592  \u2591 \u2592 \u2591\u2592\u2591 \u2591  \u2592   \u2592\u2592 \u2591\u2591 \u2591 \u2592  \u2591\u2591 \u2591 \u2592  \u2591 \u2592   \u2592\u2592 \u2591\n     \u2591\u2591    \u2591   \u2592     \u2591 \u2591    \u2591  \u2591\u2591 \u2591  \u2591   \u2592     \u2591 \u2591     \u2591 \u2591    \u2591   \u2592\n      \u2591        \u2591  \u2591    \u2591  \u2591 \u2591  \u2591  \u2591      \u2591  \u2591    \u2591  \u2591    \u2591  \u2591     \u2591  \u2591\n     \u2591\n</code></pre> <p>Valhalla is an open source routing engine and accompanying libraries for use with OpenStreetMap data. Valhalla also includes tools like time+distance matrix computation, isochrones, elevation sampling, map matching and tour optimization (Travelling Salesman).</p>"},{"location":"#build-status","title":"Build Status","text":"Linux macOS &amp; Windows Code Coverage Timezone DB"},{"location":"#license","title":"License","text":"<p>Valhalla, and all of the projects under the Valhalla organization, use the MIT License.  Avatar/logo by Jordan. </p> <p>OpenStreetMap data in the <code>./test/data</code> is licensed under ODbL and copyrighted by OSM contributors. Additional information on licenses and other requirements concerning the data sources most frequently used by Valhalla can be found in the docs.</p>"},{"location":"#overview","title":"Overview","text":"<p>There are several key features that we hope can differentiate the Valhalla project from other routing and network analysis engines. They are:</p> <ul> <li>Open source software, on open source data with a very liberal license. Should allow for transparency in development, encourage contribution and community input, and foster use in other projects.</li> <li>Tiled hierarchical data structure. Should allow users to have a small memory footprint on memory constrained devices, enable offline routing, provide a means for regional extracts and partial updates.</li> <li>Dynamic, runtime costing of edges and vertices within the graph via a plugin architecture. Should allow for customization and alternate route generation.</li> <li>C++ based API. Should allow for cross compilation of the various pieces to enable routing on offline portable devices.</li> <li>A plugin based narrative and manoeuvre generation architecture. Should allow for generation that is customized either to the administrative area or to the target locale.</li> <li>Multi-modal and time-based routes. Should allow for mixing auto, pedestrian, bike and public transportation in the same route or setting a time by which one must arrive at a location.</li> </ul>"},{"location":"#demo-server","title":"Demo Server","text":"<p>FOSSGIS e.V. hosts a demo server which is open to the public and includes a full planet graph with an open-source web app on https://valhalla.openstreetmap.de. The HTTP API is accessible on a slightly different subdomain, e.g. https://valhalla1.openstreetmap.de/isochrone. Usage of the demo server follows the usual fair-usage policy as OSRM &amp; Nominatim demo servers (somewhat enforced by rate limits).</p>"},{"location":"#platform-compatibility","title":"Platform Compatibility","text":"<p>Valhalla is fully functional on many Linux and Mac OS distributions, and is also used on iOS and Android devices.</p> <p>For Windows, not all functionality is fully supported yet. Building the Valhalla library works flawlessly, as well as the following application modules:</p> <ul> <li><code>TOOLS</code>: utilities to query and benchmark various components</li> <li><code>DATA_TOOLS</code>: utilities to build input data and handle transit</li> <li><code>PYTHON_BINDINGS</code>: use all actions (route, isochrones, matrix etc) via the Valhalla Python library (needs a full (i.e. development) Python distribution in the <code>PATH</code>)</li> </ul>"},{"location":"#organization","title":"Organization","text":"<p>The Valhalla organization is comprised of several library modules each responsible for a different function. The layout of the various modules is as follows:</p> <ul> <li>Midgard - Basic geographic and geometric algorithms for use in the various other projects.</li> <li>Baldr - The base data structures for accessing and caching tiled route data.</li> <li>Sif - Library used in costing of graph nodes and edges. This can be used as input to <code>loki</code> and <code>thor</code>.</li> <li>Skadi - Library and service for accessing elevation data. This can be used as input to <code>mjolnir</code> or as a standalone service.</li> <li>Mjolnir - Tools for turning open data into Valhalla graph tiles.</li> <li>Loki - Library used to search graph tiles and correlate input locations to an entity within a tile. This correlated entity (edge or vertex) can be used as input to <code>thor</code>.</li> <li>Meili - Library used to for map-matching.</li> <li>Thor - Library used to generate a path through the graph tile hierarchy.  This path and attribution along the path can be used as input to <code>odin</code>.</li> <li>Odin - Library used to generate manoeuvres and narrative based on a path. This set of directions information can be used as input to <code>tyr</code>.</li> <li>Tyr - Service used to handle http requests for a route communicating with all of the other valhalla APIs. The service will format output from <code>odin</code> and support json (and eventually protocol buffer) output.</li> <li>Tools - A set command line tools that exercise bits of functionality from the library components above and provide the basis for quality testing and performance benchmarking.</li> <li>Demos - A set of demos which allows interacting with the service and APIs.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation is stored in the <code>docs/</code> folder in this GitHub repository. It can be viewed at valhalla.github.io/valhalla.</p>"},{"location":"#installation","title":"Installation","text":"<p>For more information on binaries, see Command Line Tools section below and the docs.</p>"},{"location":"#from-source","title":"From source","text":"<p>If you want to build Valhalla from source, follow the documentation.</p>"},{"location":"#with-docker","title":"With docker","text":"<p>To run Valhalla locally or your own server, we recommend using one of our Docker images, see the README.</p>"},{"location":"#via-python-bindings","title":"Via Python bindings","text":"<p>We publish our (very) high-level Python bindings to PyPI with <code>pyvalhalla</code>.</p> <p>The Python packages don't only contain the Python bindings, they also provide access to the C++ executables, e.g. in the form of <code>python -m valhalla valhalla_build_tiles -h</code>. For more details, see the Python README.</p> <p>To install the native C++ executables one doesn't even need to have root permissions or even have Python installed. Simply download the desired wheel from PyPI, extract it with e.g. <code>unzip</code> and run the included <code>valhalla/bin/&lt;binary&gt;</code> directly.</p>"},{"location":"#via-nodejs-bindings","title":"Via NodeJS bindings","text":"<p>We provide high-level NodeJS binding:</p> <pre><code>npm install @valhallajs/valhallajs\n</code></pre> <p>For more details, see the NodeJS README.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We  contributions to Valhalla. They could be non-technical, e.g. translations into other languages via Transifex or documentation improvements, or technical ones like bug fixes or feature implementations. It's important to open an issue before setting out to work on a PR.</p> <p>Ideally, get familiar with our Contribution guidelines first.</p>"},{"location":"#command-line-tools","title":"Command Line Tools","text":"<p>[!TIP] Easily install various Valhalla command line tools like <code>valhalla_build_tiles</code> or <code>valhalla_service</code> with the Python bindings.</p>"},{"location":"#valhalla_service-aka-one-shot-mode","title":"<code>valhalla_service</code> aka one-shot mode","text":"<p>If you can't (e.g. Windows Server) or don't want to have the full-fledged HTTP API running, you can have the (almost) exact same behavior with the 'valhalla_service' executable in so-called \"one-shot\" mode. It's simple, just pass the config file, the action (route, isochrone, matrix etc) and the stringified JSON request (or alternatively a file containing the request to circumvent shell command length issues):</p> <pre><code>valhalla_service valhalla.json isochrone '{\"locations\":[{\"lat\":42.552448,\"lon\":1.564865}],\"costing\":\"auto\",\"contours\":[{\"time\":10,\"color\":\"ff0000\"}], \"show_locations\":true}'\n# Alternatively you can pass a file with the same contents\nvalhalla_service valhalla.json isochrone isochrone_request.txt\n</code></pre> <p>It's important to note that all Valhalla logs for one-shot mode are piped to <code>stderr</code> while the actual JSON response will be in <code>stdout</code>. To completely silence the logs, pass <code>type: \"\"</code> to <code>midgard.logging</code> in the config file.</p>"},{"location":"#batch-script-tool","title":"Batch Script Tool","text":"<ul> <li>Batch Run_Route</li> </ul>"},{"location":"#related-projects","title":"Related projects","text":"<p>The following projects are open-source and built with the intention to make it easier to use Valhalla and its features:</p> <ul> <li>OpenStreetMapSpeeds: A project conflating open GPS data to improve Valhalla's speed classification. The current JSON is from early 2022 and can be downloaded here and used by setting the path in the <code>mjolnir.default_speeds_config</code> config option.</li> <li>valhalla-operator: A k8s operator to deploy and manage Valhalla.</li> <li>valhalla-app: A React based web app for Valhalla, powering https://valhalla.openstreetmap.de/.</li> <li>valhalla-qgis-plugin: A QGIS plugin for Valhalla, also available in the official QGIS plugin store, featuring built-in <code>valhalla_service</code> and <code>valhalla_build_tiles</code>.</li> <li>routingpy: A Python client for most open-source routing engines, including Valhalla, with a common interface for all engines. Available on PyPI.</li> <li>routingjs: A TypeScript client for most open-source routing engines, including Valhalla, with a common interface for all engines. Available as engine-specific packages on npm.</li> <li>Valhalla_jll.jl: Valhalla binaries shipped for Julia.</li> <li>valhalla-go: Valhalla Golang bindings via cgo</li> </ul>"},{"location":"README_nodejs/","title":"Valhalla Node.js Bindings","text":"<p>Node.js bindings for Valhalla, an open-source routing engine.</p>"},{"location":"README_nodejs/#installation","title":"Installation","text":"<pre><code>npm install @valhallajs/valhallajs\n</code></pre>"},{"location":"README_nodejs/#quick-start","title":"Quick Start","text":""},{"location":"README_nodejs/#1-build-valhalla-tiles","title":"1. Build Valhalla Tiles","text":"<p>First, download OSM data and build routing tiles using the Valhalla CLI tools:</p> <pre><code># Download OSM data (e.g. Berlin)\nwget https://download.geofabrik.de/europe/germany/berlin-latest.osm.pbf\n\n# Build config file\nnpx valhalla build_config --mjolnir-tile-dir valhalla_tiles --mjolnir-tile-extract valhalla_tiles.tar &gt; config.json\n\n# Build tiles from OSM data\nnpx valhalla build_tiles -c config.json berlin-latest.osm.pbf\n</code></pre>"},{"location":"README_nodejs/#2-use-valhalla-for-routing","title":"2. Use Valhalla for Routing","text":"<pre><code>import { Actor, getConfig } from '@valhallajs/valhallajs';\n\nasync function main() {\n  // Create an actor with config generated on previous step\n  const actor = await Actor.fromConfigFile('config.json');\n\n  // Calculate a route\n  const result = await actor.route({\n    locations: [\n      { lat: 52.5200, lon: 13.4050 },\n      { lat: 52.5300, lon: 13.4150 }\n    ],\n    costing: 'auto'\n  });\n\n  console.log(result);\n}\n\nmain();\n</code></pre>"},{"location":"README_nodejs/#3-working-with-graphid-no-built-graph-needed","title":"3. Working with <code>GraphId</code> (no built graph needed)","text":"<p>The <code>GraphId</code> class represents Valhalla's internal graph identifiers, which encode a hierarchy level, tile ID, and element ID.</p> <pre><code>import { GraphId } from '@valhallajs/valhallajs';\n\n// Construct from components: (tileid, level, id)\nconst gid = new GraphId(100, 2, 5);\nconsole.log(gid.level());   // 2\nconsole.log(gid.tileid());  // 100\nconsole.log(gid.id());      // 5\nconsole.log(gid.is_valid()); // true\n\n// Construct from string \"level/tileid/id\"\nconst gid2 = new GraphId('2/100/5');\nconsole.log(gid.equals(gid2)); // true\n\n// String and JSON representations\nconsole.log(gid.toString());    // \"2/100/5\"\nconsole.log(JSON.stringify(gid)); // {\"level\":2,\"tileid\":100,\"id\":5,\"value\":...}\n\n// Get tile base (same tile, id zeroed out)\nconst base = gid.tile_base();\nconsole.log(base.toString()); // \"2/100/0\"\n\n// Advance the id by an offset (returns a new GraphId)\nconst next = gid.add(3);\nconsole.log(next.toString()); // \"2/100/8\"\n\n// Roundtrip through the raw numeric value\nconst restored = new GraphId(gid.value);\nconsole.log(restored.equals(gid)); // true\n</code></pre>"},{"location":"README_nodejs/#protocol-buffer-support","title":"Protocol Buffer Support","text":"<p>For performance-critical applications, Valhalla supports Protocol Buffer (pbf) format for requests and responses. This provides faster serialization/deserialization and smaller payload sizes compared to JSON.</p>"},{"location":"README_nodejs/#supported-apis","title":"Supported APIs","text":"<p>The following methods support <code>format: 'pbf'</code>: - <code>route</code> - <code>matrix</code> - <code>isochrone</code> - <code>expansion</code> - <code>traceRoute</code> - <code>traceAttributes</code></p>"},{"location":"README_nodejs/#using-protocol-buffer-format","title":"Using Protocol Buffer Format","text":"<p>When you request <code>format: 'pbf'</code>, the method returns a Node.js Buffer containing serialized protobuf data instead of a parsed JSON object.</p> <pre><code>import { Actor } from '@valhallajs/valhallajs';\nimport protobuf from 'protobufjs';\nimport { fileURLToPath } from 'url';\nimport { dirname, join } from 'path';\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nasync function main() {\n  const actor = await Actor.fromConfigFile('config.json');\n\n  // Load the protobuf definition\n  const protoPath = join(__dirname, 'node_modules/@valhallajs/valhallajs/proto/api.proto');\n  const root = await protobuf.load(protoPath);\n  const Api = root.lookupType('valhalla.Api');\n\n  // Request in pbf format\n  const buffer = await actor.route({\n    locations: [\n      { lat: 52.5200, lon: 13.4050 },\n      { lat: 52.5300, lon: 13.4150 }\n    ],\n    costing: 'auto',\n    format: 'pbf'  // Returns Buffer instead of JSON object\n  });\n\n  // Decode the protobuf buffer\n  const message = Api.decode(buffer);\n  const response = Api.toObject(message, {\n    longs: String,\n    enums: String,\n    bytes: String\n  });\n\n  console.log(response.trip);\n  console.log(response.directions);\n}\n\nmain();\n</code></pre>"},{"location":"README_nodejs/#installing-protobufjs","title":"Installing protobufjs","text":"<p>To decode protobuf responses, install protobufjs:</p> <pre><code>npm install protobufjs\n</code></pre>"},{"location":"README_nodejs/#benefits-of-protocol-buffer-format","title":"Benefits of Protocol Buffer Format","text":"<ul> <li>Performance: 3-10x faster serialization/deserialization</li> <li>Size: 20-50% smaller payload sizes</li> <li>Bandwidth: Reduced network transfer costs</li> <li>Type Safety: Strongly-typed schema definitions</li> </ul>"},{"location":"README_nodejs/#proto-files-location","title":"Proto Files Location","text":"<p>The protocol buffer definitions are included in the package at <code>node_modules/@valhallajs/valhallajs/proto/</code>. The main entry point is <code>api.proto</code>, which imports all other necessary definitions.</p>"},{"location":"README_nodejs/#compatibility","title":"Compatibility","text":""},{"location":"README_nodejs/#nodejs-versions","title":"Node.js Versions","text":"<ul> <li>Node.js v16.0.0 and all later versions</li> <li>Node.js v15.12.0+</li> <li>Node.js v14.17.0+</li> <li>Node.js v12.22.0+</li> </ul>"},{"location":"README_nodejs/#platforms","title":"Platforms","text":"<ul> <li>Linux (arm64, x64)</li> <li>macOS (arm64)</li> </ul>"},{"location":"README_python/","title":"Python bindings","text":""},{"location":"README_python/#valhalla-python-bindings","title":"Valhalla Python bindings","text":"<p>This folder contains the Python bindings to Valhalla routing engine.</p> <p>[!NOTE] <code>pyvalhalla</code> packages are currently only published for: - <code>linux-x86_x64</code> - <code>linux-aarch64</code> - <code>win-amd64</code> - <code>macos-arm64</code></p> <p>On top of the (very) high-level Python bindings, we package some data-building Valhalla executables to ease the process of graph creation or run Valhalla as a service, see below.</p>"},{"location":"README_python/#installation","title":"Installation","text":"<p>We publish CPython packages as binary wheels for Win (<code>amd64</code>), MacOS (<code>arm64</code>) and Linux (<code>x86_64</code>/<code>aarch64</code>) distributions with <code>glibc&gt;=2.28</code>. To decrease disk footprint of the PyPI releases, we only publish a single <code>abi3</code> wheel per platform, which requires Python &gt;= 3.12. To install on Python &lt; 3.12, make sure to install the system dependencies as described in the docs before trying a <code>pip install pyvalhalla</code>.</p> <p>Or manually in the current Python environment with e.g.</p> <pre><code>git clone https://github.com/valhalla/valhalla\ncd valhalla\npip install .\n</code></pre> <p>In case you need to do a source installation (from <code>sdist</code>), follow the build instructions for your platform to install the needed dependencies. Then a simple <code>pip install pyvalhalla</code> should work fine for Linux/OSX. On Windows one needs to install C++ developer tools, see also below in the developer notes for external <code>vcpkg</code> usage to resolve dependencies.</p> <p>[!TIP] For developers: <code>pip install -e</code> (editable build) will by default build into a temp directory, so everytime it's invoked it'll rebuild all of libvalhalla. Use the following command to enable real incremental builds:</p> <pre><code>pip install -e . --no-build-isolation \\\n  -Cbuild-dir=build_python (or other build dir) \\\n  -Ccmake.build-type=Release \\\n  -Ccmake.define.VALHALLA_VERSION_MODIFIER=\"$(git rev-parse --short HEAD)\"\n  # optionally for vcpkg package management\n  -Ccmake.define.CMAKE_TOOLCHAIN_FILE=\"$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake\"\n  -Ccmake.define.VCPKG_TARGET_TRIPLET=x64-windows\n  -Ccmake.define.VCPKG_OVERLAY_PORTS=overlay-ports-vcpkg\n</code></pre> <p>Similarly for building a wheel:</p> <pre><code>pip wheel . -w dist --no-build-isolation \\\n  -Cbuild-dir=build_python (or other build dir) \\\n  -Ccmake.build-type=Release \\\n  -Ccmake.define.VALHALLA_VERSION_MODIFIER=\"$(git rev-parse --short HEAD)\"\n  # optionally for vcpkg package management\n  -Ccmake.define.CMAKE_TOOLCHAIN_FILE=\"$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake\"\n  -Ccmake.define.VCPKG_TARGET_TRIPLET=x64-windows\n  -Ccmake.define.VCPKG_OVERLAY_PORTS=overlay-ports-vcpkg\n</code></pre> <p>Both commands have to repeated for each build.</p>"},{"location":"README_python/#typing-support","title":"Typing support","text":"<p>We (try to) include full typing support for pyvalhalla. If you're using <code>mypy</code> with strict typing policies, you'll need to install pyvalhalla appropriately with <code>pip install pyvalhalla[typing]</code>.</p>"},{"location":"README_python/#usage","title":"Usage","text":""},{"location":"README_python/#bindings","title":"Bindings","text":"<p>Find a more extended notebook in <code>./examples</code>, e.g. how to use the actor.</p> <p>Before using the Python bindings you need to have access to a routable Valhalla graph. Once you installed the <code>pyvalhalla</code> package you can create one with</p> <pre><code>wget https://download.geofabrik.de/europe/andorra-latest.osm.pbf\npython -m valhalla valhalla_build_tiles -c &lt;valhalla.json&gt; andorra-latest.osm.pbf\n</code></pre> <p>Once you have created a graph locally, you can use it like this:</p> <pre><code>from valhalla import Actor, get_config, get_help\n\n# generate configuration\nconfig = get_config(tile_extract='./custom_files/valhalla_tiles.tar', verbose=True)\n\n# print the help for specific config items (has the same structure as the output of get_config()\nprint(get_help()[\"service_limits\"][\"auto\"][\"max_distance\"])\n\n# instantiate Actor to load graph and call actions\nactor = Actor(config)\nroute = actor.route({\"locations\": [...]})\n</code></pre>"},{"location":"README_python/#graph-utilities","title":"Graph Utilities","text":"<p>Access to low-level graph data structures for advanced use cases:</p> <pre><code>from valhalla.utils.graph_utils import GraphId, GraphUtils\n\n# Create a GraphId from its string representation or numeric value\nedge_id = GraphId(\"2/421920/20\")  # format: \"level/tileid/id\"\n# or\nedge_id = GraphId(674464020)\n\n# Initialize GraphUtils with config (reuse for multiple queries)\n# Accepts: file path (str/Path), JSON string, or dict\nconfig = \"/path/to/valhalla.json\"\n# or dict config\nconfig = {\"mjolnir\": {\"tile_extract\": \"/path/to/tiles.tar\"}}\ngraph = GraphUtils(config)\n\n# Get the polyline geometry for an edge\nshape = graph.get_edge_shape(edge_id)\n\n# shape is a list of (lon, lat) tuples\nprint(f\"Edge has {len(shape)} coordinate points\")\nfor lon, lat in shape:\n    print(f\"  ({lon:.6f}, {lat:.6f})\")\n\n# Convert to GeoJSON LineString\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [[lon, lat] for lon, lat in shape]\n    }\n}\n</code></pre>"},{"location":"README_python/#speed-compression-utilities","title":"Speed Compression Utilities","text":"<p>Valhalla uses DCT-2 (Discrete Cosine Transform) to compress historical speed profiles. These utilities allow you to work with compressed speed data:</p> <pre><code>import numpy as np\nfrom valhalla.utils.predicted_speeds import (\n    compress_speed_buckets,\n    decompress_speed_bucket,\n    encode_compressed_speeds,\n    decode_compressed_speeds,\n    BUCKETS_PER_WEEK,\n    COEFFICIENT_COUNT,\n)\n\n# Compress 2016 speed buckets (7 days \u00d7 288 five-minute intervals)\nspeeds = np.full(BUCKETS_PER_WEEK, 50.0, dtype=np.float32)  # 50 KPH constant\ncoefficients = compress_speed_buckets(speeds)\n\n# Decompress a specific bucket (e.g., Monday 10:00 AM)\nbucket_idx = 120  # (24 hours \u00d7 12 buckets/hour) \u00d7 0 days + 10 \u00d7 12\nspeed = decompress_speed_bucket(coefficients, bucket_idx)\n\n# Encode coefficients for storage/transmission\nencoded = encode_compressed_speeds(coefficients)\nprint(f\"Compressed to {len(encoded)} characters\")\n\n# Decode from string\ncoefficients_restored = decode_compressed_speeds(encoded)\n</code></pre>"},{"location":"README_python/#valhalla-executables","title":"Valhalla executables","text":"<p>To access the C++ (native) executables, there are 2 options:</p> <ul> <li>(recommended) execute the module, e.g. <code>python -m valhalla valhalla_build_tiles -h</code></li> <li>execute the Python wrapper scripts directly, e.g. <code>valhalla_build_tiles -h</code></li> </ul> <p>[!NOTE] For the latter option to work, the Python environment's <code>bin/</code> folder has to be in the <code>$PATH</code>. Inside virtual environments, that's always the case.</p> <p>Executing the scripts directly might also not work properly if there's a system-wide Valhalla installation, unless the Python environment's <code>bin/</code> folder has higher priority than system folders in <code>$PATH</code>. The module execution uses an explicit Python executable which should be preferred.</p> <p>There are also some additional commands we added:</p> <ul> <li><code>--help</code>: print the help for <code>python -m valhalla</code> explicitly</li> <li><code>--quiet</code>: redirect <code>stdout</code> of the C++ executables to <code>/dev/null</code>; can be added once anywhere in the command, will not be forwarded to a C++ executable</li> <li><code>print_bin_path</code>: simply prints the absolute path to the package-internal <code>bin/</code> directory where the C++ executables are; useful if the executables should be accessed directly in some script</li> </ul> <p>To find out which Valhalla executables are currently included, run <code>python -m valhalla --help</code>. We limit the number of executables to control the wheel size. However, we're open to include any other executable if there's a good reason.</p>"},{"location":"README_python/#building-from-source","title":"Building from source","text":"<p>Note, building the bindings from source is usually best done by building Valhalla with <code>cmake -B build -DENABLE_PYTHON_BINDING=ON ...</code>. However, if you want to package your own <code>pyvalhalla</code> bindings for some reason (e.g. fork in a bigger team), you can follow the below instructions, which are also executed by our CI.</p> <p>The Python build respects a few CMake configuration variables:</p> <ul> <li><code>VALHALLA_VERSION_MODIFIER</code> (optional): Will append a string to the actual Valhalla version string, e.g. <code>$(git rev-parse --short HEAD)</code> will append the current branch's commit hash.</li> </ul>"},{"location":"README_python/#cibuildwheel","title":"<code>cibuildwheel</code>","text":"<p>On our CI, this orchestrates the packaging of all <code>pyvalhalla</code> wheels for every supported, minor Python version and every platform. It can also be run locally (obviously only being able to build wheels for your platform), e.g.</p> <pre><code>python -m pip install cibuildwheel\ncibuildwheel --print-build-identifiers\ncibuildwheel --only cp313-manylinux_x86_64\n\n# for windows you'll have to set an env var to the vcpkg win root\nVCPKG_ARCH_ROOT=\"build/vcpkg_installed/custom-x64-windows\" cibuildwheel --only cp313-win_amd64\n</code></pre> <p>The build looks at a few environment variables:</p> <ul> <li><code>VCPKG_ARCH_ROOT</code> (required for Win): The relative/absolute directory of the <code>vcpkg</code> root.</li> </ul> <p>In the end, you'll find the wheel in <code>./wheelhouse</code>.</p>"},{"location":"README_python/#linux","title":"Linux","text":"<p>To package arch-dependent Linux bindings we use a <code>manylinux</code> fork, where we install all dependencies into the <code>manylinux_2_28</code> image, based on AlmaLinux 8. This is necessary to have a broad <code>glibc</code> compatibility with many semi-recent Linux distros.</p> <p>Either pull the <code>manylinux</code> image, or build it locally for testing:</p> <pre><code>docker pull ghcr.io/valhalla/manylinux:2_28_valhalla_python\n\n# or pull the image from ghcr.io\ngit clone https://github.com/valhalla/manylinux\ncd manylinux\nPOLICY=manylinux_2_28 PLATFORM=x86_64 COMMIT_SHA=$(git rev-parse --verify HEAD) BUILDX_BUILDER=builder-docker-container ./build.sh\ndocker tag quay.io/pypa/manylinux_2_28_x86_64:$(git rev-parse --verify HEAD) ghcr.io/valhalla/manylinux:2_28_valhalla_python\n</code></pre> <p>Once built, start a container to actually build Valhalla using AlmaLinux 8:</p> <pre><code>cd valhalla\ndocker run -dt -v $PWD:/valhalla-py --name valhalla-py --workdir /valhalla-py ghcr.io/valhalla/manylinux:2_28_valhalla_python\ndocker exec -t valhalla-py /valhalla-py/src/bindings/python/scripts/build_manylinux.sh build_manylinux 3.13\n</code></pre> <p>This will also build &amp; install <code>libvalhalla</code> before building the bindings. At this point there should be a <code>wheelhouse</code> folder with the fixed python wheel, ready to be installed or distributed to arbitrary python 3.13 installations.</p>"},{"location":"README_python/#testing-linux-only","title":"Testing (<code>linux</code> only)","text":"<p>We have a small test script which makes sure that all the executables are working properly. If run locally for some reason, install a <code>pyvalhalla</code> wheel first. We run this in CI in a fresh Docker container with no dependencies installed, mostly to verify dynamic linking of the vendored dependencies.</p>"},{"location":"baldr/","title":"Baldr","text":"<p>Baldr serves as a set of routing-specific data structures for use within other pieces of the Valhalla library. In keeping with the Norse mythological theme, the name Baldr was chosen as a backronym standing for: Base ALgorithms and Data Resource. Since Baldr deals mostly with accessing routing data and algorithms related to routing sub-problems.</p> <p>Baldr is essentially a set of various data structures and algorithms which deal with things like: route data tiles, tile caching, hierarchical tile layout and tile data members such as nodes, edges and exits.</p>"},{"location":"baldr/#components","title":"Components","text":""},{"location":"baldr/#graphid","title":"<code>GraphId</code>","text":"<p><code>GraphId</code> (source) is a unique identifier of a node or an edge within the tiled, hierarchical graph.</p> <p>It includes:</p> <ul> <li>Hierarchy level</li> <li>Tile index</li> <li>Node or edge index</li> </ul> <p>Warning</p> <p><code>GraphId</code> does not contain the information about the kind of object it identifies. We cannot tell whether a <code>GraphId</code> represents a node or an edge just by looking at it.</p> <p>For example, an ID with object index 0 may represent either a node or an edge. In other words, we could (and usually do) have two objects -  a node and an edge - with the same identifier.</p>"},{"location":"baldr/#implementation","title":"Implementation","text":"<p>Internally, Valhalla uses a 64-bit unsigned integer value to represent <code>GraphId</code>. This representation supports efficient comparison and hashing operations and allows for reasonable ranges of field values.</p> <p>Here's the bit layout of the value. The fields are presented with the most significant bit (MSb) first - see Bit numbering for more info.</p> <pre><code>       MSb                                     LSb\n       \u25bc                                       \u25bc\nbit   64         46        25         3        0\npos    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502 RESERVED \u2502 id      \u2502 tileid  \u2502 level  \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nsize     18         21        22        3\n</code></pre>"},{"location":"baldr/#fields","title":"Fields","text":"<p>Order is based on field position in bit layout, from field starting at the MSb to one ending at LSb.</p> Field Bits Description <code>RESERVED</code> 18 Spare, unused bits <code>id</code> 21 Node or edge index <code>tileid</code> 22 Tile index <code>level</code> 3 Hierarchy level"},{"location":"baldr/#examples","title":"Examples","text":""},{"location":"baldr/#valid-graphid","title":"Valid <code>GraphId</code>","text":"Field Bits Decimal Binary RESERVED 18 <code>id</code> 21 1234567 <code>0b100101101011010000111</code> <code>tileid</code> 22 5869 <code>0b0000000001011011101101</code> <code>level</code> 3 1 <code>0b001</code> <ul> <li>Final value, decimal: <code>41425194497897</code></li> <li> <p>Final value, binary:</p> <pre><code>0b100101101011010000111_0000000001011011101101_001\n</code></pre> </li> </ul>"},{"location":"baldr/#invalid-graphid","title":"Invalid <code>GraphId</code>","text":"<p>Invalid <code>GraphId</code> value has all non-reserved bits set to <code>1</code>:</p> <pre><code>0x3fffffffffff\n</code></pre>"},{"location":"baldr/#code","title":"Code","text":"<p>Below are some sample Python functions:</p> <pre><code>HIERARCHY_LEVEL_BITS = 3\nHIERARCHY_LEVEL_MASK = 2**HIERARCHY_LEVEL_BITS - 1\nMAX_HIERARCHY_LEVEL = HIERARCHY_LEVEL_MASK\n\nTILE_INDEX_BITS = 22\nTILE_INDEX_MASK = 2**TILE_INDEX_BITS - 1\nMAX_TILE_INDEX = TILE_INDEX_MASK\n\nOBJECT_INDEX_BITS = 21\nOBJECT_INDEX_MASK = 2**OBJECT_INDEX_BITS - 1\nMAX_OBJECT_INDEX = OBJECT_INDEX_MASK\n\ndef to_graph_id(\n    hierarchy_level: int,\n    tile_index: int,\n    object_index: int,\n) -&gt; int:\n    \"\"\"Create 64-bit representation of `GraphId`.\"\"\"\n\n    assert 0 &lt;= hierarchy_level &lt;= MAX_HIERARCHY_LEVEL\n    assert 0 &lt;= tile_index &lt;= MAX_TILE_INDEX\n    assert 0 &lt;= object_index &lt;= MAX_OBJECT_INDEX\n\n    x = (\n        # 3 bits\n        hierarchy_level\n        # 22 bits, offset by previous field's width\n        | (tile_index &lt;&lt; HIERARCHY_LEVEL_BITS)\n        # 21 bits, offset by the combined width of previous fields\n        | (object_index &lt;&lt; (HIERARCHY_LEVEL_BITS + TILE_INDEX_BITS))\n    )\n\n    return x\n\n\ndef get_hierarchy_level(graph_id: int) -&gt; int:\n    \"\"\"Hierarchy level from 64-bit representation of `GraphId`.\"\"\"\n\n    return graph_id &amp; HIERARCHY_LEVEL_MASK\n\n\ndef get_tile_index(graph_id: int) -&gt; int:\n    \"\"\"Tile index from 64-bit representation of `GraphId`.\"\"\"\n\n    offset = HIERARCHY_LEVEL_BITS\n\n    return (graph_id &gt;&gt; offset) &amp; TILE_INDEX_MASK\n\n\ndef get_object_index(graph_id: int) -&gt; int:\n    \"\"\"Object (node or edge) index from 64-bit representation of `GraphId`.\"\"\"\n\n    offset = HIERARCHY_LEVEL_BITS + TILE_INDEX_BITS\n\n    return (graph_id &gt;&gt; offset) &amp; OBJECT_INDEX_MASK\n</code></pre> <pre><code>&gt;&gt;&gt; get_hierarchy_level(73160266)\n2\n&gt;&gt;&gt; get_hierarchy_level(142438865769)\n1\n</code></pre> <pre><code>&gt;&gt;&gt; get_tile_index(73160266)\n756425\n&gt;&gt;&gt; get_tile_index(142438865769)\n37741\n</code></pre>"},{"location":"baldr/#graphtilereader","title":"GraphTileReader","text":"<p>TODO:</p>"},{"location":"building/","title":"Build from Source","text":"<p>We aim to make Valhalla installable on every half-modern hardware, platform and architecture. If the below instructions are not working for you, we'd be happy if you file an issue or open a PR with a fix.</p>"},{"location":"building/#build-configuration-all-platforms","title":"Build Configuration (all platforms)","text":"<p>Valhalla uses CMake as the build system, the compiler needs C++17 support.</p> <p>Important build options include:</p> Option Behavior <code>-DENABLE_TOOLS</code> (<code>On</code>/<code>Off</code>) Build <code>valhalla_service</code> and other utilities (defaults to on) <code>-DENABLE_DATA_TOOLS</code> (<code>On</code>/<code>Off</code>) Build the data preprocessing tools (defaults to on) <code>-DENABLE_HTTP</code> (<code>On</code>/<code>Off</code>) Build with <code>curl</code> support (defaults to on) <code>-DENABLE_PYTHON_BINDINGS</code> (<code>On</code>/<code>Off</code>) Build the python bindings (defaults to on) <code>-DENABLE_SERVICES</code> (<code>On</code> / <code>Off</code>) Build the HTTP service (defaults to on) <code>-DENABLE_THREAD_SAFE_TILE_REF_COUNT</code> (<code>ON</code> / <code>OFF</code>) If ON uses <code>shared_ptr</code> as tile reference (i.e. it is thread safe, defaults to off) <code>-DENABLE_CCACHE</code> (<code>On</code> / <code>Off</code>) Speed up incremental rebuilds via <code>ccache</code> (defaults to on) <code>-DENABLE_BENCHMARKS</code> (<code>On</code> / <code>Off</code>) Enable microbenchmarking (defaults to on) <code>-DENABLE_TESTS</code> (<code>On</code> / <code>Off</code>) Enable Valhalla tests (defaults to on) <code>-DENABLE_COVERAGE</code> (<code>On</code> / <code>Off</code>) Build with coverage instrumentalisation (defaults to off) <code>-DBUILD_SHARED_LIBS</code> (<code>On</code> / <code>Off</code>) Build static or shared libraries (defaults to off) <code>-DENABLE_STATIC_LIBRARY_MODULES</code> (<code>On</code> / <code>Off</code>) If ON builds Valhalla modules as STATIC library targets (defaults to off) <code>-DENABLE_COMPILER_WARNINGS</code> (<code>ON</code> / <code>OFF</code>) Build with common compiler warnings (defaults to off) <code>-DENABLE_SINGLE_FILES_WERROR</code> (<code>ON</code> / <code>OFF</code>) Convert compiler warnings to errors for a (growing) selection of files (defaults to on) <code>-DENABLE_WERROR</code> (<code>ON</code> / <code>OFF</code>) Treat compiler warnings as errors  (defaults to off). Requires <code>-DENABLE_COMPILER_WARNINGS=ON</code> to take effect. <code>-DENABLE_SANITIZERS</code> (<code>ON</code> / <code>OFF</code>) Build with all the integrated sanitizers (defaults to off). <code>-DENABLE_ADDRESS_SANITIZER</code> (<code>ON</code> / <code>OFF</code>) Build with address sanitizer (defaults to off). <code>-DENABLE_UNDEFINED_SANITIZER</code> (<code>ON</code> / <code>OFF</code>) Build with undefined behavior sanitizer (defaults to off). <code>-DPREFER_SYSTEM_DEPS</code> (<code>ON</code> / <code>OFF</code>) Whether to use internally vendored headers or find the equivalent external package (defaults to off). <code>-DENABLE_GEOTIFF</code> (<code>ON</code> / <code>OFF</code>) Whether to include libgeotiff as a dependency (used for serialization of isochrone grid, defaults to ON). <code>-DCMAKE_UNITY_BUILD</code> (<code>ON</code> / <code>OFF</code>) Whether to enable unity builds to speed up compilation (defaults to off). You may need to experiment with different values for <code>-DCMAKE_UNITY_BUILD_BATCH_SIZE</code> (default is 8) to achieve successful compilation."},{"location":"building/#building-with-vcpkg-any-platform","title":"Building with <code>vcpkg</code> - any platform","text":"<p>Instead of installing the dependencies system-wide, you can also opt to use <code>vcpkg</code>.</p> <p>The following commands should work on all platforms:</p>"},{"location":"building/#clone-sources","title":"Clone sources","text":"<pre><code>git clone --recurse-submodules https://github.com/valhalla/valhalla\ncd valhalla\n# Clone vcpkg for dependencies:\ngit clone https://github.com/microsoft/vcpkg &amp;&amp; git -C vcpkg checkout &lt;some-tag&gt;\n</code></pre>"},{"location":"building/#bootstrap-vcpkg","title":"Bootstrap <code>vcpkg</code>","text":"LinuxmacOSWindows <pre><code>./vcpkg/bootstrap-vcpkg.sh\n</code></pre> <pre><code>./vcpkg/bootstrap-vcpkg.sh\n</code></pre> <pre><code>cmd.exe /c .\\vcpkg\\bootstrap-vcpkg.bat\n</code></pre>"},{"location":"building/#set-build-type-optional","title":"Set build type (Optional)","text":"<p>To build only release build without any debug symbols:</p> LinuxmacOSWindows <pre><code>echo \"set(VCPKG_BUILD_TYPE Release)\" &gt;&gt; vcpkg/triplets/x64-linux.cmake\n</code></pre> <pre><code>echo \"set(VCPKG_BUILD_TYPE release)\" &gt;&gt; vcpkg/triplets/arm64-osx.cmake\n</code></pre> <pre><code>echo set(VCPKG_BUILD_TYPE release)&gt;&gt; .\\vcpkg\\triplets\\x64-windows.cmake\n</code></pre>"},{"location":"building/#configure-cmake","title":"Configure CMake","text":"<p><code>vcpkg</code> will install everything during cmake configuration.</p> <p>If you want to <code>ENABLE_SERVICES=ON</code>, install prime_server (Not available for Windows).</p> LinuxmacOSWindows <pre><code>cmake -B build -DCMAKE_TOOLCHAIN_FILE=$PWD/vcpkg/scripts/buildsystems/vcpkg.cmake -DENABLE_SERVICES=OFF\n</code></pre> <pre><code>cmake -B build -DCMAKE_TOOLCHAIN_FILE=$PWD/vcpkg/scripts/buildsystems/vcpkg.cmake -DENABLE_SERVICES=OFF\n</code></pre> <pre><code>cmake -B build -DCMAKE_TOOLCHAIN_FILE=%CD%\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake -DENABLE_SERVICES=OFF\n</code></pre>"},{"location":"building/#build","title":"Build","text":"LinuxmacOSWindows <pre><code>cmake --build build -- -j$(nproc)\n</code></pre> <pre><code>cmake --build build -- -j$(sysctl -n hw.physicalcpu)\n</code></pre> <pre><code># /m:4 = Use up to 4 processes\ncmake --build build --config Release -- /clp:ErrorsOnly /p:BuildInParallel=true /m:4\n</code></pre>"},{"location":"building/#platform-specific-builds","title":"Platform-specific builds","text":""},{"location":"building/#building-from-source-linux","title":"Building from Source - Linux","text":"<p>To install on a Debian or Ubuntu system you need to install its dependencies with:</p> <pre><code>./scripts/install-linux-deps.sh\n</code></pre> <p>Now you can build and install Valhalla, e.g.</p> <pre><code># will build to ./build\ncmake -B build -DCMAKE_BUILD_TYPE=Release\nmake -C build -j$(nproc)\nsudo make -C build install\n</code></pre>"},{"location":"building/#building-from-source-macos","title":"Building from Source - macOS","text":"<p>Both arm64 and x64 should build cleanly with the below commands.</p> <p>To install Valhalla on macOS, you need to install its dependencies with Homebrew:</p> <pre><code># install dependencies (automake &amp; czmq are required by prime_server)\nbrew install automake cmake libtool protobuf-c libspatialite pkg-config sqlite3 jq curl wget czmq lz4 spatialite-tools unzip luajit boost\n# following packages are needed for running Linux compatible scripts\nbrew install bash coreutils binutils\n# Update your PATH env variable to include /usr/local/opt/binutils/bin:/usr/local/opt/coreutils/libexec/gnubin\n</code></pre> <p>Now, clone the Valhalla repository</p> <pre><code>git clone --recurse-submodules https://github.com/valhalla/valhalla.git\n</code></pre> <p>Then, build <code>prime_server</code>.</p> <p>After getting the dependencies install it with e.g.:</p> <pre><code># will build to ./build\ncmake -B build -DCMAKE_BUILD_TYPE=Release\nmake -C build -j$(sysctl -n hw.physicalcpu)\nsudo make -C build install\n</code></pre>"},{"location":"building/#building-from-source-windows","title":"Building from Source - Windows","text":"<p>It's recommended to work with the following toolset:</p> <ul> <li>Visual Studio with C++ support</li> <li>Visual Studio Code (easier and lighter to handle)</li> <li>vcpkg to install packages</li> <li>CMake</li> </ul> <p>Install the dependencies with <code>vcpkg</code>:</p> <pre><code>git -C C:\\path\\to\\vcpkg checkout f330a32\n# only build release versions for vcpkg packages\necho.set(VCPKG_BUILD_TYPE Release)&gt;&gt; path\\to\\vcpkg\\triplets\\x64-windows.cmake\ncd C:\\path\\to\\valhalla\nC:\\path\\to\\vcpkg.exe install --triplet x64-windows\n</code></pre> <p>Let CMake configure the build with the required modules enabled. The final command for <code>x64</code> could look like</p> <pre><code>\"C:\\Program Files\\CMake\\bin\\cmake.EXE\" --no-warn-unused-cli -DENABLE_TOOLS=ON -DENABLE_DATA_TOOLS=ON -DENABLE_PYTHON_BINDINGS=ON -DENABLE_HTTP=ON -DENABLE_CCACHE=OFF -DENABLE_SERVICES=OFF -DENABLE_BENCHMARKS=OFF -DENABLE_TESTS=OFF -DVCPKG_TARGET_TRIPLET=x64-windows -DCMAKE_TOOLCHAIN_FILE=path\\to\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -Hpath/to/valhalla -Bpath/to/valhalla/build -G \"Visual Studio 16 2019\" -T host=x64 -A x64\n</code></pre> <p>Run the build for all targets.</p> <pre><code>cmake -B build -S C:\\path\\to\\valhalla --config Release -- /clp:ErrorsOnly /p:BuildInParallel=true /m:8\n</code></pre> <p>The artifacts will be built to <code>./build/Release</code>.</p>"},{"location":"building/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>if the build fails on something with <code>date_time</code>, chances are you don't have <code>make</code> and/or <code>awk</code> installed, which is needed to properly configure <code>third_party/tz</code>. Even so, it might still fail because the used MS shell can't handle <code>mv</code> properly. In that case simply mv <code>third_party/tz/leapseconds.out</code> to <code>third_party/tz/leapseconds</code> and start the build again</li> </ul>"},{"location":"building/#include-valhalla-as-a-project-dependency","title":"Include Valhalla as a project dependency","text":"<p>When importing <code>libvalhalla</code> as a dependency in a project, it's important to know that we're using both CMake and <code>pkg-config</code> to resolve our own dependencies. Check the root <code>CMakeLists.txt</code> for details. This is important in case you'd like to bring your own dependencies, such as cURL or protobuf. It's always safe to use <code>PKG_CONFIG_PATH</code> environment variable to point CMake to custom installations, however, for dependencies we resolve with <code>find_package</code> you'll need to check CMake's built-in <code>Find*</code> modules on how to provide the proper paths.</p> <p>To resolve <code>libvalhalla</code>'s linker/library paths/options, we recommend to use <code>pkg-config</code> or <code>pkg_check_modules</code> (in CMake).</p> <p>Currently, <code>rapidjson</code>, <code>date</code> &amp; <code>dirent</code> (Windows only) headers are vendored in <code>third_party</code>. Consuming applications are encouraged to use <code>pkg-config</code> to resolve Valhalla and its dependencies which will automatically install those headers to <code>/path/to/include/valhalla/third_party/{rapidjson, date, dirent.h}</code> and can be <code>#include</code>d appropriately.</p>"},{"location":"building/#running-valhalla-server-on-unix","title":"Running Valhalla server on Unix","text":"<p>The following script should be enough to make some routing data and start a server using it.</p> <p>Tip</p> <p>Instructions for running an elevation lookup service with Valhalla.</p> <pre><code># download some data and make tiles out of it\n# NOTE: you can feed multiple extracts into pbfgraphbuilder\nwget https://download.geofabrik.de/europe/switzerland-latest.osm.pbf https://download.geofabrik.de/europe/liechtenstein-latest.osm.pbf\n# get the config and setup\nmkdir -p valhalla_tiles\nvalhalla_build_config --mjolnir-tile-dir ${PWD}/valhalla_tiles --mjolnir-tile-extract ${PWD}/valhalla_tiles.tar --mjolnir-timezone ${PWD}/valhalla_tiles/timezones.sqlite --mjolnir-admin ${PWD}/valhalla_tiles/admins.sqlite &gt; valhalla.json\n# build timezones.sqlite to support time-dependent routing\nvalhalla_build_timezones &gt; valhalla_tiles/timezones.sqlite\n# build admins.sqlite to support admin-related properties such as access restrictions, driving side, ISO codes etc\nvalhalla_build_admins -c valhalla.json switzerland-latest.osm.pbf liechtenstein-latest.osm.pbf\n# build routing tiles\nvalhalla_build_tiles -c valhalla.json switzerland-latest.osm.pbf liechtenstein-latest.osm.pbf\n# tar it up for running the server\n# either run this to build a tile index for faster graph loading times\nvalhalla_build_extract -c valhalla.json -v\n# or simply tar up the tiles\nfind valhalla_tiles | sort -n | tar cf valhalla_tiles.tar --no-recursion -T -\n\n# grab the demos repo and open up the point and click routing sample\ngit clone --depth=1 --recurse-submodules --single-branch --branch=gh-pages https://github.com/valhalla/demos.git\nfirefox demos/routing/index-internal.html &amp;\n# NOTE: set the environment pulldown to 'localhost' to point it at your own server\n\n# start up the server\nvalhalla_service valhalla.json 1\n# curl it directly if you like:\ncurl http://localhost:8002/route --data '{\"locations\":[{\"lat\":47.365109,\"lon\":8.546824,\"type\":\"break\",\"city\":\"Z\u00fcrich\",\"state\":\"Altstadt\"},{\"lat\":47.108878,\"lon\":8.394801,\"type\":\"break\",\"city\":\"6037 Root\",\"state\":\"Untere Waldstrasse\"}],\"costing\":\"auto\",\"directions_options\":{\"units\":\"miles\"}}' | jq '.'\n\n#HAVE FUN!\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to Valhalla. If you would like to report an issue, or even better fix an existing one, please use the Valhalla issue tracker on GitHub.</p> <p>There are many ways to make meaningful contributions to the project:</p> <ul> <li>file issues &amp; bugs with clear and easily reproducible instructions</li> <li>contribute bug fixes</li> <li>contribute feature implementations, for larger features/changes its best to open an issue asking for feedback before starting implementation</li> <li>improve translations on Transifex</li> </ul>"},{"location":"contributing/#code-contributions","title":"Code contributions","text":"<p>First time? Read Contributing to a project.</p> <p>We appreciate the community picking up and fixing bugs or even implementing new features. There are a few things to follow/be aware of when working on Valhalla:</p> <ul> <li>we currently use the C++20 standard</li> <li>we use <code>pre-commit</code> to make sure commits are formatted &amp; linted: run <code>./scripts/format.sh</code> once and it'll be installed</li> <li><code>clang-format</code>/<code>clang-tidy</code> is used to format/lint the C++ code, <code>black</code> &amp; <code>flake8</code> format/lint Python code</li> <li><code>ASan</code> is run in CI, but without its integrated leak sanitizer due to platform issues</li> <li>we ask for unit tests to demonstrate a working bug fix or feature implementation, please feel free to ask us for instructions in the PR</li> <li>don't force-push once you got the first review; this will make it easier for reviewers to track how their change requests are being addressed</li> </ul> <p>Before opening a PR we'd ask you to format &amp; lint the code:</p> <pre><code># installs the pre-commit hook\n./scripts/format.sh\npre-commit run --all-files\n\n# optionally run clang-tidy\n# needs the compile_commands.json, we have to rebuild Valhalla\ncmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=On &amp;&amp; make -C build\n./scripts/clang-tidy-only-diff.sh\n\n# optionally run with ASan\ncmake -B build -DENABLE_ADDRESS_SANITIZER=ON -DCMAKE_BUILD_TYPE=Debug &amp;&amp; make -C build\n# if the leak sanitizer is problematic, you can disable it with\nexport ASAN_OPTIONS=detect_leaks=0\n</code></pre>"},{"location":"contributing/#unitintegration-tests","title":"Unit/integration Tests","text":"<p>We highly encourage running and updating the tests to make sure no regressions have been made. We use the GoogleTest suite and also created our own test framework called \"gurka\" (the Norsk counterpart to OSRM's \"cucumber\"), to easily test custom-built maps. Check out more information in the test docs.</p> <p>To build and run all tests:</p> <pre><code>make check -j$(nproc)\n</code></pre> <p>To run an individual test, first move into the <code>./build</code> directory (lots of paths in the tests are relative):</p> <pre><code>cd build\nmake run-&lt;test name&gt;\n</code></pre> <p>Coverage reports are automatically generated using <code>codecov</code> for each pull request, but you can also build them locally by passing <code>-DENABLE_COVERAGE=On</code> and running <code>make coverage</code>.</p>"},{"location":"contributing/#performance-tests","title":"Performance tests","text":"<p>This will mostly be performed by the maintainers before we merge PRs which could have a significant impact on performance or quality.</p> <p>Workflow:</p> <ol> <li>Take a giant file with routes (&gt; 10K).</li> <li>Spin up the service.</li> <li>Run the requests with <code>./run_route_scripts/run_with_server.py</code>.</li> </ol> <p>We can alter the logic for the requests inside that script, depending on what we want to test:</p> <pre><code>./run_route_scripts/run_with_server.py \\\n    --test-file 'auto.txt' \\\n    --url 'http://localhost:8002/route' \\\n    --concurrency 20 \\\n    --format 'csv'\n</code></pre>"},{"location":"contributing/#compiler-tests","title":"Compiler tests","text":"<p>We add a placeholder CMake project at <code>test/compiler_checks</code>, which can be used to make assertions about non-standard behavior to be able to quickly judge compatibility across a range of compilers.</p> <p>To use this, add your executable(s) code, they will be picked up automatically by CMake. Then push to a branch and use the manual trigger of the <code>check_compilers.yml</code> GHA workflow to run it.</p>"},{"location":"contributing/#translation-contributions","title":"Translation contributions","text":"<p>Valhalla currently supports almost 30 languages with &gt; 95% translation coverage. If you find that Valhalla's output instructions are not supported or not optimal in your favorite language, it'd be great if you took the time to contribute improvements. We're using Transifex to manage translations and try to download all improvements before each release.</p> <p>You can find more information in the dedicated doc.</p>"},{"location":"contributing/#documentation-contributions","title":"Documentation contributions","text":"<p>Valhalla uses Material for MkDocs to create project documentation. All relevant files are in the <code>docs/</code> directory.</p> <p>Additionally, some pages are made to be shown on GitHub (<code>README.md</code>, <code>CONTRIBUTING.md</code>, etc). See About writing and formatting on GitHub for more info.</p>"},{"location":"contributing/#publishing","title":"Publishing","text":"<p>Documentation is published to GitHub pages via GitHub Actions on every push to <code>master</code> branch.</p> <p>See <code>.github/workflows/gh-pages.yml</code> file for more info.</p>"},{"location":"decoding/","title":"Decode a route shape","text":"<p>Valhalla routing, map-matching, and elevation services use an encoded polyline format to store a series of latitude, longitude coordinates as a single string. Polyline encoding greatly reduces the size of the route response or map-matching request, especially for longer routes or GPS traces. A description is found here: polyline encoding.</p> <p>Note: Valhalla APIs use six digits of decimal precision.</p> <p>It is very important that you use six digits, rather than five as referenced in the Google algorithms documentation. With fewer than six digits, your locations are incorrectly placed (commonly, in the middle of an ocean), and you may receive errors with your API requests.</p> <p>Below are some sample algorithms to decode the string to create a list of latitude,longitude coordinates. Using this demo tool, you can also paste an encoded polyline string, decode it, and see the locations on a map (and save to GeoJSON). Use it to test and verify that your points are placed where you expected them.</p>"},{"location":"decoding/#javascript","title":"JavaScript","text":"<p>Here is an example of decoding in JavaScript.</p> <pre><code>// This is adapted from the implementation in Project-OSRM\n// https://github.com/DennisOSRM/Project-OSRM-Web/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\npolyline.decode = function(str, precision) {\n    var index = 0,\n        lat = 0,\n        lng = 0,\n        coordinates = [],\n        shift = 0,\n        result = 0,\n        byte = null,\n        latitude_change,\n        longitude_change,\n        factor = Math.pow(10, precision || 6);\n\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    while (index &lt; str.length) {\n\n        // Reset shift, result, and byte\n        byte = null;\n        shift = 0;\n        result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte &amp; 0x1f) &lt;&lt; shift;\n            shift += 5;\n        } while (byte &gt;= 0x20);\n\n        latitude_change = ((result &amp; 1) ? ~(result &gt;&gt; 1) : (result &gt;&gt; 1));\n\n        shift = result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte &amp; 0x1f) &lt;&lt; shift;\n            shift += 5;\n        } while (byte &gt;= 0x20);\n\n        longitude_change = ((result &amp; 1) ? ~(result &gt;&gt; 1) : (result &gt;&gt; 1));\n\n        lat += latitude_change;\n        lng += longitude_change;\n\n        coordinates.push([lat / factor, lng / factor]);\n    }\n\n    return coordinates;\n};\n</code></pre>"},{"location":"decoding/#c-11","title":"C++ 11","text":"<p>Here is an example of decoding in C++11</p> <pre><code>#include &lt;vector&gt;\n\nconstexpr double kPolylinePrecision = 1E6;\nconstexpr double kInvPolylinePrecision = 1.0 / kPolylinePrecision;\n\nstruct PointLL {\n  float lat;\n  float lon;\n};\n\nstd::vector&lt;PointLL&gt; decode(const std::string&amp; encoded) {\n  size_t i = 0;     // what byte are we looking at\n\n  // Handy lambda to turn a few bytes of an encoded string into an integer\n  auto deserialize = [&amp;encoded, &amp;i](const int previous) {\n    // Grab each 5 bits and mask it in where it belongs using the shift\n    int byte, shift = 0, result = 0;\n    do {\n      byte = static_cast&lt;int&gt;(encoded[i++]) - 63;\n      result |= (byte &amp; 0x1f) &lt;&lt; shift;\n      shift += 5;\n    } while (byte &gt;= 0x20);\n    // Undo the left shift from above or the bit flipping and add to previous\n    // since its an offset\n    return previous + (result &amp; 1 ? ~(result &gt;&gt; 1) : (result &gt;&gt; 1));\n  };\n\n  // Iterate over all characters in the encoded string\n  std::vector&lt;PointLL&gt; shape;\n  int last_lon = 0, last_lat = 0;\n  while (i &lt; encoded.length()) {\n    // Decode the coordinates, lat first for some reason\n    int lat = deserialize(last_lat);\n    int lon = deserialize(last_lon);\n\n    // Shift the decimal point 5 places to the left\n    shape.emplace_back(static_cast&lt;float&gt;(static_cast&lt;double&gt;(lat) *\n                                          kInvPolylinePrecision),\n                       static_cast&lt;float&gt;(static_cast&lt;double&gt;(lon) *\n                                          kInvPolylinePrecision));\n\n    // Remember the last one we encountered\n    last_lon = lon;\n    last_lat = lat;\n  }\n  return shape;\n}\n</code></pre>"},{"location":"decoding/#python","title":"Python","text":"<p>Here is an example of decoding in Python</p> <pre><code>#!/usr/bin/env python\n\nimport sys\n\n#six degrees of precision in valhalla\ninv = 1.0 / 1e6;\n\n#decode an encoded string\ndef decode(encoded):\n  decoded = []\n  previous = [0,0]\n  i = 0\n  #for each byte\n  while i &lt; len(encoded):\n    #for each coord (lat, lon)\n    ll = [0,0]\n    for j in [0, 1]:\n      shift = 0\n      byte = 0x20\n      #keep decoding bytes until you have this coord\n      while byte &gt;= 0x20:\n        byte = ord(encoded[i]) - 63\n        i += 1\n        ll[j] |= (byte &amp; 0x1f) &lt;&lt; shift\n        shift += 5\n      #get the final value adding the previous offset and remember it for the next\n      ll[j] = previous[j] + (~(ll[j] &gt;&gt; 1) if ll[j] &amp; 1 else (ll[j] &gt;&gt; 1))\n      previous[j] = ll[j]\n    #scale by the precision and chop off long coords also flip the positions so\n    #its the far more standard lon,lat instead of lat,lon\n    decoded.append([float('%.6f' % (ll[1] * inv)), float('%.6f' % (ll[0] * inv))])\n  #hand back the list of coordinates\n  return decoded\n\nprint(decode(sys.argv[1]))\n</code></pre>"},{"location":"decoding/#r","title":"R","text":"<p>Here is an example of decoding in R.</p> <pre><code>library(tidyverse)\n\ndecode &lt;- function(encoded) {\n  chars &lt;- stringr::str_split(encoded, \"\")[[1]]\n  lats &lt;- vector(mode = \"integer\", length = 1)\n  lons &lt;- vector(mode = \"integer\", length = 1)\n  i &lt;- 0\n\n  while (i &lt; length(chars)){\n    shift &lt;- 0\n    result &lt;- 0\n    byte &lt;- 0x20L\n\n    while (byte &gt;= 0x20) {\n      i &lt;- i + 1\n      byte &lt;- chars[[i]] %&gt;% utf8ToInt() - 63\n      result &lt;- bitwOr(result, bitwAnd(byte, 0x1f) %&gt;% bitwShiftL(shift))\n      shift &lt;- shift + 5\n      if (byte &lt; 0x20) break\n    }\n\n    if (bitwAnd(result, 1)) {\n      result &lt;- result %&gt;% bitwShiftR(1) %&gt;% bitwNot()\n    } else {\n      result &lt;- result %&gt;% bitwShiftR(1)\n    }\n\n    lats &lt;- c(lats, (lats[[length(lats)]] + result))\n\n    shift &lt;- 0\n    result &lt;- 0\n    byte &lt;- 10000L\n\n    while (byte &gt;= 0x20) {\n      i &lt;- i + 1\n      byte &lt;- chars[[i]] %&gt;% utf8ToInt() - 63\n      result &lt;- bitwOr(result, bitwAnd(byte, 0x1f) %&gt;% bitwShiftL(shift))\n      shift &lt;- shift + 5\n      if (byte &lt; 0x20) break\n    }\n\n    if (bitwAnd(result, 1)) {\n      result &lt;- result %&gt;% bitwShiftR(1) %&gt;% bitwNot()\n    } else {\n      result &lt;- result %&gt;% bitwShiftR(1)\n    }\n\n    lons &lt;- c(lons, (lons[[length(lons)]] + result))\n  }\n\n  decoded &lt;- tibble::tibble(lat = lats[2:length(lats)]/1000000,\n                            lng = lons[2:length(lons)]/1000000)\n\n  return (decoded)\n}\n</code></pre>"},{"location":"decoding/#go","title":"Go","text":"<pre><code>func decodePolyline(encoded *string, precisionOptional ...int) [][]float64 {\n    // default to 6 digits of precision\n    precision := 6\n    if len(precisionOptional) &gt; 0 {\n        precision = precisionOptional[0]\n    }\n    factor := math.Pow10(precision)\n\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    lat, lng := 0, 0\n    var coordinates [][]float64\n    index := 0\n    for index &lt; len(*encoded) {\n        // Consume varint bits for lat until we run out\n        var byte int = 0x20\n        shift, result := 0, 0\n        for byte &gt;= 0x20 {\n            byte = int((*encoded)[index]) - 63\n            result |= (byte &amp; 0x1f) &lt;&lt; shift\n            shift += 5\n            index++\n        }\n\n        // check if we need to go negative or not\n        if (result &amp; 1) &gt; 0 {\n            lat += ^(result &gt;&gt; 1)\n        } else {\n            lat += result &gt;&gt; 1\n        }\n\n        // Consume varint bits for lng until we run out\n        byte = 0x20\n        shift, result = 0, 0\n        for byte &gt;= 0x20 {\n            byte = int((*encoded)[index]) - 63\n            result |= (byte &amp; 0x1f) &lt;&lt; shift\n            shift += 5\n            index++\n        }\n\n        // check if we need to go negative or not\n        if (result &amp; 1) &gt; 0 {\n            lng += ^(result &gt;&gt; 1)\n        } else {\n            lng += result &gt;&gt; 1\n        }\n\n        // scale the int back to floating point and store it\n        coordinates = append(coordinates, []float64{float64(lat) / factor, float64(lng) / factor})\n    }\n\n    return coordinates\n}\n</code></pre>"},{"location":"decoding/#rust","title":"Rust","text":"<pre><code>/// Decode a polyline string.\nfn decode_polyline(polyline: &amp;str, precision: f64) -&gt; Vec&lt;(f64, f64)&gt; {\n    let mut shape = Vec::new();\n\n    let mut chars = polyline.chars();\n    let mut last_lat = 0;\n    let mut last_lon = 0;\n\n    // Get the next latitude/longitude tuple.\n    let mut next_coordinates = || {\n        last_lat = parse_polyline_coordinate(&amp;mut chars, last_lat)?;\n        last_lon = parse_polyline_coordinate(&amp;mut chars, last_lon)?;\n        Some((last_lat, last_lon))\n    };\n\n    while let Some((lat, lon)) = next_coordinates() {\n        shape.push((lat as f64 / precision, lon as f64 / precision));\n    }\n\n    shape\n}\n\n/// Parse the next latitude or longitude in the polyline string.\nfn parse_polyline_coordinate(mut chars: impl Iterator&lt;Item = char&gt;, previous: i32) -&gt; Option&lt;i32&gt; {\n    let mut byte = None;\n    let mut result = 0;\n    let mut shift = 0;\n\n    while byte.is_none_or(|b| b &gt;= 0x20) {\n        let byte = *byte.insert(chars.next()? as i32 - 63);\n        result |= (byte &amp; 0x1f) &lt;&lt; shift;\n        shift += 5;\n    }\n\n    let value = if result &amp; 1 != 0 {\n        previous + !(result &gt;&gt; 1)\n    } else {\n        previous + (result &gt;&gt; 1)\n    };\n\n    Some(value)\n}\n\n#[test]\nfn decode_polyline6() {\n    let x = decode_polyline(\"e~epoA|jfpOiDaK\", 1E6);\n    let decoded = vec![(42.225139, -8.670911), (42.225224, -8.670718)];\n    assert_eq!(x, decoded);\n}\n</code></pre>"},{"location":"elevation/","title":"Elevation Lookup Service","text":"<p>This document describes how to run an elevation lookup service using Valhalla. Documentation for querying this service can be found here: elevation-api-docdocs.</p>"},{"location":"elevation/#running","title":"Running","text":"<p>The easiest way to start an elevation service is to run valhalla via Docker, download elevation data, and start the service. Or you can build Valhalla from source. See the main README for installation instructions.</p> <p>The following bash should be enough to make some get some elevation data and start a server using it:</p> <pre><code># Be sure that the parallel and curl dependencies are installed\nsudo apt-get install parallel\nsudo apt-get install curl\n# grab data for the whole world (it's about 1.6TB) or a smaller bounding box\nvalhalla_build_elevation -180 180 -90 90 ./elevation_tiles $(nproc)\n#configure the server\nvalhalla_build_config --additional-data-elevation ./elevation_tiles &gt; config.json\n#start up the server with the config and number of threads\nvalhalla_service config.json 1\n#curl it directly if you like:\ncurl http://localhost:8002/height --data '{\"range\":true,\"shape\":[{\"lat\":40.712431,\"lon\":-76.504916},{\"lat\":40.712275,\"lon\":-76.605259},{\"lat\":40.712122,\"lon\":-76.805694},{\"lat\":40.722431,\"lon\":-76.884916},{\"lat\":40.812275,\"lon\":-76.905259},{\"lat\":40.912122,\"lon\":-76.965694}]' | jq '.'\n\n#HAVE FUN!\n</code></pre>"},{"location":"elevation/#see-also","title":"See Also","text":"<ul> <li>API docs for <code>/height</code> endpoint</li> <li>Skadi module for working with digital elevation model (DEM) data</li> <li>Terrain tiles for download from Amazon Web Services Public Datasets program</li> </ul>"},{"location":"incidents/","title":"Incidents","text":"<p>Valhalla supports loading incidents in the form of pbf format valhalla-shaped tiles. That means that we have a proto definition which describes the tile format in such a way that code can be generated to access the data but also that the geograph area a tile covers matches those of the tiles that are natively supported in valhalla. Very briefly, the incident format has a vector of incident locations objects each of which specify the location along an edge in the corresponding graph tile where the incident occurs (begins/ends). There is also a vector of metadata which is indexed by the incident location information. Here's some pseudo code to give you the gist:</p> <pre><code>struct incident_tile{\n  struct locations {\n    uint32_t edge_index;   // the index of the edge in the corresponding graph tile\n    float start_pct;       // the percent along the edge the incident starts\n    float end_pct;         // the percent along the edge the incident ends\n    size_t metadata_index; // the index into the metadata vector describing the incident\n  };\n\n  struct metadata {\n    enum struct event_type:uint8_t {\n      CONSTRUCTION = 0,\n      // ... many more\n    };\n    std::string description;\n    //... many more see the proto file\n  };\n\n  // locations of incidents along edges, sorted by edge id\n  std::vector&lt;location&gt; locations;\n  // metadata to go along with each incident\n  std::vector&lt;metadata&gt; metadatas;\n};\n</code></pre>"},{"location":"incidents/#runtime-support","title":"Runtime support","text":"<p>If your request enables the <code>incidents</code> attribute filter and both incident tiles are available and the library is configured to use them, then incidents along paths will be attached to <code>TripLeg</code>s as they are created. These are then serialized into json as their own top level object.</p>"},{"location":"incidents/#tile-access","title":"Tile access","text":"<p>Much like graph tile, incident tiles are loaded from a configured directory. Since the tiles are not fixed size (protobuf and unknown number of incidens per tile) the idea here is that we will need to continually refresh the tiles from the directory. There are a couple of assumptions that we are making:</p> <ul> <li>its unlikely that incidents change frequently</li> <li>its unlikely that there are large numbers of incidents</li> <li>incidents will not affect routing algorithms computations</li> </ul> <p>The graphreader will then call a singleton whose job it is to give access to the available incident tiles from the directory. Access is used in triplegbuilder to associate incidents to the pbf route leg. The way these incidents are accessed is via binary search to find the corresponding incident for the edge index. We also mark a bit in the speed record for the edge to say that a given edge should have an incident. Upon seeing this bit set to true in the graphreader we will go look up the incident from the incident tile via the singleton.</p>"},{"location":"incidents/#how-are-incidents-refreshed","title":"How are incidents refreshed","text":"<p>This deserves an explanation because its the trickier part. The model we use here is a class with a private constructor and one public static function. That function statically initializes a singleton instance of this class. The class's constructor spawns a thread that runs in the background. That thread is responsible for monitoring the filesystem for new incidents. When the thread is first started, the singleton waits for it to initialize (load all the incidents that are available).</p> <p>The thread and the singleton instance communicate over the thread barrier by sharing a state object. The bulk of communications use atomic booleans (which are hopefully lock free on most implementations). You'll notice a mutex in there as well. The mutex is only used for synchronization of the tile cache, which is an <code>unordered_map</code>. Synchronization is needed because the <code>unordered_map</code> may reallocate when new tiles are added to it. Thus this synchronization is also conditional. When the tileset is static, ie. when its a memory mapped tar, we do not need to use the mutex to synchronize and instead preallocate all the slots needed for the cache. The state object shared between the threads is wrapped in a <code>shared_ptr</code>, from the code comments:</p> <pre><code>// we use a shared_ptr to wrap the state between the watcher thread and the main threads singleton\n// instance. this gives the responsibility to the last living thread to deallocate the state object.\n// if we didn't do this, and the watcher thread were still running when the singleton instance got\n// destructed, then the watcher would be making use of a deallocated state object. this way, if the\n// watcher is last to die it owns the lifetime of the state and if the singleton is the last to die\n// it owns the lifetime of the state. note that we still need to use atomics inside the state as\n// only the shared_ptr itself is thread safe, not the thing it points to\n</code></pre> <p>There are two modes for the incident loading singleton, one which does directory scans (<code>mjolnir.incident_dir</code> in the config), which on a modern ssd where changes are happening to the incident directory, takes 15 seconds for a planets worth of incident tiles. The second mode is a memory mapped log file which tells the timestamp when an incident tile was last changed rather than using mtime of the files on the filesystem. This can be configured with the <code>mjolnir.incident_log</code> config option and takes generally subsecond on modern ssds to complete for updates since it doesnt need to scan the whole directory.</p> <p>Since there is only one thread (per process) who is in charge of updating incidents we need to be worried about the health of this thread. There is one other configuration options to do with the healthiness of this thread. This config option is called <code>mjolnir.max_incident_loading_latency</code> and controls how long a round of incident updates can take before we log an error that the update was latent.</p>"},{"location":"locales/","title":"Narrative language files","text":"<p>Valhalla supports localized instructions in multiple languages for both textual and verbal phrases. All localized text is managed in JSON files in the locales directory. We rely on external contributors to provide translations of these phrases to other languages.</p>"},{"location":"locales/#contributing-translations","title":"Contributing translations","text":"<p>The recommended way to contribute translations is on Transifex. If you prefer you may also skip Transifex and edit the language files directly.</p>"},{"location":"locales/#translating-on-transifex-recommended","title":"Translating on Transifex (Recommended)","text":"<p>Follow these steps to start contributing a translation:</p> <ol> <li>Sign up for a free account at https://www.transifex.com/.</li> <li>Navigate to https://www.transifex.com/explore/projects/ and search for the <code>Valhalla Phrases</code> project.</li> <li>Submit a request to join the team for the languages you know. You may also request a new language if yours does not appear in the list.</li> <li>Wait for an email with an invitation to start translating.</li> <li>From the dashboard, navigate to the Translate page for your chosen language.</li> <li>Select the <code>en-US.json</code> source file to translate from.</li> <li>Before you start translating make sure to filter out any phrases with the <code>notranslate</code> tag. Apply this filter by selecting Tag &gt; Doesn't contain tag &gt; notranslate.</li> <li>For more information on how to use Transifex, check out the getting started guide.</li> </ol> <p>Once a language is 100% translated, the project maintainers will be notified and we will make a PR with your updates. Thank you for your contribution!</p>"},{"location":"locales/#translating-language-files-directly-advanced","title":"Translating language files directly (Advanced)","text":"<p>Follow these instructions if you prefer to edit the JSON files directly without Transifex.</p>"},{"location":"locales/#how-to-contribute-a-new-narrative-language-file","title":"How to contribute a new narrative language file","text":"<ol> <li> <p>Copy the <code>en-US.json</code> to <code>&lt;NEW_LANGUAGE_TAG&gt;.json</code> Using IETF BCP 47 as reference - the typical format for the <code>&lt;NEW_LANGUAGE_TAG&gt;</code> is: &lt;ISO 639 two-letter language code&gt;-&lt;ISO 3166 two-letter country code&gt; Czech/Czech Republic example: <code>cs-CZ</code></p> </li> <li> <p>Update the <code>posix_locale</code> value in your new file. The character encoding must be UTF-8. The typical format is: &lt;ISO 639 two-letter language code&gt;_&lt;ISO 3166 two-letter country code&gt;.UTF-8 Czech/Czech Republic <code>posix_locale</code> example: <code>cs_CZ.UTF-8</code></p> </li> <li> <p>Update the <code>aliases</code> array in your new file. A typical alias entry is the ISO 639 two-letter language code without the ISO 3166 two-letter country code. The alias entry must be unique across language files. Czech <code>aliases</code> entry example: <code>cs</code></p> </li> <li> <p>Do not translate the JSON keys or phrase tags. An example using the ramp instruction: </p> </li> <li> <p>Please translate the JSON values. As needed, reorder the phrase words and tags - the tags must remain in the phrase. Do not update <code>example_phrases</code>! We want it stay English.</p> </li> <li> <p>Run <code>make check</code> to verify the tests pass OR move on to step#7 and we can help verify.</p> </li> <li> <p>Submit a pull request for review. Thank you!</p> </li> </ol>"},{"location":"locales/#adding-new-instruction-strings","title":"Adding new instruction strings","text":"<p>TODO(nils): I don't think that's how it's supposed to work (anymore?). If I understand correctly, we'd upload a new <code>en_US.json</code> to Transifex and that'll take care of copying the new stuff to existing translation files.</p> <ol> <li> <p>First add the new strings in en-US.json. The JSON keys are used by narrative_builder to select the instruction template string.</p> </li> <li> <p>Sync the new strings to each new narrative language file by running <code>./merge-en.sh</code>. This will copy the new English strings to each new language.</p> </li> <li> <p>Update the English strings in each language file.</p> </li> </ol>"},{"location":"locales/#instruction-descriptions","title":"Instruction descriptions","text":"<p><code>TODO</code></p>"},{"location":"locales/#tag-descriptions","title":"Tag descriptions","text":"<p><code>TODO</code></p>"},{"location":"locales/#syncing-with-transifex","title":"Syncing with Transifex","text":"<p>Use the Transifex command line client, <code>tx</code>, to sync locale files with the Transifex website.</p>"},{"location":"locales/#install","title":"Install","text":"<ul> <li>Install tx.</li> <li>Get an API secret from your settings page.</li> <li>Run <code>tx status</code> in the root valhalla directory to confirm.</li> </ul>"},{"location":"locales/#one-time-setup","title":"One-time setup","text":"<p>These were the steps taken to setup tx for the first time, you can probably just skip to the next section.</p> <ul> <li>Run <code>tx init</code> in the root directory. This will walk you through creating the <code>.tx/config</code> file.</li> <li>Use <code>locales/en-US.json</code> as the path to the source file.</li> <li>Use <code>locales/&lt;lang&gt;.json</code> as the path to the translation files.</li> <li>Use <code>Valhalla</code> as the Organization name and <code>Valhalla Phrases</code> as the project name.</li> </ul> <p>To learn more about the Config command, visit https://docs.transifex.com/client/config.</p>"},{"location":"locales/#useful-commands","title":"Useful commands","text":""},{"location":"locales/#pulling-translation-updates-from-transifex","title":"Pulling translation updates from Transifex","text":"<p>Pull acceptable translation files with 16 threads using <code>git</code> timestamps (else it'll use filesystem timestamps which seems completely wrong):</p> <pre><code>tx pull --minimum-perc 70 --workers 16 --use-git-timestamps\n</code></pre> <p>Use this command to pull all changes from Transifex into the Valhalla repo (will contain the ones not &gt; 70%).</p> <pre><code>tx pull --all\n</code></pre> <p>Or for just one language (use --force to overwrite local):</p> <pre><code>tx pull --language &lt;lang&gt; --force\n</code></pre>"},{"location":"locales/#pulling-english-source-file-updates-from-transifex","title":"Pulling English source file updates from Transifex","text":"<p>When the source file en-US.json has been updated on Transifex manually.</p> <pre><code>tx pull --source\n</code></pre>"},{"location":"locales/#pushing-translation-updates-to-transifex","title":"Pushing translation updates to Transifex","text":"<p>When edits have been made to the locale JSON files manually in git but not in Transifex.</p> <p>NOTE: this command will overwrite the file on Transifex, you will want to pull updates first and resolve any conflicts.</p> <pre><code>tx pull --all\n# resolve conflicts, open PR\ntx push --all\n</code></pre>"},{"location":"locales/#pulling-new-translation-file-from-transifex","title":"Pulling NEW translation file FROM Transifex","text":"<p>Translation files for new languages that are contributed in Transifex are not automatically downloaded by tx:</p> <ol> <li>Pull the new language:     <pre><code>tx pull --languages &lt;lang&gt;\n</code></pre></li> <li>Make sure the new translation filename is following the  convention. <li>Update <code>./.tx/config</code> with the new translation file mapping.</li> <li>Update <code>test/gurka/test_route_with_narrative_languages::lang_phrase</code> vector with the new phrase (best to let if fail after updating with a bogus phrase which will print the correct one)</li>"},{"location":"locales/#pushing-new-translation-file-to-transifex","title":"Pushing NEW translation file TO Transifex","text":"<p>New language files added in Valhalla need to be uploaded to Transifex for external contributors to make updates in the translation interface. Make sure that language does not already have a translation file in Transifex first by trying a pull command.</p> <pre><code>tx pull --language &lt;lang&gt;\n# if no translation exists push up a new one\ntx push --language &lt;lang&gt; --translations\n</code></pre>"},{"location":"loki/","title":"Loki","text":"<p>Loki can be used to associate location information to an underlying graph tile object for use in creating input to the routing engine. In keeping with the Norse mythological theme, the name Loki was chosen as a play on the word locate. Since loki deals mostly with correlating some input (minimally a lat,lon) to an object within a graph tile, this seemed like a fitting name!</p> <p>Loki is essentially a set of various data structures and algorithms which deal with things like: correlating an input location to the underlying graph, partial distance along an edge and filtering edges which shouldn't be considered for correlation.</p>"},{"location":"loki/#components","title":"Components","text":"<p>What follows are some notable components of loki.</p>"},{"location":"loki/#search","title":"Search","text":""},{"location":"loki/#whats-it-do","title":"What's it do?","text":"<p>The primary function of loki is to correlate the given input coordinate(s) to the underlying routing graph by searching over small portions of said graph near said input. The goal is to return information about the graph that can be used by a router to find a path in the graph from one point to another. Generally this is a set of candidate edges for each input coordinate. Additionally the actual correlated (snapped to route network geometry) coordinate is returned which can be useful for things like placing transit egress points on the route network or fun trivia stuff like dropping a point in the atlantic or a massive desert to find the closest signs of civilization to that point.</p>"},{"location":"loki/#hows-it-work","title":"How's it work?","text":"<p>First, we exploit the fact that the graph is tiled and separated into levels of detail. See Why Tiles? for more detail. This is important because it lets us focus our search on specific partitions of the graph which are closest to the input coordinate. Also, note that loki is only interested in the most detailed level as it has all of the edges in the graph, even the lesser importance ones. You might be thinking ok so those tiles must be pretty darn small to make this reasonable (time/space complexity). Because the tiles are a regularly spaced grid, some will land on almost no routable edges and some will land on, well, Tokyo.</p> <p>This may not seem like much of a problem at first but closer inspection reveals its very important to strike a balance between tile size and complexity concerns. The heart of the problem is that we use these tiles for several different use-cases (algorithms) and each has different needs. Performing the actual graph traversal algorithm benefits from loading larger tiles into memory so the expansion of the graph doesn't hit (load more) new tiles so frequently. At the same time you want smaller tiles so that when you need to find just a couple edges nearest to a point you don't need to consider so many edges. There are more concerns but these illustrate the point well enough.</p> <p>So to settle on a size we looked at which operation dominated (in terms of complexity) with the intuition that optimizing things for that would give the most bang for the buck. That lead us to larger (for some value of large) tiles to benefit graph traversal. It did though mean that some tricks needed to be carried out on the graph correlation use-case. We're getting ahead of ourselves though. How did it work with native high detail level tile sizes? You noticed the past tense there right? Foreshadowing!</p> <p>The initial implementation (lets call it v0) of this was very very simple. For a single input coordinate, loki would just open the tile that the coordinate was in, scan through all the nodes in that chunk of the routing graph and return the edges connected to the one that was closest to the input. If there were no nodes in the tile, it would return no result. As you may have guessed though, it was really fast (sub-millisecond in Tokyo). You may also have guessed that it was really annoying. The closest node is often not even connected to the correct edge and can be pretty far away from the input coordinate in sparser tiles. This brings up another point about what a good implementation of loki should do. It should find the most plausible result not just the quickest one. This sounds obvious but of course the two things are at odds.</p> <p>Next we were onto the second implementation (v1 I guess?) which entailed actually looking at the edges' shapes. Now this operation is expensive... The shapes are compressed into strings via LEB128 encoding, which means to look at one we need to decompress it. This is expensive (comparatively), so its important to look at as few as possible. Here is where we run into a problem. We really want to look at all the edges that have shape near the input coordinate, but we have no idea which ones those are without looking at every edge's shape. So we did a few tricks. The first one was that since scanning through the nodes was free (again comparatively) we would do that first and if we were within a certain distance from a node we'd just return that result. This was problematic if the distance threshold wasn't set high enough because it could snap the result to a node on an opposing lane of traffic. Tune the threshold smaller and you make the likelihood of snapping to a node so low its not worth doing. The second trick we employed was using the length of an edge as a heuristic to determine whether an edge should or should not be considered (ie. have its shape decoded) with respect to a given input point. Basically if an edge was long enough to have reached the input point from one of its endpoints it would be considered. This weeded out a lot of short edges that weren't close to the input, but it had the side effect of over emphasizing larger edges nearer to the input. In other words it was not all that fast and there were lots of problems with it: finds result in wrong tile, finds no result because its in the adjacent tile, snaps to the wrong road because of node snapping, finds the wrong road because of over emphasis on longer edges (see issues: #72, #62, #52).</p> <p>So we were in a bit of a terrible state... Wrong results or no results and nothing that was particularly fast (median 130ms across NYC). It was time to come back to the tile size... But honestly it was only affecting this use-case. The case in which you are using the tiles as a geospatial index to limit your search to a small geographic region. So we had an idea. Add an index to each tile at high enough resolution for it to be performant. So we hopped over to mjolnir and did it. Essentially for each tile, we cut it up into a 5x5 set of bins and for each bin we note which edges' shapes pass through it. Mjolnir is what makes our tiles, meaning we do this once at tile creation time so the index is cached with the tile (its basically appended to the end with the shape data and so forth). Another important trick we did was reference the edges in these bins in a global fashion (an edge from another tile can pass into a bin in this tile, I like to call these hairy tiles). This lets us find edges that cross tiles boundaries (one of the problems noted above). Finally we employed one more trick to make the indexes easier to use. The graph is arranged so that you can traverse an edge in both the forward and reverse direction. To do this, each edge is represented by two directed edges (one from A to B and one from B to A). Each of these directed edges has its own id. We only ever store one of these two ids in the bins the edges intersect. This cuts down on redundant shape decoding.</p> <p>So what does the current implementation look like (v2?)? Well, after the indexes were added to the tiles we went to work using them. We wrote a little utility that lets you iterate (kind of like a python generator) over the bins in a closest first fashion. Basically we grab this closest bin first generator, seed it with the input point and iterate over the bins it passes us. If the bin is empty we move on, if its not, we decode the shapes of each edge in the bin and see if any edge was closer to this point than the current known closest. We terminate when either we've searched too far without finding anything or the bin we are about to look in is farther away than our current known closest edge. Since we look at bins in closest first order we shouldn't be able to find anything closer if the closest point in the bin is further than the current known closest edge.</p> <p>This implementation is small, it prunes a lot of search space, it doesn't find the wrong edge (in terms of closeness), it can find things in tiles not containing the input coordinates and of course its way fast (median 4ms across NYC). It does cost in data size but it was measured as a less than %5 increase across the planet tileset.</p>"},{"location":"loki/#whats-next","title":"What's next?","text":"<p>In terms of features there are a few things I didn't mention that the current (and previous) version of the algorithm do provide. The most important of these is probably the filtering out of edges that are not traversable by you for the mode of travel you've selected. For example, you can't drive a car on the Appalachian Trail so if you request a driving route with points along the trail, loki will filter those trail edges out because they don't provide car access. It will end up correlating your coordinates to edges closest to your input which do have car access though.</p> <p>Another feature provided by the current (and previous) version of loki is that of favoring a direction of travel. This is very useful in a mobile navigation context. Say you are speeding down a two lane road when your passenger presses the 'get route' button. As previously mentioned, even if you two are smack in the middle of a long edge with no other connecting edges around, technically there are two results, the edge in the direction you are traveling and the edge in the reverse direction of travel. The thing is, you don't care about the route in the reverse direction of travel. So loki allows you to specify a favored direction of travel and if one of the directions is with in a 90 degree window of that then it will be included in the candidate set passed onto the routing algorithm.</p> <p>You might be noticing a theme here. In some cases we want to reject or favor certain edges based on some criteria (usually derived from the users request parameters). And this is the first area of future work. For a given edge we essentially want to assign a probability which denotes its likelihood of being the actual edge intended in the request. At this point the probability is binary. It either is traversable by your mode of travel or not. It either is in the general direction you are going, or not. It either is the closest edge to your input or not. It would seem we should want to have each of these factors influence a portion of the final probability. This would allow us to add other factors in the future. For example, if the request supplied a street name with the coordinate we could give a higher weighting to edges with similar street names. This means we would want to actually look at least a little bit further than the absolute closest edge in the presence of that edge not matching the provided street name.</p> <p>Another general problem is that of islands of connectivity. Without traversing the route network, one cannot say for certain that two edges are reachable from one another (for a given mode of travel). So it happens with some degree of probability that loki will correlate a pair of inputs but the routing algorithm will find no path between them. In some cases this is by design. In fact at a coarse level, if two regions are not possibly connected, think O'ahu and Mt. Everest, we won't even ask loki to correlate the coordinates to the graph. Even places that are quite close can have reachability issues which indeed should fail to find paths (unless you have a boat/hanglider/climbing gear handy). However there are a number of fairly frequently occurring cases that follow a pattern similar to the following. A user is somewhere on the road network (highly connected). User wants to go to a POI. The POI itself might be a polygon such as a park, the white house or a golf course, which will give an input coordinate as the centroid of that feature. Or it may be a point POI, such as a city center or something relatively small like an overlook on a mountain. The problem with all of these is that their location, the coordinate that will be provided as input to loki was picked so that the feature could be properly labeled on the map. In other words the coordinates are those you'd expect to use if you wanted to see where the thing is. This is often very unhelpful for the purpose of routing. Not only could routing to that label point be suboptimal (the parking for the golf course is not near its centroid), but it could actually put you on an island of limited connectivity. So that when you pass these results to the routing algorithm you won't find a path.</p> <p>To tackle this issue we have a few options. We could at data creation time crawl the route network to find small islands of connectivity. We could mark the edges in these islands so that loki would know to only send them to the routing algorithm if both input coordinates were in the same island. Or we could use a multi-pass approach in which we have the routing algorithm detect when its search is trapped in an island of connectivity and send the list of edges with in back to loki as a set of edges excluded from the correlation process. That latter would seem like the best option at this point in time simply because the information needed to store and time to crawl the tiles to find these small islands of connectivity would be prohibitive.</p> <p>The final area for future work would be an elaboration to what was said earlier about wanting only to look a the highest detail level of route network data. One could conceive of a scenario in which a user has a route and they want to drag a portion of that route so as to force it toward a certain feature. If the route network is dense where that feature lives but the users map is zoomed out such that the user only sees certain route network edges loki should attempt to correlate to those rather than the possibly not visible edges in the area. Essentially when doing a correlation at a course zoom level we may want to exclude certain classes of edges that are unlikely to be visible to the user interacting with the map.</p>"},{"location":"loki/#benchmark","title":"Benchmark","text":"<p>TODO:</p>"},{"location":"meili/","title":"Meili","text":"<p>Meili, provides a set of algorithms and datastructures for map matching. It matches a sequence of locations (usually noisy e.g. GPS trajectory) to the underlying road network. In keeping with the Norse mythological theme, the name Meili, Thor's brother, was chosen. Since map matching is closely related to routing and since Thor is the Valhalla routing library, meili seemed most appropriate. Additionally the main author of this software, @ptpt from team Mapillary  noted that, m\u0115il\u00ec (\u7f8e\u4e3d) means beautiful in Chinese. This is indeed a beautiful collaboration between team Mapillary and team Valhalla! Open source FTW!</p>"},{"location":"meili/#documentation","title":"Documentation","text":"<ol> <li>Overview</li> <li>Library API</li> <li>Configuration</li> <li>The Algorithms</li> </ol>"},{"location":"midgard/","title":"Midgard","text":"<p>Midgard serves as a set of geographic/metric data structures and algorithms for use in essentially all other parts of valhalla. In keeping with the Norse mythological theme, the name Midgard was chosen as it is represents the world as humans know it. Since the software and classes within midgard deal mostly with the maths of our favorite spheroid, this seemed like a fitting name!</p> <p>Midgard contains a set of various geometric data structures and support classes. It also includes algorithms which deal with things like: closest point to line, vector and matrix operations, polyline encoding, logging, projection, tiling, and culling. Midgard also include a variety of constants for time and distance conversions as well as angular measures.</p>"},{"location":"midgard/#components","title":"Components","text":"<p>What follows are some notable components of midgard.</p>"},{"location":"midgard/#2-d-points-and-latitude-longitude","title":"2-D Points and Latitude, Longitude","text":"<p>Midgard includes classes to support two-dimensional points: either Cartesian x,y (Point2) or latitude, longitude (PointLL). Basic operations such as distance between 2 points are provided, with the PointLL providing arc-distance or distance along a spherical earth.</p>"},{"location":"midgard/#2-d-vectors","title":"2-D Vectors","text":"<p>Midgard includes a 2-D vector class. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Basic 2-D vector operations such as dot products, scaling, normalization, projection, and angle computations are provided.</p>"},{"location":"midgard/#line-segments-and-polylines","title":"Line Segments and Polylines","text":"<p>Midgard provides a class supporting 2-D line segments. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Various intersection methods, clipping methods, and distance methods are provided.</p>"},{"location":"midgard/#2-d-bounding-boxes","title":"2-D Bounding Boxes","text":"<p>Midgard includes a class to support 2-D axis-aligned bounding boxes. This is a templated class so it can support either Cartesian coordinates or latitude, longitude coordinates. Methods to determine if points are inside a bounding box are provided as well as methods to find the intersection of 2 bounding boxes. Clipping operations to clip polylines to the bounding box are also provided.</p> <p>A class supporting oriented or general 2-D bounding boxes is also provided.</p>"},{"location":"midgard/#ellipse","title":"Ellipse","text":"<p>Midgard contains a class supporting methods to construct an ellipse, test if a line segment intersects the ellipse, test if an axis-aligned bounding box intersects, and test whether a point is within the ellipse. This is a templated class to work with Point2 (Euclidean x,y) or PointLL (latitude,longitude).</p>"},{"location":"midgard/#tiles","title":"Tiles","text":"<p>Midgard provides a class that provides a uniform (square) tiling system for a specified bounding box and tile size. This is a template class that works with Point2 (Euclidean x,y) or PointLL (latitude,longitude). A unique tile Id is assigned for each tile based on the following rules: Tile numbers start at 0 at the min y, x (lower left) Tile numbers increase by column (x,longitude) then by row (y,latitude) Tile numbers increase along each row by increasing x,longitude. This class contains methods for converting x,y or lat,lng into tile Id and vice-versa.  Methods for relative tiles (using row and column offsets) are also provided. Also includes a method to get a list of tiles covering a bounding box.</p>"},{"location":"midgard/#gridded-data","title":"Gridded Data","text":"<p>Midgard provides a class to store data in a gridded/tiled data structure. Contains methods to mark each tile with data using a compare operator. There is also a method to generate contour lines from isotile data. The contouring method is a derivation from the C code version of CONREC by Paul Bourke: https://paulbourke.net/papers/conrec/</p>"},{"location":"midgard/#distance-approximation","title":"Distance Approximation","text":"<p>Midgard provides a special class to perform distance approximation in latitude, longitude space. This class approximates distance (meters) between two points. This method is more efficient than using spherical distance calculations within the PointLL class. It computes an approximate distance using the pythagorean theorem with the meters of latitude change (exact) and the meters of longitude change at the \"test point\". Longitude is inexact since meters per degree of longitude changes with latitude. This approximation has very little error (less than 1%) if the positions are close to one another (within several hundred meters). Error increases at high (near polar) latitudes. This method will not work if the points cross 180 degrees longitude.</p>"},{"location":"midgard/#polyline-encoding","title":"Polyline Encoding","text":"<p>TODO:</p>"},{"location":"midgard/#logging","title":"Logging","text":"<p>TODO:</p>"},{"location":"midgard/#util","title":"Util","text":"<p>midgard includes a variety of utility methods supporting : TODO</p>"},{"location":"midgard/#sequence","title":"Sequence","text":"<p>TODO:</p>"},{"location":"mjolnir/","title":"Mjolnir","text":"<p>The mjolnir is essentially a set of applications, data structures and algorithms which deal with things like: parsing OSM data extracts, cutting routable \"graph\" tiles, generating tile hierarchies and testing for data deficiencies.  This tiled routing data is used in routing and searching under the valhalla organization.  In keeping with the Norse mythological theme, the name Mj\u00f6lnir was chosen as it represents a weapon of mass destruction.  This seemed fitting since the main application deals mostly with pounding planet sized OSM data into tiny routable tile fragments.</p>"},{"location":"mjolnir/#components","title":"Components","text":"<p>What follows are some notable components of the mjolnir.</p>"},{"location":"odin/","title":"Odin","text":"<p>Odin serves as a directions engine for annotating a path as input from the routing engine for use in navigation. In keeping with the Norse mythological theme, the name Odin was chosen as he has often been noted as being very wise. Since the library deals mostly with providing, hopefully wise, guidance along a path to be used for navigation, this seemed like a fitting name! We've also managed to create a backronym out of Odin which stands for: Open Directions and Improved Narrative.</p> <p>Odin contains a set of various data structures and algorithms which deal with things like: maneuver generation, streetname matching and narrative generation.</p>"},{"location":"odin/#components","title":"Components","text":"<p>What follows are some notable components of the odin.</p>"},{"location":"odin/#maneuver","title":"Maneuver","text":"<p>TODO:</p>"},{"location":"odin/#util","title":"Util","text":"<p>TODO:</p>"},{"location":"releasing/","title":"Releasing a new Valhalla version","text":"<p>We are using https://semver.org/ for versioning with major, minor and patch versions.</p>"},{"location":"releasing/#guarantees","title":"Guarantees","text":"<p>We are giving the following guarantees between versions:</p>"},{"location":"releasing/#major-version-change","title":"Major version change","text":"<ul> <li>There are no guarantees about compatibility of APIs or datasets</li> <li>Breaking changes will be noted as <code>BREAKING</code> in the changelog</li> </ul>"},{"location":"releasing/#minor-version-change","title":"Minor version change","text":"<p>We may introduce forward-compatible changes: query parameters and response properties may be added in responses, but existing properties may not be changed or removed. One exception to this is the addition of new turn types, which we see as forward-compatible changes.</p> <ul> <li>Forward-compatible HTTP API</li> <li>Forward-compatible C++ library API</li> <li>Forward-compatible dataset version</li> </ul>"},{"location":"releasing/#patch-version-change","title":"Patch version change","text":"<ul> <li>No change of query parameters or response formats</li> <li>Compatible HTTP API</li> <li>Compatible C++ library API</li> <li>Compatible data datasets</li> </ul>"},{"location":"releasing/#release-and-branch-management","title":"Release and branch management","text":"<ul> <li>The <code>master</code> branch is for the bleeding edge development</li> <li>We create and maintain release branches <code>x.y</code> to control the release flow</li> <li>We create the release branch once we create release branches once we want to release the first RC</li> <li>RCs go in the release branch, commits needs to be cherry-picked from master</li> <li>No minor or major version will be released without a code-equal release candidates</li> <li>For quality assurance, release candidates need to be staged before tagging a final release</li> <li>Patch versions may be released without a release candidate</li> <li>We may backport fixes to older versions and release them as patch versions</li> </ul>"},{"location":"releasing/#releasing-a-version","title":"Releasing a version","text":"<ol> <li>Update the translations from Transifex, see README.</li> <li>Check out the appropriate release branch <code>x.y</code>.</li> <li>Make sure <code>CHANGELOG.md</code> is up to date.</li> <li>Make sure all tests are passing (e.g. Circle CI gives you a ).</li> <li>Make sure the <code>valhalla/valhalla.h</code> has been updated.</li> <li>Use an annotated tag to mark the release: <code>git tag x.y.z -a</code>. The body of the tag description    should be the changelog entries.</li> <li>Push tags and commits: <code>git push; git push --tags</code></li> <li>On https://github.com/valhalla/valhalla/releases press <code>Draft a new release</code>, write the release    tag <code>x.y.z</code> in the <code>Tag version</code> field, write the changelog entries in the <code>Describe this    release</code> field and press <code>Publish release</code>.</li> </ol>"},{"location":"route_overview/","title":"Overview of how routes are computed","text":"<p>This document provides a brief overview of Valhalla route computation.</p> <p></p>"},{"location":"route_overview/#request-parsing","title":"Request Parsing","text":"<p>Parse incoming request (JSON) to validate inputs. Converts (most) of the incoming request to protocol buffer objects to pass through the individual stages. The exception is currently some costing options for which parsing is deferred until needed within the costing module itself.</p>"},{"location":"route_overview/#finding-candidate-edges","title":"Finding Candidate Edges","text":"<p>The first step within a route is to find candidate edges for each incoming location. This logic is held within the loki directory. A set of nearby edges is found by iterating through bins within a routing graph tile or set of tiles near the location latitude, longitude. Bins are subdivided portions of Valhalla tiles that are currently .05 degrees per bin. Each bin stores a list of Valhalla edges with the bin. Edges that are allowed for the specified costing model are tested to determine the closest point along the geometry or shape of the edge. Special logic manages edges that are in disconnected regions which frequently occur in OpenStreetMap data. Additional candidate edges may be created in these cases. In addition, other filters such as filtering by heading can optionally be applied to narrow the set of candidate edges. </p>"},{"location":"route_overview/#path-computation","title":"Path Computation","text":"<p>Valhalla uses a couple different algorithms to generate the route path.  Code for these algorithms is held within the thor directory. They are all flavors of Dijkstra\u2019s algorithm. The following classes are derived from PathAlgorithm (base class defining the route path interface):</p> <ul> <li>UnidirectionalAStar - This is a forward OR reverse direction A* algorithm which is currently used for time-dependent routing and trivial paths.</li> <li>BidirectionalAStar - This is a bidirectional A* algorithm used for routes that are not time-dependent and are not trivial.</li> <li>MultiModal - This is a forward direction A* algorithm with transit schedule lookup included as well as logic to switch modes between pedestrian and transit. This algorithm is time-dependent due to the nature of transit schedules.</li> </ul> <p>All of Valhalla\u2019s path algorithms use dynamic, run-time costing. Costing logic is held within the sif directory. A base class (DynamicCost) defines the interface that each costing model implements.  A brief overview of the costing design is located here. </p> <p>Forming Trip Legs TripLegBuilder creates the Trip Legs for Valhalla. A route result contains one or more legs, where each leg represents the path between two successive locations. Code for this step is within the thor directory. Each Trip Leg is a sequence of nodes and edges that form a path, created in a forward direction from <code>Node 0</code> to <code>Node 1</code> to...<code>Node N</code>.  Edge and node attributes are added to each leg which will then be passed to Odin to create Trip Directions.  Moreover, TripLegBuilder will add intersecting edge attributes at each node within the path to assist Odin with maneuver generation. </p> <p>Looking at the figure below, our path is from <code>Node 1</code> to <code>Node 2</code> to <code>Node 3</code> to...<code>Node N</code>.  The path (a, f, l) is highlighted in red.  Each arrow represents a directed edge (DE) from Node to Node. Looking at our path, when we are at <code>Node 2</code> we will store the edge information for <code>DE a/b</code> and the attributes(e.g., surface, speed, access, transit information, and etc.) for <code>DE a</code>.  Also, we will store the intersecting edge info for <code>c/d</code>, <code>e/f</code>, and <code>g/h</code>. </p> <p></p> <p>Generating Guidance The route narrative/guidance generating code is located in the odin directory.</p> <ul> <li>Odin inspects the trip leg nodes and edges in reverse order to form an initial list of maneuvers or steps</li> <li>Odin collapses the initial maneuver list to form a concise list of maneuvers</li> <li>Odin adds text and verbal instructions to form trip directions</li> <li>Odin supports these languages for narration instructions </li> </ul>"},{"location":"route_overview/#serializing-the-route-response","title":"Serializing the Route Response","text":"<p>The serialization of the route response takes place in the tyr layer of the Valhalla source code. Tyr is used to handle HTTP requests for a route and communicates with all of the other Valhalla APIs.  Tyr will format output from Odin and supports JSON and protocol buffer (pbf) output.</p> <ul> <li>Serialization logic is split up by API (route, matrix, isochrone, height, locate, and map-matching (trace_route and trace_attributes).</li> <li>route_serializer.cc <ul> <li>serializeDirections(request, path_legs, directions_legs) \u2192 outputs a json string</li> <li>toOSRM - Serialize route response in OSRM compatible format</li> <li>toJSON - Returns a trip object formatted to JSON</li> <li>jsonToProtoRoute(json_route, proto_route) \u2192 used by navigator</li> <li>Transfers the JSON route information returned from a route request into the Route pbf object passed in by reference.</li> </ul> </li> <li>To summarize, Valhalla builds a JSON \u201ctrip\u201d object which contains the locations, route summary with basic info about the trip, a list of legs of the trip, status, units and language.</li> <li>A more in depth description of the results can be found here.</li> </ul>"},{"location":"sif/","title":"Sif","text":"<p>Sif provides dynamic, extensible costing for edges and transitions between edges (turn costs). Its primary use is in the routing engine when forming the best path between locations. In keeping with the Norse mythological theme, the name Sif was chosen since Sif is a companion to Thor.</p> <p>Sif is essentially a set of various data structures and algorithms which deal with things like: correlating an input location to the underlying graph, partial distance along an edge and filtering edges which shouldn't be considered for correlation.</p>"},{"location":"sif/#components","title":"Components","text":"<p>What follows are some notable components of sif.</p>"},{"location":"sif/#dynamic-costing","title":"Dynamic Costing","text":"<p>TODO:</p>"},{"location":"skadi/","title":"Skadi","text":"<p>Skadi can be used to access digital elevation model data which is useful in computing steepness of edges in the route graph or generating an elevation profile along a computed route. In keeping with the Norse mythological theme, the jotunn/goddess Ska\u00f0i was chosen as she is associated, among other things, with the mountains. Since skadi deals mostly with extracting elevation data from various datasets, this seemed like a fitting name!</p> <p>Skadi is essentially a set of various data structures and algorithms which deal with things like: sampling elevation data in an adhoc or evenly sampled manner as well as serving elevation data in structured (json) or raw (geotiff) formats.</p>"},{"location":"skadi/#components","title":"Components","text":"<p>What follows are some notable components of Skadi.</p>"},{"location":"skadi/#sample","title":"Sample","text":"<p>TODO:</p>"},{"location":"skadi/#service","title":"Service","text":"<p>TODO:</p>"},{"location":"speeds/","title":"Speed values in Valhalla APIs","text":"<p>To calculate speed and related factors when routing, such as travel times, Valhalla APIs consider speed limits in the OpenStreetMap source data, defaults for a particular category of road, or a measure of whether the road is in an urban or rural environment.</p> <p>Real-time or historical traffic information is not currently included in speed calculations. Valhalla is working towards these capabilities, and the tiled data structures of Valhalla and dynamic costing approach can readily support traffic information when available.</p>"},{"location":"speeds/#assignment-of-speeds-to-roadways","title":"Assignment of speeds to roadways","text":"<p>Routing data contains two attributes to denote speed: <code>speed</code> and <code>speed_limit</code>.</p> <p>The most important for routing determination is <code>speed</code>, given in units of kilometers per hour. The <code>speed</code> value, along with the length of the roadway edge, determine the travel time along a road section.</p> <p>The <code>speed_limit</code> contains the posted speed limit, if available, and can be used by mobile navigation applications to display the speed limit and possibly alert the driver when it is exceeded.</p> <p>The <code>speed</code> is assigned based on tags within the OpenStreetMap data as follows:</p> <ul> <li><code>max_speed</code>: If a <code>maxspeed</code> tag is available from OSM, that speed is used as the routing speed and the <code>speed_limit</code> is set to that value. Note that <code>maxspeed=none</code> is valid and means the speed limit is unlimited (as on the German Autobahn); in this case we do not set a speed based on <code>maxspeed</code> but rely on the default speeds based on the <code>highway</code> tag (see next bullet point).</li> <li><code>highway</code>:  If there is no <code>maxspeed</code> or <code>maxspeed=none</code> tag, then <code>speed</code> is based on the OSM <code>highway</code> tag. There are a default set of speeds for each <code>highway</code> tag. Note that future work involves implementing country-specific default speeds for highway tags.</li> <li>road density: The road density (the length of drivable roads in kilometers per square kilometer) at each node in the routing graph is estimated during Valhalla data import. The road density is used to determine if a road is in a rural or urban area. Roads in urban areas have their speed reduced if there is no <code>maxspeed</code> tag. In the future, this method may be replaced with a more accurate measure of rural versus urban regions, but density produces adequate results for now.</li> </ul> <p>The <code>speed_type</code> attribute defines whether the assigned routing speed is from a speed limit or based on the highway tag.</p>"},{"location":"terminology/","title":"Mobility glossary","text":"<ul> <li>break location - the start or end point of a route.</li> <li>cost - fixed costs in seconds that are added to both the path cost and the estimated time.</li> <li>costing model - set of costs for particular methods of travel, such as automobile or pedestrian.</li> <li>edge - a line connected between nodes</li> <li>factor - multiply the cost along an edge or road section in a way that influences the path to favor or avoid a particular attribute</li> <li>graph - a set of edges connected by nodes used for building a route</li> <li>location - a latitude, longitude coordinate pair, specified in decimal degrees that determines the routing and order of navigation.</li> <li>maneuver - an operation to be performed during navigation, such as a turn, and the expected duration of the movement.</li> <li>narration - textual guidance describing the maneuver to be performed, such as a turn, distance to travel, and expected time.</li> <li>path - the sequence of edges forming a route</li> <li>penalty - fixed costs in seconds that are only added to the path cost. Penalties can influence the route path determination but do not add to the estimated time along the path.</li> <li>route - sequence of edges and maneuvers forming the best travel path between locations given the available road network, costs, influence factors, and other inputs.</li> <li>short path - a route that attempts to minimize distance traveled over the constituent edges, but may not be the shortest distance.</li> <li>through location - an optional location to influence the route to travel through that location.</li> <li>tiled routing - method of building a path on graph data that has been split into square cells.</li> <li>time - the number of seconds estimated to complete a maneuver or trip, including any additional costs.</li> <li>trip - results of an entire route, including locations, legs, and maneuvers.</li> <li>height - with respect to elevation, the height above or below sea level at a specific location (lat,lng).</li> <li>height with range - computing the range (cumulative distance) and height for a series of lat,lng pairs of a line or shape.  This is very useful for charting/graphing.</li> </ul>"},{"location":"testing/","title":"Unit tests","text":"<p>Valhalla currently uses GoogleTest for unit testing.</p> <ul> <li>The basics are covered in GoogleTest primer</li> <li>More advanced topics  are covered here</li> </ul> <p>Important things to note:</p> <ul> <li><code>EXPECT_XXX</code> macros mark the test as failed but continue execution<ul> <li>Allows to test more at once</li> <li>A preferred way over <code>ASSERT_XXX</code></li> <li><code>ASSERT_XXX</code> family should be used when it's pointless to continue the test<ul> <li>e.g. the method we test returns <code>nullptr</code> instead of a valid pointer</li> </ul> </li> </ul> </li> <li>Tests execution order is unspecified<ul> <li>If the order is needed fixtures or test suite environments may help</li> <li>Sometimes it may hint the test design needs rethinking</li> </ul> </li> <li>Be careful with _ in test names - gtest joins a suite name with test name using _<ul> <li><code>TEST(Foo, Basic_test)</code> and <code>TEST(Foo_Basic, test)</code> will produce a conflict</li> <li>In practice it never happens - no need to worry much about it</li> </ul> </li> <li>Be aware of curly braces <code>{}</code> inside macros<ul> <li>A typical case -&gt; container with initializer list creation inside assert macro</li> <li>Preprocessor is dumb and thinks commas separate the arguments</li> <li><code>ASSERT_EQ(foo, vector{1,2,3});</code></li> <li>Fixing this can be done by adding <code>()</code> - <code>ASSERT_EQ(foo, (vector{1,2,3}));</code></li> </ul> </li> <li>Disabling a test is easy - just prefix its name with <code>DISABLED_</code><ul> <li><code>TEST(PredictiveTraffic, DISABLED_test_predictive_traffic)</code></li> <li>They are still compiled and there is always a warning each time the suite runs</li> </ul> </li> </ul>"},{"location":"thor/","title":"Thor","text":"<p>Thor serves as a routing engine backed by tiled open source routing data. Thor is a companion to Sif which it relies heavily on to determine the appropriate graph traversal. The resulting path can be used as input for creating guidance/narrative. The name Thor was chosen as an acronym standing for: Tiled Hierarchical Open Routing and was the foundational idea around which the organization Valhalla and its Norse mythology theme was formed.</p> <p>The thor library is essentially a set of various data structures and algorithms which deal with things like: A* graph traversal, edge costing, vertex costing and path construction. It also includes methods for computing time-distance matrices, optimized routing, and isochrones.</p>"},{"location":"thor/#components","title":"Components","text":"<p>What follows are some notable components of thor.</p>"},{"location":"thor/#pathalgorithm","title":"PathAlgorithm","text":"<p>Valhalla uses a couple different algorithms to generate the route path. Thor contains a base class, called PathAlgorithm, defining the route path comptution interface. The following classes are derived from PathAlgorithm:   - AStar - This is a forward direction A* algorithm which is currently used only for \u201ctrivial paths\u201d where the origin and destination are on the same edge or adjacent, connected edges.   - TimeDepForward - This is a forward direction A* algorithm meant to be used for time dependent routes where a departure time from the origin is specified.    - TimeDepReverse - This is a revers direction A* algorithm meant to be used for time dependent routes where an arrival time at the destination is specified.   - BidirectionalAStar - This is a bidirectional A* algorithm used for routes that are not time-dependent and are not trivial.   - MultiModal - This is a forward direction A* algorithm with transit schedule lookup included as well as logic to switch modes between pedestrian and transit. This algorithm is time-dependent due to the nature of transit schedules.</p>"},{"location":"thor/#triplegbuilder","title":"TripLegBuilder","text":"<p>The PathAlgorithm methods all form a simple definition of the route path containing the directed edges comprising the path as well as the elapsed time at each edge along the path. This list is sent to a class called TripLegBuilder to form a more detailed representation of the trip path. TripLegBuilder forms details along the path that are required for guidance or narrative generation. Forming this TripPath requires reading attribution such as names, geometry, and other information required so that the subsequent guidance generation processing does not have to access the Valhalla tiles.</p>"},{"location":"thor/#matrix-isochrone-optimized-routes","title":"Matrix, Isochrone, Optimized Routes","text":"<p>Thor also includes methods to compute time-distance matrices, isochrones, and optimized routes (Traveling Salesman Problem).</p>"},{"location":"tiles/","title":"Tile Specifications","text":""},{"location":"tiles/#introduction","title":"Introduction","text":"<p>A tile represents a small rectangular section of a geographic area. The entire map or geographic region is divided into a grid of square tiles.</p> <p>Tiles are files in a specific format. They contain information necessary for routing: road network data, access restrictions, administrative information and so on.</p>"},{"location":"tiles/#hierarchieslevels","title":"Hierarchies/Levels","text":"<p>Tiles are arranged into a hierarchy with three levels.</p> Hierarchy level Tile size, degrees Content 0 4\u00b0 Highway roads: motorway, trunk and primary. 1 1\u00b0 Arterial roads: secondary and tertiary. 2 0.25\u00b0 Local roads: unclassified, residential, service or other. <p>At each level, the world is split into square tiles with a specific size using the bounding box <code>(-180, -90, 180, 90)</code>. The rows and columns start from the bottom left and increase to the top right - tiles are row ordered increasing from west to east.</p>"},{"location":"tiles/#the-world-at-level-0","title":"The World at Level 0","text":"<p>The following image shows the world at level 0.</p> <p> Image generated using https://geojson.io</p> <p>Using bounding boxes for Germany, Pennsylvania, and NYC we can show how the regions would be split up into the 3 levels. Level 0 is colored in light blue. Level 1 is light green and level 2 is light red.</p>"},{"location":"tiles/#germany","title":"Germany","text":"<p> Image generated using https://geojson.io</p>"},{"location":"tiles/#pennsylvania","title":"Pennsylvania","text":"<p> Image generated using https://geojson.io</p>"},{"location":"tiles/#nyc","title":"NYC","text":"<p> Image generated using https://geojson.io</p>"},{"location":"tiles/#sample-tile-code","title":"Sample Tile Code","text":"<p>Below are some sample functions to help you obtain latitude and longitude coordinates, levels, tile ids, and lists of tiles that intersect a bounding box.</p>"},{"location":"tiles/#working-with-graphid","title":"Working with <code>GraphId</code>","text":"<p>See <code>GraphId</code> page for relevant functions.</p>"},{"location":"tiles/#working-with-latitude-and-longitude-coordinates","title":"Working with Latitude and Longitude Coordinates","text":"<pre><code>from graphid import get_hierarchy_level, get_tile_index\n\nlevel_to_size = {\n    0: 4.0,\n    1: 1.0,\n    2: 0.25,\n}\n\n\ndef get_latlon(graph_id: int) -&gt; tuple[float, float]:\n    \"\"\"Latitude and longitude of tile's bottom-left corner.\"\"\"\n\n    hierarchy_level = get_hierarchy_level(graph_id)\n    size: float = level_to_size[hierarchy_level]\n    total_columns = int(360 / size)\n    tile_index = get_tile_index(graph_id)\n    lat = (tile_index // total_columns) * size - 90\n    lon = (tile_index % total_columns) * size - 180\n\n    return lat, lon\n\n\ndef get_tile_index_from_latlon(\n    hierarchy_level: int,\n    lat: float,\n    lon: float,\n) -&gt; int:\n    assert -90 &lt;= lat &lt;= 90\n    assert -180 &lt;= lon &lt;= 180\n\n    size: float = level_to_size[hierarchy_level]\n    total_columns = int(360 / size)\n    num_columns = int((lon + 180) / size)\n    num_rows = int((lat + 90) / size)\n\n    return num_rows * total_columns + num_columns\n\n\ndef tiles_for_bounding_box(\n    left: float,\n    bottom: float,\n    right: float,\n    top: float,\n) -&gt; list[tuple[int, int]]:\n    \"\"\"Return a list of tiles that intersect the bounding box.\"\"\"\n\n    assert -90 &lt;= bottom &lt;= 90\n    assert -90 &lt;= top &lt;= 90\n    assert bottom &lt;= top\n    assert -180 &lt;= left &lt;= 180\n    assert -180 &lt;= right &lt;= 180\n\n    # if this is crossing the anti meridian split it up and combine\n    if left &gt; right:\n        east = tiles_for_bounding_box(left, bottom, 180.0, top)\n        west = tiles_for_bounding_box(-180.0, bottom, right, top)\n        return east + west\n\n    # move these so we can compute percentages\n    left += 180\n    right += 180\n    bottom += 90\n    top += 90\n\n    tiles = []\n    # for each size of tile\n    for level, size in level_to_size.items():\n        # for each column\n        for x in range(int(left / size), int(right / size) + 1):\n            # for each row\n            for y in range(int(bottom / size), int(top / size) + 1):\n                # give back the level and the tile index\n                tile_index = int(y * (360.0 / size) + x)\n                tiles.append((level, tile_index))\n\n    return tiles\n</code></pre> <pre><code>&gt;&gt;&gt; get_latlon(73160266)\n(41.25, -73.75)\n&gt;&gt;&gt; get_latlon(142438865769)\n(14.0, 121.0)\n</code></pre> <pre><code>&gt;&gt;&gt; get_tile_index_from_latlon(0, 14.601879, 120.972545)\n2415\n&gt;&gt;&gt; get_tile_index_from_latlon(1, 14.601879, 120.972545)\n37740\n&gt;&gt;&gt; get_tile_index_from_latlon(2, 41.413203, -73.623787)\n756425\n</code></pre> <pre><code>&gt;&gt;&gt; from pprint import pp\n&gt;&gt;&gt; # NYC bounding box\n&gt;&gt;&gt; bottom, left = (40.512764, -74.251961)\n&gt;&gt;&gt; top, right = (40.903125, -73.755405)\n&gt;&gt;&gt; x = tiles_for_bounding_box(left, bottom, right, top)\n&gt;&gt;&gt; pp(sorted(x))\n[(0, 2906),\n (1, 46905),\n (1, 46906),\n (2, 752102),\n (2, 752103),\n (2, 752104),\n (2, 753542),\n (2, 753543),\n (2, 753544)]\n</code></pre>"},{"location":"tyr/","title":"Tyr","text":"<p>Tyr is a service layer taking locations and options as input and returning a route and maneuvers as output essentially linking together all other projects under the valhalla organization. In keeping with the Norse mythological theme, the name Tyr was chosen as backcronym standing for: Take Your Route. Since this software deals mostly with providing routes based on http requests, this seemed like a fitting name! Tyr is essentially a set of various data structures and algorithms which deal with things like: data marshalling, http, request parsing, response serializing, and  interprocess communication.</p>"},{"location":"tyr/#components","title":"Components","text":"<p>What follows are some notable components of tyr.</p>"},{"location":"tzdb_update/","title":"Tzdb update","text":""},{"location":"tzdb_update/#updating-the-timezone-database","title":"Updating the timezone database","text":"<p>The timezone information is coming from 2 repositories: - eggert/tz: Contains the IANA rules and prepares releases for each IANA release. We have this repo submodule'd and configure the files via CMake. - evansiroky/timezone-boundary-builder: Contains the geometries of IANA timezones, mostly sourced from OSM. Releases comprise the <code>timezones-with-oceans.shapefile.zip</code> shapefile which we use to build our timezone SQLite database.</p> <p>Updating the timezone information regularly is paramount to keep up with: - renamed/merged timezones, which implicitly deprecates (but still preserves) old timezones - geometry changes of timezones - entirely new timezones which are carved out due to local/regional DST changes - DST changes of existing timezones</p> <p>DST changes are the most important reason to update regularly.</p>"},{"location":"tzdb_update/#update-process","title":"Update process","text":"<ol> <li>Update the <code>tz</code> submodule     <pre><code>git -C third_party/tz checkout &lt;release_tag&gt;\n</code></pre></li> <li>Update <code>scripts/valhalla_build_timezones</code> to download the latest release</li> <li>Run <code>datetime</code> test. If any timezones were merged/renamed, it'll fail with a pretty-print of new/old elements for copy/pasting convenience. However, if entirely new timezones were added, there's more manual work:</li> <li>identify which timezone the new one is carved out of (look into the submoduled <code>tz</code> repo's NEWS)</li> <li>if the parent timezone has an ID &lt; 387, it just needs a bit shift of the parent timezone</li> <li>if the parent timezone is itself a previously added new timezone, one might add another field to NodeInfo; follow the instructions in baldr/nodeinfo.h/cc</li> <li>Sanity check step 3! Both looking at the release notes of the IANA data and adding test cases.</li> </ol>"},{"location":"tzdb_update/#important-notes","title":"Important notes","text":"<ul> <li>The 2 repos we source our information from are not always in-sync. If there's a IANA release being skipped in the boundary builder project, it usually means that nothing changed wrt geometries. However, you'll need to verify that.</li> <li>Regarding data compatibility:<ul> <li>new code/old data: the algorithms can ask for nodes' timezone indices of potentially deprecated timezones (old tile data), and it'll receive the new timezone information, which is not a problem</li> <li>old code/new data: for entirely new timezones, the new data has an additional field in NodeInfo which tells new code that it's a new timezone, while old code continues to see the new timezone's parent.</li> </ul> </li> </ul>"},{"location":"valhalla-intro/","title":"Introduction for Users","text":""},{"location":"valhalla-intro/#valhalla-open-source-routing","title":"Valhalla open source routing","text":"<p>This is the early history of Valhalla.</p> <p>Routing is a wily beast and many valiant efforts have been made to slay it, with limited success. However, we have brought a mighty new Mj\u00f6lnir-like weapon to bear on this beast: Open Source!</p> <p>After much intense battle development we are proud to take the wraps off of Valhalla. Valhalla is open source routing software using open source data (primarily Open Street Map), with a very liberal license. This should allow for transparency in development, encourage contribution and community input, and foster use in other projects. The name is inspired by key features of the routing engine: the core route engine is called THOR (Tiled, Hierarchical Open Routing), generation of trip information for the path is called ODIN (Open Directions and Improved Narrative) and the service component is called TYR (Take Your Route). Valhalla seemed like a fitting organization name -- previous efforts may have died but we all get to fight on in the great hall that is Open Source.</p> <p>Valhalla developers know routing. We have worked together as a team for over a decade and have complementary skills that allow efficient software development. Our experience includes both commercial and OSM routing. We are well versed in scaling routing services to handle millions of requests per day. Performance and scalability is important, but our primary focus will be creating high quality routes, guidance, and directions.</p>"},{"location":"valhalla-intro/#features","title":"Features","text":"<p>Existing open-source routing engines derive from academic research, resulting in fast routing algorithms over large graphs/networks. There are many properties of road networks that must be considered to produce quality routes and guidance/narrative descriptions. Rather than wrap these decisions into a baked costing model, we choose to add most attribution to the graph data and allow dynamic, run-time costing. This should allow others to contribute and apply costing models and also allow flexible use of alternate costing to produce routes with different characteristics.</p> <p>There are other key features that we hope distinguish Valhalla from other systems and encourage developers to build systems around the service and contribute back to the project. These features include:</p>"},{"location":"valhalla-intro/#multimodal-and-time-based-routing","title":"Multimodal and time-based routing","text":"<p>While the initial development phase of Valhalla will focus on single mode trips, we want to quickly move to support mixing auto, pedestrian, bike and public transportation in the same route.</p> <p>Support for public transit requires time and schedule dependent routing and must support tracking time along a path and can potentially support setting a time by which one must arrive at a location.</p> <p>From day one the design of Valhalla has been influenced by multi-modal considerations.</p>"},{"location":"valhalla-intro/#tiled-hierarchical-data","title":"Tiled, hierarchical data","text":"<p>Lets face it, building routing data sets from OSM is not easy. We wondered why routing data couldn\u2019t be treated like vector map data - use a tiled data structure to allow easy downloading and updating of regions.</p> <p>Graph (the route data structure) tiles can be downloaded for use by client-side routing applications or by hosted services that don\u2019t want to go through the pain of data creation. A structured graph hierarchy (e.g., highways, arterials, local, transit) along with shortcut edges will ensure high performance. THOR should allow for smaller memory footprints on memory constrained devices and provide a means for regional extracts and partial updates.</p>"},{"location":"valhalla-intro/#take-your-route-tyr","title":"Take your route (TYR)","text":"<p>Tyr signifies another fitting theme both from Norse mythology and from our open approach. Initially, Tyr will be our routing service where users can generate routes for mobile or web use. We plan to build methods to download tiled route data to allow unconnected, client-side features like off-line routing where users can \"take your route\" on the road or download graph tiles for a region and be able to use their device in places they might not have connectivity. Features like client-side \"return to route\" and off-line routing are possible.</p>"},{"location":"valhalla-intro/#flexibility-and-extensibility","title":"Flexibility and extensibility","text":"<p>We want to encourage others to contribute their expertise and local knowledge to routing and guidance/narrative.</p> <p>What makes a good route in one country/region may not hold true in another country. Having the ability to create dynamic and extensible \"plug-in\" code to perform costing/weighting may encourage others to use and extend Valhalla. Dynamic costing will also help create alternate route paths (at run time - without generating different data sets) and allow new costing methods for specialized use cases: truck routing, green/eco routing, and perhaps least cost routing.</p> <p>Within narrative and guidance generation software we want to provide means of adding custom narrative phrases and perhaps other means of extending or adding custom plug-ins to tailor the output to a user\u2019s need.</p>"},{"location":"valhalla-intro/#open-directions-and-improved-narrative-odin","title":"Open directions and improved narrative (ODIN)","text":"<p>A quality route result is more than just a path shape and long list of road names with simple turns and dreaded \"continue\" instructions. ODIN will be responsible for transforming path information into guidance and narrative directions that are easy to understand, useful, and assist users during their trip. Exit information and directional information on highways will help remove ambiguity at key decision points along the route. For example:</p> <ul> <li>Take exit 51B on the right onto I 81 North toward I 78/Hazleton/Allentown</li> </ul> <p>ODIN collapses maneuvers using common base street names and simplifies transitions at complex intersections. Landmarks and other related information are also planned. Guidance and route explication must also be able to be tailored to different languages and potential uses - so extensibility and contributions from others are key.</p>"},{"location":"api/","title":"API Overview","text":"<p>Valhalla is an open-source toolkit for multimodal transportation, powered by open data. The APIs use the standard REST model of interaction with JSON serving as both the request and response formats. Please refer to a specific service's API documentation to learn about the various request/response properties. In addition to JSON request/response formats Valhalla also supports protocol buffers as request/response format. For more information regarding protocol buffer support see here.</p> <p>The route service guides you between points by car, bike, foot, and multimodal combinations involving walking and riding public transit. Your apps can use the results from the route service to plan multimodal journeys with narratives to guide users by text and by voice. Valhalla draws data from OpenStreetMap for the main graph and from user-supplied GTFS feeds for <code>multimodal</code> routing. See the api documentation.</p> <p>Trying to run more than one errand in the day or start your own delivery service? The optimized route service computes the times and distances between many origins and destinations and provides you with an optimized path between the locations. See the api documentation.</p> <p>If you want only a table of the times and distances, start with the matrix service. See the api documentation.</p> <p>Use the isochrone service to get a computation of areas that are reachable within specified time periods from a location or set of locations. See the api documentation.</p> <p>The map-matching service matches coordinates to known roads so you can turn a path into a route with narrative instructions and get the attribute values from that matched line. See the api documentation.</p> <p>Use the elevation service to find the elevation along a path or at specified locations. See the api documentation.</p> <p>You can use the expansion service to return a geojson representation of a graph traversal at a given location. See the api documentation.</p> <p>The locate service allows you to get detailed metadata about the nodes and edges in the graph. See the api documentation.</p> <p>The status service is a simple service that returns information about the running server or valhalla instance. See the api documentation.</p> <p>The centroid service allows you to find the least cost convergence point of routes from multiple locations. Documentation coming soonish.</p>"},{"location":"api/protocol-buffers/","title":"Support for Protocol Buffers as Request/Response Formats (BETA)","text":"<p>Valhalla allows users to interact with its service (and bindings/library) directly using pbf objects/bytes in addition to the conventional JSON request/response formats. This feature is currently in beta meaning that we are still actively developing it and there are likely still some bugs to work out before it's ready for widespread use. Most importantly, we reserve the right to make organizational changes to the protobuf schema while the label beta is still in effect. </p> <p>Valhalla keeps track of the state of a \"request\" as it is being processed through our various APIs using protobuf messages. In fact, when you call into our top level APIs like <code>route</code> <code>locate</code> <code>isochrones</code> etc, we parse your json directly into a protobuf object. We then pass that object around to different parts of the library adding to it as we fulfill the request. We extended this functionality such that, instead of passing json to the service/bindings/library you can pass protobuf bytes or objects and get back protobuf bytes or objects.</p>"},{"location":"api/protocol-buffers/#motivations","title":"Motivations","text":"<p>There are a couple good reasons for this. As formats go, protobuf has many benefits over json:</p> <ul> <li>speed of serialization and deserialization</li> <li>over the wire size</li> <li>backward/forward compatibility</li> <li>working with an object on both sides of the network which eventually leads to</li> <li>gRPC</li> </ul> <p>The major drawback is that protobuf is a binary format so if you have just the bytes they aren't much good to you.</p>"},{"location":"api/protocol-buffers/#request","title":"Request","text":"<p>To use protobuf as a request/input to the HTTP API you need to do two things:</p> <ul> <li>Send the proper HTTP header to signal a protobuf payload. The header should be: <code>Content-Type: application/x-protobuf</code></li> <li>Send protocol buffer's serialized bytes as the body of the HTTP request</li> </ul> <p>The message we use for the entire transaction is the <code>Api</code> message, whose definition you can find here. All of the request parameters should be filled out via the <code>Options</code> message attached to the <code>Api</code> message. Most importantly, you will want to set your <code>format</code> to <code>pbf</code> and your <code>action</code> to the relevant API you are calling (though the HTTP request path also provides the latter). The <code>options</code> object also contains a subobject named <code>pbf_field_selector</code> which can be used to turn on/off the top level fields in the response. For example, if you only want the <code>directions</code> part of the protobuf response to be present (much smaller payload) then turn on only that flag in the field selector. The rest of the request options depend on which API you are calling. For more information about what and which options to set for a given API please read that APIs specific docs regarding its request options.</p>"},{"location":"api/protocol-buffers/#response","title":"Response","text":"<p>As with the request/input, the response/output will again be the <code>Api</code> message but will have more parts of it filled out. Depending on which API you are calling different parts of the response object will be filled out. Route-like responses will have <code>Trip</code> and <code>Directions</code> objects filled out whereas non-route APIs will have different parts of the message filled out. Not all APIs support protobuf output. Those that don't, will return JSON as they do today. Currently, the following APIs support protobuf as output: <code>route</code>, <code>matrix</code>, <code>isochrone</code>, <code>expansion</code>, <code>trace_route</code>, <code>trace_attributes</code>, <code>optimized_route</code>, <code>centroid</code>, <code>status</code></p>"},{"location":"api/protocol-buffers/#nodejs-bindings","title":"Node.js Bindings","text":"<p>The Node.js bindings (<code>@valhallajs/valhallajs</code>) support protobuf format for all compatible APIs. When you specify <code>format: 'pbf'</code> in your request, the bindings will return a Node.js <code>Buffer</code> containing the serialized protobuf data instead of a parsed JSON object.</p> <p>For more information, see the Node.js bindings README.</p>"},{"location":"api/protocol-buffers/#future-work","title":"Future Work","text":"<p>There are a few more things we should do before we can remove the beta label from this feature:</p> <ul> <li>Add Native PBF Support to Python Bindings: We can support, in addition to JSON strings, the ability for python to work directly with protobuf objects (those generated with protoc) across the python/c++ barrier. This would be a very natural way for python users to interact with Valhalla.</li> <li>Support for All APIs: As mentioned above we only support a certain subset Valhalla's APIs, over time we can add the rest of the APIs to the <code>Api</code> message.</li> </ul>"},{"location":"api/elevation/api-reference/","title":"Elevation service API reference","text":"<p>Valhalla's elevation lookup service provides digital elevation model (DEM) data as the result of a query. The elevation service data has many applications when combined with other routing and navigation data, including computing the steepness of roads and paths or generating an elevation profile chart along a route.</p> <p>For example, you can get elevation data for a point, a trail, or a trip. You might use the results to consider hills for your bicycle trip, or when estimating battery usage for trips in electric vehicles.</p> <p>View an interactive demo here.</p>"},{"location":"api/elevation/api-reference/#inputs-of-the-elevation-service","title":"Inputs of the elevation service","text":"<p>The elevation service currently has a single action, <code>/height?</code>, that can be requested. The <code>height</code> provides the elevation at a set of input locations, which are specified as either a <code>shape</code> or an <code>encoded_polyline</code>. The shape option uses an ordered list of one or more locations within a JSON array, while an encoded polyline stores multiple locations within a single string. If you include a <code>range</code> parameter and set it to <code>true</code>, both the height and cumulative distance are returned for each point.</p> <p>The elevation service also supports sampling the input shape or encoded polyline in uniform intervals along the path defined by the successive locations. If you include a <code>resample_distance</code> parameter with a distance in meters the elevation service will resample the input polyline at the requested resample_distance and return heights (and cumulative distance if requested) at the resampled locations. The resampled polyline is also returned.</p> <p>An elevation service request takes the form of <code>servername/height?json={}</code>, where the JSON inputs inside the <code>{}</code> includes location information and the optional range parameter.</p> <p>There is an option to name your elevation request. You can do this by appending the following to your request <code>&amp;id=</code>.  The <code>id</code> is returned with the response so a user could match to the corresponding request.</p>"},{"location":"api/elevation/api-reference/#height-precision","title":"Height Precision","text":"<p>By default, all height values are returned as integer values. This works fine for most cases. However, using integer precision when charting elevation results along a nearly flat road can lead to \"stair step\" changes in elevation. Height data can be returned with 1 or 2 digits decimal precision by specifying <code>height_precision</code>.</p> Height precision Description <code>height_precision</code> Specifies the precision (number of decimal places) of all returned height values. Values of <code>0</code>, <code>1</code>, or <code>2</code> are admissible. Defaults to 0 (integer precision). Any other value will result in integer precision (0 decimal places)."},{"location":"api/elevation/api-reference/#use-a-shape-list-for-input-locations","title":"Use a shape list for input locations","text":"<p>The elevation request run locally takes the form of <code>localhost:8002/height?json={}</code>, where the JSON inputs inside the <code>{}</code> are described below.</p> <p>A <code>shape</code> request must include a latitude and longitude in decimal degrees, and the locations are visited in the order specified. The input coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on.</p> <p>These parameters are available for <code>shape</code>.</p> Shape parameters Description <code>lat</code> Latitude of the location in degrees. <code>lon</code> Longitude of the location in degrees. <p>Here is an example JSON payload for a profile request using <code>shape</code>:</p> <pre><code>{\"range\":true,\"shape\":[{\"lat\":40.712431,\"lon\":-76.504916},{\"lat\":40.712275,\"lon\":-76.605259},{\"lat\":40.712122,\"lon\":-76.805694},{\"lat\":40.722431,\"lon\":-76.884916},{\"lat\":40.812275,\"lon\":-76.905259},{\"lat\":40.912122,\"lon\":-76.965694}]}&amp;id=Pottsville\n</code></pre> <p>This request provides <code>shape</code> points near Pottsville, Pennsylvania. The resulting profile response displays the input shape, as well as the <code>range</code> and <code>height</code> (as <code>range_height</code> in the response) for each point.</p> <pre><code>{\"shape\":[{\"lat\":40.712433,\"lon\":-76.504913},{\"lat\":40.712276,\"lon\":-76.605263},{\"lat\":40.712124,\"lon\":-76.805695},{\"lat\":40.722431,\"lon\":-76.884918},{\"lat\":40.812275,\"lon\":-76.905258},{\"lat\":40.912121,\"lon\":-76.965691}],\"range_height\":[[0,307],[8467,272],[25380,204],[32162,204],[42309,180],[54533,198]]}\n</code></pre> <p>Without the <code>range</code>, the result looks something like this, with only a <code>height</code>:</p> <pre><code>{\"shape\":[{\"lat\":40.712433,\"lon\":-76.504913},{\"lat\":40.712276,\"lon\":-76.605263},{\"lat\":40.712124,\"lon\":-76.805695},{\"lat\":40.722431,\"lon\":-76.884918},{\"lat\":40.812275,\"lon\":-76.905258},{\"lat\":40.912121,\"lon\":-76.965691}],\"height\":[307,272,204,204,180,198]}\n</code></pre>"},{"location":"api/elevation/api-reference/#use-an-encoded-polyline-for-input-locations","title":"Use an encoded polyline for input locations","text":"<p>The <code>encoded_polyline</code> parameter is a string of a polyline-encoded, with the specified precision, shape and has the following parameters. Details on polyline encoding and decoding can be found here.</p> Encoded polyline parameters Description <code>shape_format</code> <code>polyline6</code> or <code>polyline5</code>. Specifies whether the polyline is encoded with 6 digit precision (polyline6) or 5 digit precision (polyline5). If <code>shape_format</code> is not specified, the encoded polyline is expected to be 6 digit precision. <code>encoded_polyline</code> A set of encoded latitude, longitude pairs of a line or shape. <p>Here is an example of the JSON payload for an <code>encoded_polyline</code> POST request:</p> <pre><code>{\"range\":true,\"encoded_polyline\":\"s{cplAfiz{pCa]xBxBx`AhC|gApBrz@{[hBsZhB_c@rFodDbRaG\\\\ypAfDec@l@mrBnHg|@?}TzAia@dFw^xKqWhNe^hWegBfvAcGpG{dAdy@_`CpoBqGfC_SnI{KrFgx@?ofA_Tus@c[qfAgw@s_Agc@}^}JcF{@_Dz@eFfEsArEs@pHm@pg@wDpkEx\\\\vjT}Djj@eUppAeKzj@eZpuE_IxaIcF~|@cBngJiMjj@_I`HwXlJuO^kKj@gJkAeaBy`AgNoHwDkAeELwD|@uDfC_i@bq@mOjUaCvDqBrEcAbGWbG|@jVd@rPkAbGsAfDqBvCaIrFsP~RoNjWajBlnD{OtZoNfXyBtE{B~HyAtEsFhL_DvDsGrF_I`HwDpGoH|T_IzLaMzKuOrFqfAbPwCl@_h@fN}OnI\"}\n</code></pre>"},{"location":"api/elevation/api-reference/#get-height-and-distance-with-the-range-parameter","title":"Get height and distance with the range parameter","text":"<p>The <code>range</code> parameter is a boolean value that controls whether or not the returned array is one-dimensional (height only) or two-dimensional (with a range and height). This can be used to generate a graph along a route, because a 2D-array has values for x (the range) and y (the height) at each shape point. Steepness or gradient can also be computed from a profile request (e.g. when range = <code>true</code>).</p> <p>The <code>range</code> is optional and assumed to be <code>false</code> if omitted.</p> Range parameters Description <code>range</code> <code>true</code> or <code>false</code>. Defaults to <code>false</code>."},{"location":"api/elevation/api-reference/#resampling","title":"Resampling","text":"<p>The <code>resample_distance</code> parameter is a numeric value specifying the distance at which the input polyline is sampled in order to provide uniform distances between samples along the polyline.</p> Sampling parameter Description <code>resample_distance</code> Numeric value indicating the sampling distance in meters."},{"location":"api/elevation/api-reference/#other-request-options","title":"Other request options","text":"Options Description <code>id</code> Name your elevation request. If <code>id</code> is specified, the naming will be sent thru to the response."},{"location":"api/elevation/api-reference/#outputs-of-the-elevation-service","title":"Outputs of the elevation service","text":"<p>The profile results are returned with the form of shape (<code>shape</code> points or <code>encoded_ polyline</code>) that was supplied in the request, along with an array representing the x and y of each input point in the elevation profile.</p> Item Description <code>id</code> Name your route request. If <code>id</code> is specified, the naming will be sent thru to the response. <code>shape</code> The specified shape coordinates from the input request. <code>encoded_polyline</code> The specified encoded polyline, with six degrees of precision, coordinates from the input request. <code>range_height</code> (Present if <code>range</code>=<code>true</code>)The 2D array of range (x) and height (y) per input latitude, longitude coordinate:<ul><li>x coordinate (first index):The range or distance along the input locations. It is the cumulative distance along the previous latitiude, longitude coordinates up to the current coordinate. The x-value for the first coordinate in the shape will always be 0.</li><li>y coordinate (second index):The height or elevation of the associated latitude, longitude pair. Returned as <code>null</code> if no height data exists for a given location.</li></ul> <code>height</code> (Present if <code>range</code>=<code>false</code> or not present)An array of height for the associated latitude, longitude coordinates. Returned as <code>null</code> if no height data exists for a given location. <code>warnings</code> (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc."},{"location":"api/elevation/api-reference/#data-sources","title":"Data sources","text":"<p>Elevation data is obtained from the Amazon Web Services Public Datasets.</p>"},{"location":"api/expansion/api-reference/","title":"Expansion service API reference (BETA)","text":"<p>Routing algorithms find the best path by expanding their search from start nodes/edges across the routing network until the destination is reached (unidirectional) or both search branches meet (bidirectional). This service could be subject to change in terms of API until we remove the BETA label.</p> <p>The expansion service wraps the <code>route</code>, <code>isochrone</code> and <code>sources_to_targets</code> services and returns a GeoJSON with all network edges (way segments) the underlying routing algorithm visited during the expansion, with relevant properties for each edge (e.g. <code>duration</code> &amp; <code>distance</code>). A top-level <code>algorithm</code> propertry informs about the used algorithm: unidirectional &amp; bidirectional A* (for <code>route</code>), unidirectional Dijkstra (for <code>isochrone</code>) or bidirectional Dijkstra (for <code>sources_to_targets</code>).</p> <p>Note, for even moderately long routes (or isochrones or few sources/targets) the <code>/expansion</code> action can produce gigantic GeoJSON responses of 100s of MB.</p> <p></p>"},{"location":"api/expansion/api-reference/#inputs-of-the-expansion-service","title":"Inputs of the Expansion service","text":"<p>Since this service wraps other services, the request format mostly follows the ones of the route, isochrone and matrix. Additionally, it accepts the following parameters:</p> Parameter Description <code>action</code> (required) The service whose expansion should be tracked. Currently one of <code>route</code>, <code>isochrone</code> or <code>sources_to_targets</code>. <code>skip_opposites</code> (optional) If set to <code>true</code> the output won't contain an edge's opposing edge. Opposing edges can be thought of as both directions of one road segment. Of the two, we discard the directional edge with higher cost and keep the one with less cost. Default false. <code>dedupe</code> (optional) If set to <code>true</code>, the output will contain each edge only once, significantly reducing the response size. The expansion will keep track of already visited edges and override their properties, ensuring that only the one with higher edge state is returned. Default <code>false</code>. <code>expansion_properties</code> (optional) A JSON array of strings of the GeoJSON property keys you'd like to have in the response. One or multiple of \"duration\", \"distance\", \"cost\", \"edge_id\", \"pred_edge_id\", \"edge_status\" or \"expansion_type\". Note, that each additional property will increase the output size by minimum ~ 10%. By default an empty <code>properties</code> object is returned. <p>The <code>expansion_properties</code> choices are as follows:</p> Property Description <code>distance</code> Returns the accumulated distance in meters for each edge in order of graph traversal. <code>duration</code> Returns the accumulated duration in seconds for each edge in order of graph traversal. <code>cost</code> Returns the accumulated cost for each edge in order of graph traversal. <code>edge_id</code> Returns the internal edge IDs for each edge in order of graph traversal. Mostly interesting for debugging. <code>pred_edge_id</code> Returns the internal edge IDs of the predecessor for each edge in order of graph traversal. Mostly interesting for debugging. <code>edge_status</code> Returns the edge states for each edge in order of graph traversal. Mostly interesting for debugging. Can be one of \"r\" (reached), \"s\" (settled), \"c\" (connected). <code>expansion_type</code> Returns the expansion direction from which the edge was encountered. 0 for forward, 1 for reverse. <code>flow_sources</code> Returns which speed sources were used on the edge. Only populated when an edge is first reached. Adds the following boolean properties in JSON: <code>[\"flow_sources_current\", \"flow_sources_predicted\", \"flow_sources_free_flow\", \"flow_sources_constrained\"]</code>. <code>travel_modes</code> Returns the travel mode with which the edge was traversed. One of <code>{\"drive\", \"pedestrian\", \"bicycle\", \"transit\"}</code>. <p>An example request is:</p> <pre><code>{\n    \"costing\": \"pedestrian\",\n    \"action\": \"isochrone\",\n    \"id\": 1,\n    \"locations\": [\n        {\n            \"lon\": 14.440689,\n            \"lat\": 50.087052\n        }\n    ],\n    \"contours\": [\n        {\n            \"time\": 1\n        }\n    ],\n    \"skip_opposites\": true,\n    \"expansion_properties\": [\n        \"duration\",\n        \"edge_id\",\n        \"pred_edge_id\",\n        \"edge_status\",\n        \"cost\",\n        \"expansion_type\"\n    ]\n}\n</code></pre>"},{"location":"api/expansion/api-reference/#outputs-of-the-expansion-service","title":"Outputs of the Expansion service","text":"<p>In the service response, the expanded way segments are returned as GeoJSON as plain <code>LineString</code>s. Due to the verbosity of the GeoJSON format, single geometry features would produce prohibitively huge responses.</p> <p>The output will only contain the <code>properties</code> which were specified in the <code>expansion_properties</code> request array. If the parameter was omitted in the request, the output will contain an empty <code>properties</code> object.</p> <p>An example response for <code>\"action\": \"isochrone\"</code> is:</p> <pre><code>{\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [\n                        14.441804,\n                        50.087371\n                    ],\n                    [\n                        14.440275,\n                        50.087137\n                    ]\n                ]\n            },\n            \"properties\": {\n                \"duration\": 19,\n                \"cost\": 19,\n                \"edge_status\": \"s\",\n                \"edge_id\": 4049718357265,\n                \"pred_edge_id\": 70368744177663\n            }\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [\n                        14.440275,\n                        50.087137\n                    ],\n                    [\n                        14.439981,\n                        50.087084\n                    ]\n                ]\n            },\n            \"properties\": {\n                \"duration\": 34,\n                \"cost\": 34,\n                \"edge_status\": \"s\",\n                \"edge_id\": 4049617693969,\n                \"pred_edge_id\": 4049718357265\n            }\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [\n                        14.439981,\n                        50.087084\n                    ],\n                    [\n                        14.438998,\n                        50.086788\n                    ]\n                ]\n            },\n            \"properties\": {\n                \"duration\": 89,\n                \"cost\": 89,\n                \"edge_status\": \"s\",\n                \"edge_id\": 4444184259857,\n                \"pred_edge_id\": 4049617693969\n            }\n        }\n    ],\n    \"properties\": {\n        \"algorithm\": \"dijkstras\"\n    }\n}\n</code></pre>"},{"location":"api/expansion/api-reference/#credits","title":"Credits","text":"<p>The image includes data from OpenStreetMap and the \"Positron\" basemap by Carto.</p>"},{"location":"api/isochrone/api-reference/","title":"Isochrone &amp; Isodistance service API reference","text":"<p>An isochrone is a line that connects points of equal travel time about a given location, from the Greek roots of <code>iso</code> for equal and <code>chrone</code> for time. Valhalla's isochrone service computes areas that are reachable within specified time intervals from a location, and returns the reachable regions as contours of polygons or lines that you can display on a map.</p> <p>Isodistances follow the same concept, but instead of time one specifies distance intervals.</p> <p>Isochrone maps share some of the same concepts and terminology with familiar topographic maps, which depict contour lines for points of equal elevation. For this reason other terms common in topography apply, such as contours or isolines.</p> <p>This is an example of 15, 30, 45 and 60 minute bicycle isochrones centered in Lancaster, PA.</p> <p></p>"},{"location":"api/isochrone/api-reference/#inputs-of-the-isochrone-service","title":"Inputs of the Isochrone service","text":"<p>An isochrone request run locally takes the form of <code>localhost:8002/isochrone?json={}</code>, where the JSON inputs inside the <code>{}</code> includes an array of at least one location and options for the route costing model.</p> <p>For example, you can use the isochrone service to find out where you can travel within a 15-minute walk from your office building. The API request for this uses <code>isochrone?</code> as the request action, <code>pedestrian</code> costing, and a single contour for a 15-minute time interval. The response is GeoJSON, which you can display on a map to visualize where you might be able to walk.</p> <pre><code>{\"locations\":[{\"lat\":40.744014,\"lon\":-73.990508}],\"costing\":\"pedestrian\",\"contours\":[{\"time\":15.0,\"color\":\"ff0000\"}]}&amp;id=Walk_From_Office\n</code></pre> <p>There is an option to name your isochrone request by appending <code>&amp;id=</code>. The <code>id</code> is returned with the response so you can match it to your corresponding request.</p>"},{"location":"api/isochrone/api-reference/#location-parameters","title":"Location parameters","text":"<p>The <code>locations</code> must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. External search services, such as Mapbox Geocoding can be used to find places and geocode addresses, whose coordinates can be used as input to the service.</p> Location parameters Description <code>lat</code> Latitude of the location in degrees. <code>lon</code> Longitude of the location in degrees. <p>Refer to the route location documentation for more information on specifying locations.</p>"},{"location":"api/isochrone/api-reference/#costing-parameters","title":"Costing parameters","text":"<p>The isochrone service uses the <code>auto</code>, <code>bicycle</code>, <code>pedestrian</code>, and <code>multimodal</code> and all other costing models available in the Valhalla Turn-by-Turn service. Refer to the route costing models and costing options documentation for more on how to specify this input.</p>"},{"location":"api/isochrone/api-reference/#other-request-parameters","title":"Other request parameters","text":"Parameter Description <code>date_time</code> The local date and time at the location. <ul><li><code>type</code><ul><li>0 - Current departure time.</li><li>1 - Specified departure time.</li><li>2 - Specified arrival time. Note: This is not yet implemented for <code>multimodal</code>.</li></ul></li><li><code>value</code> - the date and time specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. For example, \"2016-07-03T08:06\"</li></ul> <code>id</code> Name of the isochrone request. If <code>id</code> is specified, the name is returned with the response. <code>contours</code> A JSON array of contour objects with the time in minutes or distance in kilometers and color to use for each isochrone contour. You can specify up to four contours (by default).<ul><li><code>time</code> - A floating point value specifying the time in minutes for the contour.</li><li><code>distance</code> - A floating point value specifying the distance in kilometers for the contour.</li><li><code>color</code> - The color for the output of the contour. Specify it as a Hex value, but without the <code>#</code>, such as <code>\"color\":\"ff0000\"</code> for red. If no color is specified, the isochrone service will assign a default color to the output.</li></ul>You can only specify one metric per contour, i.e. <code>time</code> or <code>distance</code>. <code>polygons</code> A Boolean value to determine whether to return geojson polygons or linestrings as the contours. The default is <code>false</code>, which returns lines; when <code>true</code>, polygons are returned. Note: When <code>polygons</code> is <code>true</code>, a feature's geometry type can be either <code>Polygon</code> or <code>MultiPolygon</code>, depending on the number of exterior rings formed for a given interval. <code>denoise</code> A floating point value from <code>0</code> to <code>1</code> (default of <code>1</code>) which can be used to remove smaller contours. A value of <code>1</code> will only return the largest contour for a given time value. A value of <code>0.5</code> drops any contours that are less than half the area of the largest contour in the set of contours for that same time value. <code>generalize</code> A floating point value in meters used as the tolerance for Douglas-Peucker generalization. Note: Generalization of contours can lead to self-intersections, as well as intersections of adjacent contours. <code>show_locations</code> A boolean indicating whether the input locations should be returned as MultiPoint features: one feature for the exact input coordinates and one feature for the coordinates of the network node it snapped to. Default false. <code>reverse</code> A boolean which can be set to do inverse expansion of the isochrone. The reverse isochrone will show from which area the given location can be reached within the given time."},{"location":"api/isochrone/api-reference/#outputs-of-the-isochrone-service","title":"Outputs of the Isochrone service","text":"<p>In the service response, the isochrone contours are returned as GeoJSON, which can be integrated into mapping applications. Alternatively, the grid data that underlies these contours can be returned as a GeoTIFF.</p> <p>The isochrone service returns contours as GeoJSON line or polygon features for the requested intervals (depending on the value of the <code>polygons</code> request parameter). These contours are calculated using a two dimensional grid. If the <code>format</code> request parameter is set to <code>geotiff</code>, the underlying grid data is returned directly instead of the contours derived from it. It will return one band for each requested metric (i.e. one for <code>time</code> and one for <code>distance</code>). If an isochrone request has been named using the optional <code>&amp;id=</code> input, then the <code>id</code> is returned as a name property for the feature collection within the GeoJSON response. A <code>metric</code> attribute lets you know whether it's a <code>distance</code> or <code>time</code> contour. A warnings array may also be included. This array may contain warning objects informing about deprecated request parameters, clamped values etc. |</p> <p>See the HTTP return codes for more on messages you might receive from the service.</p>"},{"location":"api/isochrone/api-reference/#draw-isochrones-on-a-map","title":"Draw isochrones on a map","text":"<p>Most JavaScript-based GeoJSON renderers, including Leaflet, can use the isochrone styling information directly from the response. At present, you cannot control the opacity through the API.</p> <p>When making a map, drawing the isochrone contours as lines is more straightforward than polygons, and, therefore, currently is the default and recommended method. When deciding between the output as lines and polygons, consider your use case and the additional styling considerations involved with polygons. For example, fills should be rendered as semi-transparent over the other map layers so they are visible, although you may have more flexibility when using a vector-based map. In addition, polygons from multiple contour levels do not have overlapping areas cut out or removed. In other words, the outer contours include the areas of any inner contours, causing the colors and transparencies to blend when multiple contour polygons are drawn at the same time.</p> <p>(TODO: write something about rendering the GeoTIFF output.)</p>"},{"location":"api/isochrone/api-reference/#data-credits","title":"Data credits","text":"<p>The image includes data from OpenStreetMap.</p>"},{"location":"api/locate/api-reference/","title":"Valhalla locate service API reference","text":"<p>Valhalla's locate service is an open-source service that provides detailed information about streets and intersections close to an input point with some added matching criteria. This allows for tight integration in routing and navigation applications on web or mobile.</p> <p>View an interactive demo</p> <p>The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page.</p>"},{"location":"api/locate/api-reference/#inputs-of-a-locate-request","title":"Inputs of a locate request","text":"<p>The locate request run locally takes the form of <code>localhost:8002/locate?json={}</code>, where the JSON inputs inside the <code>{}</code> include location information, name and options for the costing model, and output options. Here is the JSON payload for an example request:</p> <pre><code>{\"verbose\":true,\"locations\":[{\"lat\":42.358528,\"lon\":-83.271400},{\"lat\":42.996613,\"lon\":-78.749855}],\"costing\":\"bicycle\",\"costing_options\":{\"bicycle\":{\"bicycle_type\":\"road\"}},\"directions_options\":{\"units\":\"miles\"},\"id\":\"12abc3afe23984fe\"}\n</code></pre> <p>This request provides detailed information about specific streets and intersections near the two input locations. Steets which do not have a surface type condusive to road bicycles will be excluded from the results. The units used for the lengths of the street sections will be displayed in miles.</p> <p>There is an option to name your request. You can do this by adding and <code>id</code> key to your request. The <code>id</code> is returned with the response so a user could match to the corresponding request.</p> <p>Because the locate service is designed to work in tandem with the route service API, the inputs for the two APIs are identical. For detailed options regarding specifying locations, costing models, costing options, directions options please see the relevant sections in the routing API docs</p>"},{"location":"api/locate/api-reference/#other-request-options","title":"Other request options","text":"Options Description <code>verbose</code> Can be set to <code>true</code> or <code>false</code>, but defaults to <code>false</code>. If set to <code>true</code> dense attribution of the given street or intersection will be returned. <code>id</code> Name your route request. If <code>id</code> is specified, the naming will be sent through to the response."},{"location":"api/locate/api-reference/#outputs-of-a-locate-request","title":"Outputs of a locate request","text":"<p>If a request has been named using the optional <code>id</code> key, then this <code>id</code> key and value will be echoed in the JSON response object.</p> <p>The locate results are returned as a JSON array, with one JSON object per input location in the order specified. In <code>verbose</code> mode details about the streets and intersections including mode of travel access, names, way ids, shape, side of street as well as the closest point to the input along these features will be returned. If <code>verbose</code> was not enabled only the closest point, way id and side of street will be returned. A warnings array may also be included. This array may contain warning objects informing about deprecated request parameters, clamped values etc. |</p> <p>Here are some sample results with <code>verbose</code> set to <code>false</code>:</p> <pre><code>[\n  {\n    \"input_lon\": -76.495743,\n    \"input_lat\": 40.310555,\n    \"nodes\": [\n      {\n        \"lat\": 40.313206,\n        \"lon\": -76.494987\n      }\n    ],\n    \"edges\": [\n      {\n        \"way_id\": 12292268,\n        \"correlated_lat\": 40.313206,\n        \"side_of_street\": \"neither\",\n        \"percent_along\": 0,\n        \"correlated_lon\": -76.494987\n      },\n      {\n        \"way_id\": 12292268,\n        \"correlated_lat\": 40.313206,\n        \"side_of_street\": \"neither\",\n        \"percent_along\": 1,\n        \"correlated_lon\": -76.494987\n      }\n    ],\n    \"warnings\": [\n      \"hov costing is deprecated and will be turned into auto costing with hov2=true costing option\"\n    ]\n  }\n]\n</code></pre> <p>Here are some sample results with <code>verbose</code> set to <code>true</code>:</p> <pre><code>[\n  {\n    \"input_lon\": -76.495743,\n    \"input_lat\": 40.310555,\n    \"nodes\": [\n      {\n        \"traffic_signal\": false,\n        \"type\": \"street_intersection\",\n        \"lat\": 40.313206,\n        \"node_id\": {\n          \"id\": 3080,\n          \"value\": 103353655794,\n          \"tile_id\": 750654,\n          \"level\": 2\n        },\n        \"access\": {\n          \"wheelchair\": true,\n          \"taxi\": false,\n          \"HOV\": true,\n          \"truck\": true,\n          \"emergency\": true,\n          \"pedestrian\": true,\n          \"car\": true,\n          \"bus\": true,\n          \"bicycle\": true\n        },\n        \"lon\": -76.494987,\n        \"edge_count\": 1,\n        \"administrative\": {\n          \"time_zone_posix\": \"EST-05EDT+01,M3.2.0/02:00,M11.1.0/02:00\",\n          \"standard_time_zone_name\": \"EST\",\n          \"iso_3166-1\": \"US\",\n          \"daylight_savings_time_zone_name\": \"EDT\",\n          \"country\": \"United States of America\",\n          \"iso_3166-2\": \"PA\",\n          \"state\": \"Pennsylvania\"\n        },\n        \"intersection_type\": \"dead-end\",\n        \"density\": 2,\n        \"local_edge_count\": 1,\n        \"mode_change\": false\n      }\n    ],\n    \"edges\": [\n      {\n        \"edge_id\": {\n          \"id\": 7660,\n          \"value\": 257032954354,\n          \"tile_id\": 750654,\n          \"level\": 2\n        },\n        \"edge_info\": {\n          \"shape\": \"ivo{kAvg{{pCiMlJ{FfDgDm@c_AqxBeFO}}@`]\",\n          \"way_id\": 12292268,\n          \"names\": [\n            \"Bomgardner Lane\"\n          ]\n        },\n        \"edge\": {\n          \"classification\": {\n            \"link\": false,\n            \"internal\": false,\n            \"surface\": \"paved_smooth\",\n            \"classification\": \"residential\"\n          },\n          \"end_node\": {\n            \"id\": 3081,\n            \"value\": 103387210226,\n            \"tile_id\": 750654,\n            \"level\": 2\n          },\n          \"speed\": 30,\n          \"traffic_signal\": false,\n          \"start_restriction\": {\n            \"moped\": false,\n            \"wheelchair\": false,\n            \"taxi\": false,\n            \"HOV\": false,\n            \"truck\": false,\n            \"emergency\": false,\n            \"pedestrian\": false,\n            \"car\": false,\n            \"bus\": false,\n            \"bicycle\": false\n          },\n          \"speed_limit\": 0,\n          \"geo_attributes\": {\n            \"weighted_grade\": 1.67,\n            \"length\": 388\n          },\n          \"cycle_lane\": \"none\",\n          \"access_restriction\": false,\n          \"part_of_complex_restriction\": false,\n          \"country_crossing\": false,\n          \"has_exit_sign\": false,\n          \"lane_count\": 1,\n          \"speed_type\": \"classified\",\n          \"drive_on_right\": true,\n          \"destination_only\": false,\n          \"seasonal\": false,\n          \"tunnel\": false,\n          \"bridge\": false,\n          \"access\": {\n            \"moped\": true,\n            \"wheelchair\": true,\n            \"taxi\": false,\n            \"HOV\": true,\n            \"truck\": true,\n            \"emergency\": false,\n            \"pedestrian\": true,\n            \"car\": true,\n            \"bus\": true,\n            \"bicycle\": true\n          },\n          \"toll\": false,\n          \"round_about\": false,\n          \"bike_network\": {\n            \"mountain\": false,\n            \"local\": false,\n            \"regional\": false,\n            \"national\": false\n          },\n          \"end_restriction\": {\n            \"moped\": false,\n            \"wheelchair\": false,\n            \"taxi\": false,\n            \"HOV\": false,\n            \"truck\": false,\n            \"emergency\": false,\n            \"pedestrian\": false,\n            \"car\": false,\n            \"bus\": false,\n            \"bicycle\": false\n          },\n          \"unreachable\": false,\n          \"forward\": true,\n          \"not_thru\": false,\n          \"truck_route\": false,\n          \"use\": \"road\"\n        },\n        \"minimum_reachability\": 51,\n        \"score\": 899846.4,\n        \"traffic_segments\": [],\n        \"percent_along\": 0,\n        \"correlated_lon\": -76.494987,\n        \"side_of_street\": \"neither\",\n        \"correlated_lat\": 40.313206\n      },\n      {\n        \"edge_id\": {\n          \"id\": 7661,\n          \"value\": 257066508786,\n          \"tile_id\": 750654,\n          \"level\": 2\n        },\n        \"edge_info\": {\n          \"shape\": \"ivo{kAvg{{pCiMlJ{FfDgDm@c_AqxBeFO}}@`]\",\n          \"way_id\": 12292268,\n          \"names\": [\n            \"Bomgardner Lane\"\n          ]\n        },\n        \"edge\": {\n          \"classification\": {\n            \"link\": false,\n            \"internal\": false,\n            \"surface\": \"paved_smooth\",\n            \"classification\": \"residential\"\n          },\n          \"end_node\": {\n            \"id\": 3080,\n            \"value\": 103353655794,\n            \"tile_id\": 750654,\n            \"level\": 2\n          },\n          \"speed\": 30,\n          \"traffic_signal\": false,\n          \"start_restriction\": {\n            \"moped\": false,\n            \"wheelchair\": false,\n            \"taxi\": false,\n            \"HOV\": false,\n            \"truck\": false,\n            \"emergency\": false,\n            \"pedestrian\": false,\n            \"car\": false,\n            \"bus\": false,\n            \"bicycle\": false\n          },\n          \"speed_limit\": 0,\n          \"geo_attributes\": {\n            \"weighted_grade\": -1.67,\n            \"length\": 388\n          },\n          \"cycle_lane\": \"none\",\n          \"access_restriction\": false,\n          \"part_of_complex_restriction\": false,\n          \"country_crossing\": false,\n          \"has_exit_sign\": false,\n          \"lane_count\": 1,\n          \"speed_type\": \"classified\",\n          \"drive_on_right\": true,\n          \"destination_only\": false,\n          \"seasonal\": false,\n          \"tunnel\": false,\n          \"bridge\": false,\n          \"access\": {\n            \"moped\": true,\n            \"wheelchair\": true,\n            \"taxi\": false,\n            \"HOV\": true,\n            \"truck\": true,\n            \"emergency\": false,\n            \"pedestrian\": true,\n            \"car\": true,\n            \"bus\": true,\n            \"bicycle\": true\n          },\n          \"toll\": false,\n          \"round_about\": false,\n          \"bike_network\": {\n            \"mountain\": false,\n            \"local\": false,\n            \"regional\": false,\n            \"national\": false\n          },\n          \"end_restriction\": {\n            \"moped\": false,\n            \"wheelchair\": false,\n            \"taxi\": false,\n            \"HOV\": false,\n            \"truck\": false,\n            \"emergency\": false,\n            \"pedestrian\": false,\n            \"car\": false,\n            \"bus\": false,\n            \"bicycle\": false\n          },\n          \"unreachable\": false,\n          \"forward\": false,\n          \"not_thru\": true,\n          \"truck_route\": false,\n          \"use\": \"road\"\n        },\n        \"minimum_reachability\": 51,\n        \"score\": 899846.4,\n        \"traffic_segments\": [],\n        \"percent_along\": 1,\n        \"correlated_lon\": -76.494987,\n        \"side_of_street\": \"neither\",\n        \"correlated_lat\": 40.313206\n      }\n    ],\n    \"warnings\": [\n      \"hov costing is deprecated and will be turned into auto costing with hov2=true costing option\"\n    ]\n  }\n]\n</code></pre>"},{"location":"api/locate/api-reference/#attribute-descriptions-for-responses","title":"Attribute Descriptions for Responses","text":""},{"location":"api/locate/api-reference/#edge","title":"Edge","text":""},{"location":"api/locate/api-reference/#verbose","title":"Verbose","text":"Key Description <code>access_restrictions</code> A list of access restrictions that apply to the edge. Each entry contains information about its access mode mask, value, and more <code>edge_info</code> Contains information stored in the edge's <code>EdgeInfo</code> struct <code>edge_info.conditional_speed_limits</code> The key describes the time window during which the speed limit applies, the value is the limit <code>edge_info.speed_limit</code> The edge's speed limit <code>edge_info.levels</code> An array containing the edge's levels as derived from the <code>level=*</code> tag. Values are either numeric, or another array containing two elements, which denote the start and end of a range (inclusive) <code>shoulder</code> A boolean value indicating whether the edge has shoulder (<code>true</code> or <code>false</code>). If <code>true</code> then the data has been tagged to indicate a shoulder is present. <code>false</code>, however, could mean either that the data is tagged as having no shoulder present OR the data is untagged and we assume no shoulder (which may be an incorrect assumption)"},{"location":"api/locate/api-reference/#http-status-codes-and-error-messages","title":"HTTP status codes and error messages","text":"<p>Because the locate service API is so tightly integrated with the route service API the two share the same list of response codes and error messages. Please review the full lists in the routing service API documentation</p>"},{"location":"api/map-matching/api-reference/","title":"Map Matching service API reference","text":"<p>With Valhalla's Map Matching service, you can match coordinates, such as GPS locations, to roads and paths that have been mapped in OpenStreetMap. By doing this, you can turn a path into a route with narrative instructions and also get the attribute values from that matched line.</p> <p>You can view an interactive demo.</p> <p>There are two separate Map Matching calls that perform different operations on an input set of latitude,longitude coordinates. The <code>trace_route</code> action returns the shape snapped to the road network and narrative directions, while <code>trace_attributes</code> returns detailed attribution along the portion of the route.</p> <p>It is important to note that all service requests should be POST because <code>shape</code> or <code>encoded_polyline</code> can be fairly large.</p>"},{"location":"api/map-matching/api-reference/#trace-route-action","title":"Trace route action","text":"<p>The <code>trace_route</code> action takes the costing mode and a list of latitude,longitude coordinates, for example, from a GPS trace, to turn them into a route with the shape snapped to the road network and a set of guidance directions. You might use this to take a GPS trace from a bike route into a set of narrative instructions so you can re-create your trip or share it with others.</p> <p>By default a single trip leg is returned in a trace_route response. You can split the route response into multiple legs by setting <code>\"type\":\"break\"</code> on any of the input shape objects in the <code>shape</code> parameter of your query. The first and last locations should always have type break. Note that setting breaks is not supported for encoded_polyline input, and is only supported for <code>map_snap</code> mode of the trace_route endpoint.</p> <p>If the path contains one or more discontinuities (i.e. no path can be found between two locations), it is split into multiple paths. Any remaining paths from the first discontinuity onwards are stored as route alternates on the response.</p>"},{"location":"api/map-matching/api-reference/#trace-attributes-action","title":"Trace attributes action","text":"<p>The <code>trace_attributes</code> action takes the costing mode and a GPS trace or latitude,longitude positions and returns detailed attribution along the portion of the route. This includes details for each section of road along the path, as well as any intersections along the path. Some of the use cases for <code>trace_attributes</code> include getting:</p> <ul> <li>just-in-time information for navigation. Getting attributes only for portions of the upcoming route can improve performance because returning full details along an entire route can create a very large payload. For example, regular route responses include shape and a set of maneuvers along each route leg. The maneuvers are a generalization of the path to simplify the description. Detailed attributes and localization of attributes along a maneuver would require significant additions to the route response. For long and even moderate length routes this can be wasteful, as the chances of re-routing along a long route are high.</li> <li>speed limits. Speed limits along a path are a good example of just-in-time information that can be used for navigation. A single maneuver in a route (US-1, for example) may have many different speed limits along the full length of the maneuver. The <code>trace_attributes</code> action allows speed limits along each road segment to be determined and associated to portions of a maneuver.</li> <li>way IDs. You can turn a GPS trace into a set of way IDs that match the trace.</li> <li>the current road. A map-matching call with a recent set of GPS locations can be useful to find information about the current road, even if not doing navigation or having a route loaded on device.</li> </ul> <p>Note that the attributes that are returned are Valhalla routing attributes, not the base OSM tags or base data. Valhalla imports OSM tags and normalizes many of them to a standard set of values used for routing. The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page. To get the base OSM tags along a path, you need to take the OSM way IDs that are returned as attributes along the path and query OSM directly through a process such as the Overpass API.</p>"},{"location":"api/map-matching/api-reference/#inputs-of-the-map-matching-service","title":"Inputs of the Map Matching service","text":""},{"location":"api/map-matching/api-reference/#shape-matching-parameters","title":"Shape-matching parameters","text":"<p><code>shape_match</code> is an optional string input parameter. It allows some control of the matching algorithm based on the type of input.</p> shape_match type Description <code>edge_walk</code> Indicates an edge walking algorithm can be used. This algorithm requires nearly exact shape matching, so it should only be used when the shape is from a prior Valhalla route. <code>map_snap</code> Indicates that a map-matching algorithm should be used because the input shape might not closely match Valhalla edges. This algorithm is more expensive. <code>walk_or_snap</code> Also the default option. This will try edge walking and if this does not succeed, it will fall back and use map matching."},{"location":"api/map-matching/api-reference/#costing-models-and-other-options","title":"Costing models and other options","text":"<p>Valhalla Map Matching can use any costing model available in the Valhalla route service except for <code>multimodal</code> (it would be difficult to get a GPS trace and detect certain mode changes). Refer to the route costing models and costing options documentation for more on how to specify this input.</p> <p>You can also set <code>directions_options</code> to specify output units, language, and whether or not to return directions in a narrative form. Refer to the route options documentation for examples.</p> <p><code>trace_route</code> has additional options that allow more flexibility in specifying timestamps (when using encoded polyline input for the trace) and for using timestamps when computing elapsed time along the matched path. These options are:</p> Option Description <code>begin_time</code> Begin timestamp for the trace. This is used along with the <code>durations</code> so that timestamps can be specified for a trace that is specified using an encoded polyline. <code>durations</code> List of durations (seconds) between each successive pair of input trace points. This allows trace points to be supplied as an encoded polyline and timestamps to be created by using this list of \"delta\" times along with the <code>begin_time</code> of the trace. <code>use_timestamps</code> A boolean value indicating whether the input timestamps or durations should be used when computing elapsed time at each edge along the matched path. If true, timestamps are used. If false (default), internal costing is applied to compute elapsed times. <code>trace_options</code> Additional options. <code>trace_options.search_radius</code> Search radius in meters associated with supplied trace points. <code>trace_options.gps_accuracy</code> GPS accuracy in meters associated with supplied trace points. <code>trace_options.breakage_distance</code> Breaking distance in meters between trace points. <code>trace_options.interpolation_distance</code> Interpolation distance in meters beyond which trace points are merged together. <code>linear_references</code> When present and <code>true</code>, the successful <code>trace_route</code> response will include a key <code>linear_references</code>. Its value is an array of base64-encoded OpenLR location references, one for each graph edge of the road network matched by the input trace."},{"location":"api/map-matching/api-reference/#attribute-filters-trace_attributes-only","title":"Attribute filters (<code>trace_attributes</code> only)","text":"<p>The <code>trace_attributes</code> action allows you to apply filters to <code>include</code> or <code>exclude</code> specific attribute filter keys in your response. These filters are optional and can be added to the action string inside of the <code>filters</code> object.</p> <p>If no filters are used, all attributes are enabled and returned in the <code>trace_attributes</code> response.</p> <p>These are the available filter keys. Review their descriptions for more information.</p> <pre><code>// Edge filter Keys\nedge.names\nedge.length  # can also set source/target_percent_along\nedge.speed\nedge.speeds_faded\nedge.speeds_non_faded\nedge.road_class\nedge.begin_heading\nedge.end_heading\nedge.begin_shape_index\nedge.end_shape_index\nedge.traversability\nedge.use\nedge.toll\nedge.unpaved\nedge.tunnel\nedge.bridge\nedge.roundabout\nedge.internal_intersection\nedge.drive_on_right\nedge.surface\nedge.sign.exit_number\nedge.sign.exit_branch\nedge.sign.exit_toward\nedge.sign.exit_name\nedge.travel_mode\nedge.vehicle_type\nedge.pedestrian_type\nedge.bicycle_type\nedge.transit_type\nedge.id\nedge.indoor\nedge.way_id\nedge.weighted_grade\nedge.max_upward_grade\nedge.max_downward_grade\nedge.mean_elevation\nedge.lane_count\nedge.cycle_lane\nedge.bicycle_network\nedge.sac_scale\nedge.shoulder\nedge.sidewalk\nedge.density\nedge.speed_limit\nedge.truck_speed\nedge.truck_route\nedge.country_crossing\nedge.forward\nedge.traffic_signal\nedge.hov_type\nedge.begin_osm_node_id\nedge.end_osm_node_id\n\n// Node filter keys\nnode.intersecting_edge.begin_heading\nnode.intersecting_edge.from_edge_name_consistency\nnode.intersecting_edge.to_edge_name_consistency\nnode.intersecting_edge.driveability\nnode.intersecting_edge.cyclability\nnode.intersecting_edge.walkability\nnode.intersecting_edge.use\nnode.intersecting_edge.road_class\nnode.intersecting_edge.lane_count\nnode.elapsed_time\nnode.admin_index\nnode.type\nnode.traffic_signal\nnode.fork\nnode.time_zone\n\n// Other filter keys\nosm_changeset\nshape\nadmin.country_code\nadmin.country_text\nadmin.state_code\nadmin.state_text\nmatched.point\nmatched.type\nmatched.edge_index\nmatched.begin_route_discontinuity\nmatched.end_route_discontinuity\nmatched.distance_along_edge\nmatched.distance_from_trace_point\n\n// Shape attributes \nshape_attributes.time\nshape_attributes.length\nshape_attributes.speed\nshape_attributes.speed_limit\nshape_attributes.closure\nshape_attributes.congestion\n</code></pre>"},{"location":"api/map-matching/api-reference/#outputs-of-the-map-matching-service","title":"Outputs of the Map Matching service","text":""},{"location":"api/map-matching/api-reference/#outputs-of-trace_route","title":"Outputs of <code>trace_route</code>","text":"<p>The outputs of the <code>trace_route</code> action are the same as the outputs of a route action.</p>"},{"location":"api/map-matching/api-reference/#outputs-of-trace_attributes","title":"Outputs of <code>trace_attributes</code>","text":"<p>The <code>trace_attributes</code> results contains a list of edges and, optionally, the following items: <code>osm_changeset</code>, list of <code>admins</code>, <code>shape</code>, <code>matched_points</code>, and <code>units</code>.</p> Result item Description <code>edges</code> List of edges associated with input shape. See the list of edge items for details. <code>osm_changeset</code> Identifier of the OpenStreetMap base data version. <code>admins</code> List of the administrative codes and names. See the list of admin items for details. <code>elevation_interval</code> The requested <code>elevation_interval</code> if it is not zero. <code>elevation</code> Optional elevation data along the matched path, sampled at the specified <code>elevation_interval</code> in the requested units (meters or feet). Only present if the <code>elevation_interval</code> request option was set to a non-zero value. <code>shape</code> The encoded polyline of the matched path. <code>matched_points</code> List of match results when using the <code>map_snap</code> shape match algorithm. There is a one-to-one correspondence with the input set of latitude, longitude coordinates and this list of match results. See the list of matched point items for details. <code>shape_attributes</code> A list of shape attributes, each a list of attributes per shape segment. <code>closures</code> are an exception: they are serialized as objects containing a <code>begin_shape_index</code> and an <code>end_shape_index</code> <code>units</code> The specified units with the request, in either kilometers or miles. <code>warnings</code> A warnings array. This array may contain descriptive text about notices of deprecated request parameters, clamped values etc."},{"location":"api/map-matching/api-reference/#edge-items","title":"Edge items","text":"<p>Each <code>edge</code> may include:</p> Edge item Description <code>names</code> List of names. <code>source_percent_along</code> The start of an edge's match as percentage of its length in (0, 1) range. If an edge was fully matched, we omit this value. <code>target_percent_along</code> The end of an edge's match as percentage of its length in (0, 1) range. If an edge was fully matched, we omit this value. <code>length</code> The matched edge length in the units specified (default is kilometers). If <code>source_percent_along</code> and/or <code>target_percent_along</code> are present, this represents the partially matched edge length, otherwise the full edge length. <code>speed</code> Edge speed in the units specified. The default is kilometers per hour. <code>speed_type</code> Describes how the base speed was assigned to the edge. Either its inferred from the road class (<code>\"classified\"</code>) or it is set by a tag (<code>\"tagged\"</code>) <code>speeds_faded</code> Contains all flow speeds available for that edge in the units specified (default is kilometers per hour). All flows are: <ul><li><code>current_flow</code></li><li><code>constrained_flow</code></li><li><code>free_flow</code></li><li><code>predicted_flow</code></li><li><code>no_flow</code></li></ul>These speeds are faded with the current flow (if available). The <code>current_flow</code> fades with the flow_mask that was passed to the request. <code>speeds_non_faded</code> Contains all raw flow speeds available for that edge in the units specified (default is kilometers per hour). All flows are: <ul><li><code>current_flow</code></li><li><code>constrained_flow</code></li><li><code>free_flow</code></li><li><code>predicted_flow</code></li><li><code>no_flow</code></li></ul> <code>road_class</code> Road class values:<ul><li><code>motorway</code></li><li><code>trunk</code></li><li><code>primary</code></li><li><code>secondary</code></li><li><code>tertiary</code></li><li><code>unclassified</code></li><li><code>residential</code></li><li><code>service_other</code></li></ul> <code>begin_heading</code> The direction at the beginning of an edge. The units are degrees from north in a clockwise direction. <code>end_heading</code> The direction at the end of an edge. The units are degrees from north in a clockwise direction.. <code>begin_shape_index</code> Index into the list of shape points for the start of the edge. <code>end_shape_index</code> Index into the list of shape points for the end of the edge. <code>traversability</code> Traversability values, if available:<ul><li><code>forward</code></li><li><code>backward</code></li><li><code>both</code></li></ul> <code>use</code> Use values: <ul><li><code>tram</code></li><li><code>road</code></li><li><code>ramp</code></li><li><code>turn_channel</code></li><li><code>track</code></li><li><code>driveway</code></li><li><code>alley</code></li><li><code>parking_aisle</code></li><li><code>emergency_access</code></li><li><code>drive_through</code></li><li><code>culdesac</code></li><li><code>cycleway</code></li><li><code>mountain_bike</code></li><li><code>sidewalk</code></li><li><code>footway</code></li><li><code>steps</code></li><li><code>other</code></li><li><code>rail-ferry</code></li><li><code>ferry</code></li><li><code>rail</code></li><li><code>bus</code></li><li><code>egress_connection</code></li><li><code>platform_connection</code></li><li><code>transit_connection</code></li></ul> <code>toll</code> True if the edge has any toll. <code>unpaved</code> True if the edge is unpaved or rough pavement. <code>tunnel</code> True if the edge is a tunnel. <code>bridge</code> True if the edge is a bridge. <code>roundabout</code> True if the edge is a roundabout. <code>internal_intersection</code> True if the edge is an internal intersection. <code>drive_on_right</code> True if the flag is enabled for driving on the right side of the street. <code>surface</code> Surface values: <ul><li><code>paved_smooth</code></li><li><code>paved</code></li><li><code>paved_rough</code></li><li><code>compacted</code></li><li><code>dirt</code></li><li><code>gravel</code></li><li><code>path</code></li><li><code>impassable</code></li></ul> <code>sign</code> Contains the interchange guide information associated with this edge. See the list of sign items for details. <code>travel_mode</code> Travel mode values:<ul><li><code>drive</code></li><li><code>pedestrian</code></li><li><code>bicycle</code></li><li><code>transit</code></li></ul> <code>vehicle_type</code> Vehicle type values:<ul><li><code>car</code></li><li><code>motorcycle</code></li><li><code>bus</code></li><li><code>tractor_trailer</code></li></ul> <code>pedestrian_type</code> Pedestrian type values:<ul><li><code>foot</code></li><li><code>wheelchair</code></li><li><code>segway</code></li></ul> <code>bicycle_type</code> Bicycle type values:<ul><li><code>road</code></li><li><code>cross</code></li><li><code>hybrid</code></li><li><code>mountain</code></li></ul> <code>transit_type</code> Transit type values: <ul><li><code>tram</code></li><li><code>metro</code></li><li><code>rail</code></li><li><code>bus</code></li><li><code>ferry</code></li><li><code>cable_car</code></li><li><code>gondola</code></li><li><code>funicular</code></li></ul> <code>id</code> Identifier of an edge within the tiled, hierarchical graph. <code>indoor</code> Whether or not the edge is inside of a building or structure or not. <code>way_id</code> Way identifier of the OpenStreetMap base data. <code>weighted_grade</code> The weighted grade factor. Valhalla manufactures a <code>weighted_grade</code> from elevation data. It is a measure used for hill avoidance in routing - sort of a relative energy use along an edge. But since an edge in Valhalla can possibly go up and down over several hills it might not equate to what most folks think of as grade. <code>max_upward_grade</code> The maximum upward slope. A value of 32768 indicates no elevation data is available for this edge. <code>max_downward_grade</code> The maximum downward slope. A value of 32768 indicates no elevation data is available for this edge. <code>mean_elevation</code> The mean or average elevation along the edge. Units are meters by default. If the units are specified as miles, then the mean elevation is returned in feet. A value of 32768 indicates no elevation data is available for this edge. <code>lane_count</code> The number of lanes for this edge. <code>cycle_lane</code> The type (if any) of bicycle lane along this edge. <code>bicycle_network</code> The bike network for this edge. <code>sac_scale</code> Classification of hiking trails based on difficulty. Values:<ul><li><code>0 - No Sac Scale</code></li><li><code>1 - Hiking</code></li><li><code>2 - Mountain hiking</code><li><code>3 - Demanding mountain hiking</code><li><code>4 - Alpine hiking</code><li><code>5 - Demanding alpine hiking</code><li><code>6 - Difficult alpine hiking</code></li> <code>shoulder</code> True if the edge has a shoulder. <code>sidewalk</code> Sidewalk values:<ul><li><code>left</code></li><li><code>right</code></li><li><code>both</code></li></ul> <code>density</code> The relative density along the edge. <code>speed_limit</code> Edge speed limit in the units specified. The default is kilometers per hour. <code>truck_speed</code> Edge truck speed in the units specified. The default is kilometers per hour. <code>truck_route</code> True if edge is part of a truck network/route. <code>end_node</code> The node at the end of this edge. See the list of end node items for details. <code>landmarks</code> List of landmarks along the edge. They are used as direction support in navigation. <code>country_crossing</code> True if the edge is a country crossing. <code>forward</code> True if the edge is traversed forwards and False if it is traversed backwards with respect to the reference shape/geometry (ie. the direction in which it was digitized). <code>traffic_signal</code> True if the edge contains a traffic signal in its direction. <code>hov_type</code> The type (if any) of HOV lane along this edge. <code>node_id</code> OpenStreetMap node identifier at the beginning of the edge. Present only if available in the underlying graph data and edge.begin_osm_node_id is requested."},{"location":"api/map-matching/api-reference/#sign-items","title":"Sign items","text":"<p>Each <code>sign</code> may include:</p> Sign item Description <code>exit_number</code> List of exit number elements. If an exit number element exists, it is typically just one value. Element example: <code>91B</code> <code>exit_branch</code> List of exit branch elements. An exit branch element is the subsequent road name or route number after the sign. Element example: <code>I 95 North</code> <code>exit_toward</code> List of exit toward elements. The exit toward element is the location where the road ahead goes; the location is typically a control city, but may also be a future road name or route number. Element example: <code>New York</code> <code>exit_name</code> List of exit name elements. The exit name element is the interchange identifier, although typically not used in the United States. Element example: <code>Gettysburg Pike</code>"},{"location":"api/map-matching/api-reference/#end-node-items","title":"End node items","text":"<p>Each <code>end_node</code> may include:</p> Node item Description <code>intersecting_edges</code> List of intersecting edges at this node. See the list of intersecting edge items for details. <code>elapsed_time</code> Elapsed time of the path to arrive at this node. <code>admin_index</code> Index value in the admin list. <code>type</code> Node type values: <ul><li><code>street_intersection</code></li><li><code>gate</code></li><li><code>bollard</code></li><li><code>toll_booth</code></li><li><code>multi_use_transit_stop</code></li><li><code>bike_share</code></li><li><code>parking</code></li><li><code>motor_way_junction</code></li><li><code>border_control</code></li></ul> <code>traffic_signal</code> A boolean value indicating whether the node is a traffic signal (<code>true</code> or <code>false</code>) <code>fork</code> True if this node is a fork. <code>time_zone</code> Time zone string for this node. <code>node_id</code> OpenStreetMap node identifier at the end of the edge. Present only if available in the underlying graph data and edge.end_osm_node_id is requested."},{"location":"api/map-matching/api-reference/#intersecting-edge-items","title":"Intersecting edge items","text":"<p>Each <code>intersecting_edge</code> may include:</p> Intersecting edge item Description <code>begin_heading</code> The direction at the beginning of this intersecting edge. The units are degrees from north in a clockwise direction. <code>from_edge_name_consistency</code> True if this intersecting edge at the end node has consistent names with the path <code>from edge</code>. <code>to_edge_name_consistency</code> True if this intersecting edge at the end node has consistent names with the path <code>to edge</code>. <code>driveability</code> Driveability values, if available:<ul><li><code>forward</code></li><li><code>backward</code></li><li><code>both</code></li></ul> <code>cyclability</code> Cyclability values, if available:<ul><li><code>forward</code></li><li><code>backward</code></li><li><code>both</code></li></ul> <code>walkability</code> Walkability values, if available:<ul><li><code>forward</code></li><li><code>backward</code></li><li><code>both</code></li></ul> <code>use</code> Use values: <ul><li><code>tram</code></li><li><code>road</code></li><li><code>ramp</code></li><li><code>turn_channel</code></li><li><code>track</code></li><li><code>driveway</code></li><li><code>alley</code></li><li><code>parking_aisle</code></li><li><code>emergency_access</code></li><li><code>drive_through</code></li><li><code>culdesac</code></li><li><code>cycleway</code></li><li><code>mountain_bike</code></li><li><code>sidewalk</code></li><li><code>footway</code></li><li><code>steps</code></li><li><code>other</code></li><li><code>rail-ferry</code></li><li><code>ferry</code></li><li><code>rail</code></li><li><code>bus</code></li><li><code>egress_connection</code></li><li><code>platform_connection</code></li><li><code>transit_connection</code></li></ul> <code>road_class</code> Road class values:<ul><li><code>motorway</code></li><li><code>trunk</code></li><li><code>primary</code></li><li><code>secondary</code></li><li><code>tertiary</code></li><li><code>unclassified</code></li><li><code>residential</code></li><li><code>service_other</code></li></ul>"},{"location":"api/map-matching/api-reference/#admin-items","title":"Admin items","text":"<p>Each <code>admin</code> may include:</p> Admin item Description <code>country_code</code> Country ISO 3166-1 alpha-2 code. <code>country_text</code> Country name. <code>state_code</code> State code. <code>state_text</code> State name."},{"location":"api/map-matching/api-reference/#matched-point-items","title":"Matched point items","text":"<p>Each <code>matched_point</code> may include:</p> Matched point item Description <code>lat</code> The latitude of the matched point. <code>lon</code> The longitude of the matched point. <code>type</code> Describes the type of this match result - possible values include:<ul><li><code>unmatched</code></li><li><code>interpolated</code></li><li><code>matched</code></li></ul> <code>edge_index</code> The index of the edge in the list of edges that this matched point is associated with. This value will not exist if this point was unmatched. <code>begin_route_discontinuity</code> The boolean value is true if this match result is the begin location of a route disconnect. This value will not exist if this is false. <code>end_route_discontinuity</code> The boolean value is true if this match result is the end location of a route disconnect.  This value will not exist if this is false. <code>distance_along_edge</code> The distance along the associated edge for this matched point. For example, if the matched point is halfway along the edge then the value would be 0.5. This value will not exist if this point was unmatched. <code>distance_from_trace_point</code> The distance in meters from the trace point to the matched point. This value will not exist if this point was unmatched."},{"location":"api/map-matching/api-reference/#get-better-results","title":"Get better results","text":"<p>Follow these guidelines to improve the Map Matching results.</p> <ul> <li>You should have good GPS accuracy, meaning that there are few obstructions affecting GPS signals. This can be difficult in urban areas.</li> <li>Make sure the trace point density is within the approximate range of one per second and one per 10 seconds. The greater the range between them, the more chance of inaccurate results.</li> <li>Have each trace represent one continuous path.</li> <li>Verify that there is a corresponding match with the OpenStreetMap network.</li> </ul> <p>You can use certain parameters to tune the response. Unless otherwise noted, each of these options is specified within a root-level <code>trace_options</code> object.</p> <ul> <li>Use <code>turn_penalty_factor</code> to penalize turns from one road segment to next. For a pedestrian <code>trace_route</code>, you may see a back-and-forth motion along the streets of your path. Try increasing the turn penalty factor to 500 to smooth out jittering of points. Note that if GPS accuracy is already good, increasing this will have a negative affect on your results.</li> <li>Set the <code>gps_accuracy</code> to indicate the accuracy in meters.</li> <li>Apply a <code>search_radius</code> to specify the search radius (in meters) within which to search road candidates for each measurement. The maximum search radius is 100 meters. Note that performance may decrease with a higher search radius value.</li> <li>Add a <code>time</code> component to your GPS data to inform the map matching algorithm about when the point was measured. Providing a <code>time</code> attribute is not available for <code>encoded_polyline</code> data and can only be specified with GPS data provided by the <code>shape</code> attribute. <code>time</code> is specified in seconds and can be a UNIX epoch time or any increasing sequence: <pre><code>{\"shape\":[{\"lat\":39.983841,\"lon\":-76.735741,\"time\":0},{\"lat\":39.983704,\"lon\":-76.735298,\"time\":2},{\"lat\":39.983578,\"lon\":-76.734848,\"time\":6},...]}\n</code></pre></li> </ul>"},{"location":"api/map-matching/api-reference/#example-map-matching-requests","title":"Example Map Matching requests","text":""},{"location":"api/map-matching/api-reference/#example-trace_route-requests","title":"Example <code>trace_route</code> requests","text":"<p>The following are example JSON payloads for POST requests for the <code>trace_routes</code> action.</p> <p><code>trace_route</code> with shape parameter</p> <pre><code>{\"shape\":[{\"lat\":39.983841,\"lon\":-76.735741,\"type\":\"break\"},{\"lat\":39.983704,\"lon\":-76.735298,\"type\":\"via\"},{\"lat\":39.983578,\"lon\":-76.734848,\"type\":\"via\"},{\"lat\":39.983551,\"lon\":-76.734253,\"type\":\"break\"},{\"lat\":39.983555,\"lon\":-76.734116,\"type\":\"via\"},{\"lat\":39.983589,\"lon\":-76.733315,\"type\":\"via\"},{\"lat\":39.983719,\"lon\":-76.732445,\"type\":\"via\"},{\"lat\":39.983818,\"lon\":-76.731712,\"type\":\"via\"},{\"lat\":39.983776,\"lon\":-76.731506,\"type\":\"via\"},{\"lat\":39.983696,\"lon\":-76.731369,\"type\":\"break\"}],\"costing\":\"auto\",\"shape_match\":\"map_snap\"}}\n</code></pre> <p><code>trace_route</code> with encoded polyline parameter</p> <pre><code>{\"encoded_polyline\":\"_grbgAh~{nhF?lBAzBFvBHxBEtBKdB?fB@dBZdBb@hBh@jBb@x@\\\\|@x@pB\\\\x@v@hBl@nBPbCXtBn@|@z@ZbAEbAa@~@q@z@QhA]pAUpAVhAPlAWtASpAAdA[dASdAQhAIlARjANnAZhAf@n@`A?lB^nCRbA\\\\xB`@vBf@tBTbCFbARzBZvBThBRnBNrBP`CHbCF`CNdCb@vBX`ARlAJfADhA@dAFdAP`AR`Ah@hBd@bBl@rBV|B?vB]tBCvBBhAF`CFnBXtAVxAVpAVtAb@|AZ`Bd@~BJfA@fAHdADhADhABjAGzAInAAjAB|BNbCR|BTjBZtB`@lBh@lB\\\\|Bl@rBXtBN`Al@g@t@?nAA~AKvACvAAlAMdAU`Ac@hAShAI`AJ`AIdAi@bAu@|@k@p@]p@a@bAc@z@g@~@Ot@Bz@f@X`BFtBXdCLbAf@zBh@fBb@xAb@nATjAKjAW`BI|AEpAHjAPdAAfAGdAFjAv@p@XlAVnA?~A?jAInAPtAVxAXnAf@tBDpBJpBXhBJfBDpAZ|Ax@pAz@h@~@lA|@bAnAd@hAj@tAR~AKxAc@xAShA]hAIdAAjA]~A[v@BhB?dBSv@Ct@CvAI~@Oz@Pv@dAz@lAj@~A^`B^|AXvAVpAXdBh@~Ap@fCh@hB\\\\zBN`Aj@xBFdA@jALbAPbAJdAHdAJbAHbAHfAJhALbA\\\\lBTvBAdC@bC@jCKjASbC?`CM`CDpB\\\\xAj@tB\\\\fA\\\\bAVfAJdAJbAXz@L|BO`AOdCDdA@~B\\\\z@l@v@l@v@l@r@j@t@b@x@b@r@z@jBVfCJdAJdANbCPfCF|BRhBS~BS`AYbAe@~BQdA\",\"shape_match\":\"map_snap\",\"costing\":\"pedestrian\",\"directions_options\":{\"units\":\"miles\"}}\n</code></pre> <p><code>trace_route</code> with additional trace options</p> <pre><code>{\"encoded_polyline\":\"{gmagAp~_nhF[_AZqAjAaB`AkB\\\\cAZeAPcAHiAKiCQaAUeAe@cA]qAQsACqAF}AIsAg@{@s@i@sAw@i@uANyAPsAv@cAZ_ALqA_@cA_Ai@q@w@[uAm@}AaAqAs@s@m@u@c@oA]mAMiAIkAYqBRyATsANsBKyBAiA?iAFsALuAPsAXaBGgCg@oBKiBf@iBGiBg@oBHqA?{Ai@cA@oAbAgAj@g@j@k@n@q@p@e@n@k@d@}@\\\\cAFgAIoBg@m@y@[_ASu@K{AHgBP{@@w@Jy@L}@JsAMoAe@kAq@kAk@gAg@y@a@m@g@q@mAo@e@gAc@sAA_AI_BFu@LiALaALaAHoAFiAF{A@yABkAKmAKcAMiBU}AYu@MaBUqBu@{As@iAaAaA_Ao@aAi@s@q@{@{@a@sAi@oAGeAD}@[YiAmA[u@BgBXaBHgAQ}@]s@S]x@_BbC}@lAw@dAs@dAk@dAm@z@s@n@y@p@{@`Ao@z@_@z@u@jA_Af@aANiAAcBPsAl@s@X}@T{@PoAPeAl@{@t@_AbAgAjBk@r@e@~AY~@U~@YhAi@lAo@t@kBb@u@NyAX{@k@MoAi@{@eAx@aArAmBt@_ALgAPiAXkAf@w@j@u@p@_A^aA\\\\aA`@eAt@eATcAGcAG}@AeAX_Aj@q@r@aAp@wAt@sARk@xA?pBAvAu@Ps@_Bk@i@y@\\\\s@f@o@j@u@f@{@RwAb@mAZaARkATqANyAImAK}@C_AFqADiAC_AUs@[}Ao@eBm@q@_@_Bg@iAm@kAaAc@s@c@w@y@{AWcAc@{Am@c@yBF{@AkAYmA_@uBD{@B{@Gu@ScBIu@NaB^_B`@sAC{Ac@}A]yAg@aBHuAJ_BAaAEgAA_AAy@@eBX_AFw@JcB^s@VuA`AuAl@kBl@_AFeAJcAB{ABwAj@o@l@q@b@u@Z{AXmAaAm@o@oAwAsAcAsAu@u@cAe@iAy@eAk@iAc@gAOgAWgBe@wAo@}Ai@sBY{@u@s@y@Y{@[aA]s@oB\\\\eCPoARwAXgBV{Ab@sAf@oAb@kAFsA?kACeADeA^aABeAO_Be@gB]}@eAaB_AoAw@aAm@o@q@cBp@eBz@a@fAi@|@o@LiBAyAIoAu@qBkAuAiAa@gAa@cB_@eAQm@c@o@{ANaBf@{@h@_BV}@XcBz@?{@s@o@y@u@}@mAaBw@qCm@mG}@uJLoBVkBVaBh@iB`@gBXgBZ_BZaBNgACwASyAUqAGuBGsBTcBRiB^eCTmBTaBNoAVaB@kAMiBZcAd@eAf@q@z@mAVgB[gAq@aAk@s@UkAG{B_@sAW}ASoBMwBSuB]gBq@eBs@eBaAuAaAeAo@{@i@}@e@{@g@{@m@m@y@_@y@[aBk@a@cBFsB[iAaAGoA`@IcC^yA`@}AVkBNwBBmBR_Cr@{CrAyD|@mCf@kBXeB\\\\eBl@aCf@cBc@sBg@qAUkBe@sBw@eBi@uA{@gAyAc@qAk@[wB@gARqANgAPiAJsAAeAa@mBKmB@uBBwB@oBZoBJkCJkANaCY}Ac@aBa@iBc@iBu@qBu@sBu@sB_AiBcA}AiAqAaAqAeAaA}@]iANgAj@}@dAcAhAeAfAyAfAo@`@k@f@o@f@s@d@o@f@k@h@o@`@s@V_Br@wAv@{An@uAt@qAj@wAl@iAv@gA~@qAbA{A`AcBz@o@^{A`AmAhAo@b@sAxA_@z@]x@a@t@qAxAk@j@qAfAm@b@m@b@kAfAuA~@eAhAcAbAiAr@qA|@gAdAcA`A{@bA_AhAgA|@mAr@qA|@mAlA\",\"shape_match\":\"map_snap\",\"costing\":\"pedestrian\",\"trace_options\":{\"turn_penalty_factor\":500},\"directions_options\":{\"units\":\"miles\"}}\n</code></pre>"},{"location":"api/map-matching/api-reference/#example-trace_attributes-requests","title":"Example <code>trace_attributes</code> requests","text":"<p>The following are example JSON payloads for POST requests for the <code>trace_attributes</code> action.</p> <p><code>trace_attributes</code> with shape parameter</p> <pre><code>{\"shape\":[{\"lat\":39.983841,\"lon\":-76.735741},{\"lat\":39.983704,\"lon\":-76.735298},{\"lat\":39.983578,\"lon\":-76.734848},{\"lat\":39.983551,\"lon\":-76.734253},{\"lat\":39.983555,\"lon\":-76.734116},{\"lat\":39.983589,\"lon\":-76.733315},{\"lat\":39.983719,\"lon\":-76.732445},{\"lat\":39.983818,\"lon\":-76.731712},{\"lat\":39.983776,\"lon\":-76.731506},{\"lat\":39.983696,\"lon\":-76.731369}],\"costing\":\"auto\",\"shape_match\":\"walk_or_snap\",\"filters\":{\"attributes\":[\"edge.names\",\"edge.id\", \"edge.weighted_grade\",\"edge.speed\"],\"action\":\"include\"}}\n</code></pre> <p><code>trace_attributes</code> with encoded polyline parameter</p> <pre><code>{\"encoded_polyline\":\"_grbgAh~{nhF?lBAzBFvBHxBEtBKdB?fB@dBZdBb@hBh@jBb@x@\\\\|@x@pB\\\\x@v@hBl@nBPbCXtBn@|@z@ZbAEbAa@~@q@z@QhA]pAUpAVhAPlAWtASpAAdA[dASdAQhAIlARjANnAZhAf@n@`A?lB^nCRbA\\\\xB`@vBf@tBTbCFbARzBZvBThBRnBNrBP`CHbCF`CNdCb@vBX`ARlAJfADhA@dAFdAP`AR`Ah@hBd@bBl@rBV|B?vB]tBCvBBhAF`CFnBXtAVxAVpAVtAb@|AZ`Bd@~BJfA@fAHdADhADhABjAGzAInAAjAB|BNbCR|BTjBZtB`@lBh@lB\\\\|Bl@rBXtBN`Al@g@t@?nAA~AKvACvAAlAMdAU`Ac@hAShAI`AJ`AIdAi@bAu@|@k@p@]p@a@bAc@z@g@~@Ot@Bz@f@X`BFtBXdCLbAf@zBh@fBb@xAb@nATjAKjAW`BI|AEpAHjAPdAAfAGdAFjAv@p@XlAVnA?~A?jAInAPtAVxAXnAf@tBDpBJpBXhBJfBDpAZ|Ax@pAz@h@~@lA|@bAnAd@hAj@tAR~AKxAc@xAShA]hAIdAAjA]~A[v@BhB?dBSv@Ct@CvAI~@Oz@Pv@dAz@lAj@~A^`B^|AXvAVpAXdBh@~Ap@fCh@hB\\\\zBN`Aj@xBFdA@jALbAPbAJdAHdAJbAHbAHfAJhALbA\\\\lBTvBAdC@bC@jCKjASbC?`CM`CDpB\\\\xAj@tB\\\\fA\\\\bAVfAJdAJbAXz@L|BO`AOdCDdA@~B\\\\z@l@v@l@v@l@r@j@t@b@x@b@r@z@jBVfCJdAJdANbCPfCF|BRhBS~BS`AYbAe@~BQdA\",\"shape_match\":\"map_snap\",\"costing\":\"pedestrian\",\"directions_options\":{\"units\":\"miles\"}}\n</code></pre> <p><code>trace_attributes</code> with <code>include</code> attribute filter</p> <pre><code>{\"shape\":[{\"lat\":39.983841,\"lon\":-76.735741},{\"lat\":39.983704,\"lon\":-76.735298},{\"lat\":39.983578,\"lon\":-76.734848},{\"lat\":39.983551,\"lon\":-76.734253},{\"lat\":39.983555,\"lon\":-76.734116},{\"lat\":39.983589,\"lon\":-76.733315},{\"lat\":39.983719,\"lon\":-76.732445},{\"lat\":39.983818,\"lon\":-76.731712},{\"lat\":39.983776,\"lon\":-76.731506},{\"lat\":39.983696,\"lon\":-76.731369}],\"costing\":\"auto\",\"shape_match\":\"walk_or_snap\",\"filters\":{\"attributes\":[\"edge.names\",\"edge.id\", \"edge.weighted_grade\",\"edge.speed\"],\"action\":\"include\"}}\n</code></pre> <p><code>trace_attributes</code> with <code>exclude</code> attribute filter</p> <p><pre><code>{\"shape\":[{\"lat\":39.983841,\"lon\":-76.735741},{\"lat\":39.983704,\"lon\":-76.735298},{\"lat\":39.983578,\"lon\":-76.734848},{\"lat\":39.983551,\"lon\":-76.734253},{\"lat\":39.983555,\"lon\":-76.734116},{\"lat\":39.983589,\"lon\":-76.733315},{\"lat\":39.983719,\"lon\":-76.732445},{\"lat\":39.983818,\"lon\":-76.731712},{\"lat\":39.983776,\"lon\":-76.731506},{\"lat\":39.983696,\"lon\":-76.731369}],\"costing\":\"auto\",\"shape_match\":\"walk_or_snap\",\"filters\":{\"attributes\":[\"edge.names\",\"edge.begin_shape_index\",\"edge.end_shape_index\",\"shape\"],\"action\":\"exclude\"}}\n</code></pre> If you would like to visualize the map matched points that correlate to specified input locations - use the following filter <pre><code>\"filters\":{\"attributes\":[\"edge.id\",\"matched.point\",\"matched.type\",\"matched.edge_index\",\"matched.begin_route_discontinuity\",\"matched.end_route_discontinuity\",\"matched.distance_along_edge\"],\"action\":\"include\"}\n</code></pre></p>"},{"location":"api/matrix/api-reference/","title":"Time-Distance Matrix service API reference","text":"<p>Valhalla's time-distance matrix service provides a quick computation of time and distance between a set of locations and returns them to you in the resulting matrix table.</p>"},{"location":"api/matrix/api-reference/#matrix-service","title":"Matrix service","text":"<p>The time distance matrix service takes a <code>sources</code> and <code>targets</code> to list locations. This allows you to set the source (origin) locations separately from the target (destination) locations. The set of origins may be disjoint (not overlapping) with the set of destinations. In other words, the target locations do not have to include any locations from source locations. The time-distance matrix can return a row matrix, a column matrix, or a general matrix of computed time and distance, depending on your input for the sources and targets parameters. The general case is a row ordered matrix with the time and distance from each source location to each target location. A row vector is considered a one_to_many time-distance matrix where there is one source location and multiple target locations. The time and distance from the source location to all target locations is returned. A column matrix represents a many_to_one time-distance matrix where there are many sources and one target. Another special case is when the source location list is the same as the target location list. Here, a diagonal (square matrix with [0,0.00] on the diagonal elements) matrix is returned. The is special case is often used as the input to optimized routing problems.</p>"},{"location":"api/matrix/api-reference/#inputs-of-the-matrix-service","title":"Inputs of the matrix service","text":"<p>The matrix request run locally takes the form of <code>localhost:8002/sources_to_targets?json={}</code>, where the JSON inputs inside the <code>{}</code> includes at least one location for both sources and for targets as well as the route costing type and options for the route costing model.</p> <p>For example, while at your office, you want to know the times and distances to walk to several restaurants where you could have dinner, as well as the times and distances from each restaurant to the train station for your commute home. This will help you determine where to eat.</p> <p><code>one-to-many using /sources_to_targets?</code></p> <pre><code>{\"sources\":[{\"lat\":40.744014,\"lon\":-73.990508}],\"targets\":[{\"lat\":40.744014,\"lon\":-73.990508},{\"lat\":40.739735,\"lon\":-73.979713},{\"lat\":40.752522,\"lon\":-73.985015},{\"lat\":40.750117,\"lon\":-73.983704},{\"lat\":40.750552,\"lon\":-73.993519}],\"costing\":\"pedestrian\"}\n</code></pre> <p><code>many-to-one using /sources_to_targets?</code></p> <pre><code>{\"sources\":[{\"lat\":40.744014,\"lon\":-73.990508},{\"lat\":40.739735,\"lon\":-73.979713},{\"lat\":40.752522,\"lon\":-73.985015},{\"lat\":40.750117,\"lon\":-73.983704},{\"lat\":40.750552,\"lon\":-73.993519}],\"targets\":[{\"lat\":40.750552,\"lon\":-73.993519}],\"costing\":\"pedestrian\"}\n</code></pre> <p><code>many-to-many using /sources_to_targets?</code></p> <pre><code>{\"sources\":[{\"lat\":40.744014,\"lon\":-73.990508},{\"lat\":40.739735,\"lon\":-73.979713},{\"lat\":40.752522,\"lon\":-73.985015},{\"lat\":40.750117,\"lon\":-73.983704},{\"lat\":40.750552,\"lon\":-73.993519}],\"targets\":[{\"lat\":40.744014,\"lon\":-73.990508},{\"lat\":40.739735,\"lon\":-73.979713},{\"lat\":40.752522,\"lon\":-73.985015},{\"lat\":40.750117,\"lon\":-73.983704},{\"lat\":40.750552,\"lon\":-73.993519}],\"costing\":\"pedestrian\"}\n</code></pre>"},{"location":"api/matrix/api-reference/#source-and-target-parameters","title":"Source and target parameters","text":"<p>When using the <code>sources_to_targets</code> action, you specify sources and targets as ordered lists of one or more locations within a JSON array, depending on the type of matrix result you are expecting.</p> <p>A source and target must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on.</p> Source and target parameters Description <code>lat</code> Latitude of the source/target in degrees. <code>lon</code> Longitude of the source/target in degrees. <code>date_time</code> Expected date/time for the user to be at the location using the ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival. <code>date_time</code> as location input offers more granularity over setting time than the global <code>date_time</code> object (see below). <p>You can refer to the route location documentation for more information on specifying locations.</p> <p>Note: <code>date_time</code> strings behave differently for <code>sources_to_targets</code> than for <code>route</code>. If set on the <code>sources</code> and there's more <code>targets</code> than <code>sources</code>, it'll behave like a \"Specified departure time\" on the <code>sources</code>. If set on the <code>targets</code> and there's less <code>targets</code> than <code>sources</code>, it'll behave like a \"Specified arrival time\" on the <code>targets</code>.</p> <p>Also, using <code>type</code> in addition to the <code>lat</code> and <code>lon</code> within the location parameter has no meaning for matrices.</p>"},{"location":"api/matrix/api-reference/#costing-parameters","title":"Costing parameters","text":"<p>The Time-Distance Matrix service uses the <code>auto</code>, <code>bicycle</code>, <code>pedestrian</code> and <code>bikeshare</code> and other costing models available in the route service. Exception: multimodal costing is not supported for the time-distance matrix service at this time.  Refer to the route costing models and costing options documentation for more on how to specify this input.</p>"},{"location":"api/matrix/api-reference/#other-request-options","title":"Other request options","text":"Options Description <code>id</code> Name your matrix request. If <code>id</code> is specified, the naming will be sent thru to the response. <code>matrix_locations</code> For one-to-many or many-to-one requests this specifies the minimum number of locations that satisfy the request. However, when specified, this option allows a partial result to be returned. This is basically equivalent to \"find the closest/best <code>matrix_locations</code> locations out of the full location set\". <code>date_time</code> This is the local date and time at the location.<ul><li><code>type</code><ul><li>0 - Current departure time.</li><li>1 - Specified departure time</li><li>2 - Specified arrival time.</li></ul></li><li><code>value</code> - the date and time is specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival.  For example \"2016-07-03T08:06\"</li></ul> <code>verbose</code> If <code>true</code> it will output a flat list of objects for <code>distances</code> &amp; <code>durations</code> explicitly specifying the source &amp; target indices. If <code>false</code> will return more compact, nested row-major <code>distances</code> &amp; <code>durations</code> arrays and not echo <code>sources</code> and <code>targets</code>. Default <code>true</code>. <code>shape_format</code> Specifies the optional format for the path shape of each connection. One of <code>polyline6</code>, <code>polyline5</code>, <code>geojson</code> or <code>no_shape</code> (default)."},{"location":"api/matrix/api-reference/#time-dependent-matrices","title":"Time-dependent matrices","text":"<p>Most control can be achieved when setting a <code>date_time</code> string on each source or target. When setting the global <code>date_time</code> object as a shortcut instead, Valhalla will translate that to setting the <code>date_time.value</code> on all source locations when <code>date_time.type = 0/1</code> and on all target locations when <code>date_time.type = 2</code>.</p> <p>However, there are important limitations of the <code>/sources_to_targets</code> service's time awareness. Due to algorithmic complexity, we disallow time-dependence for certain combinations of <code>date_time</code> on locations, if - <code>date_time.type = 0/1</code> or <code>date_time</code> on any source, when there's more sources than targets - <code>date_time.type = 2</code> or <code>date_time</code> on any target, when there's more or equal amount of targets than/as sources</p>"},{"location":"api/matrix/api-reference/#outputs-of-the-matrix-service","title":"Outputs of the matrix service","text":"<p>Depending on the <code>verbose</code> (default: <code>true</code>) request parameter, the result of the Time-Distance Matrix service is different. In both (<code>\"verbose\": true</code> and <code>\"verbose\": false</code>) cases, these parameters are present:</p> Item Description <code>id</code> Name of the request. Included only if a matrix request has been named using the optional <code>id</code> input. <code>algorithm</code> The algorithm used to compute the results. Can be <code>\"timedistancematrix\"</code>, <code>\"costmatrix\"</code> or <code>\"timedistancebssmatrix\"</code> <code>units</code> Distance units for output. Allowable unit types are <code>\"miles\"</code> and <code>\"kilometers\"</code>. If no unit type is specified in the input, the units default to <code>\"kilometers\"</code>. <code>warnings</code> (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. <p>See the HTTP return codes for more on messages you might receive from the service.</p>"},{"location":"api/matrix/api-reference/#verbose-mode-verbose-true","title":"Verbose mode (<code>\"verbose\": true</code>)","text":"<p>The following parameters are only present in <code>\"verbose\": true</code> mode:</p> Item Description <code>sources</code> The sources passed to the request. <code>targets</code> The targets passed to the request. <code>sources_to_targets</code> An array of time and distance between the sources and the targets.The array is row-ordered, meaning the time and distance from the first location to all others forms the first row of the array, followed by the time and distance from the second source location to all target locations, etc.The Object contained in the arrays contains the following fields:<ul><li><code>distance</code>: The computed distance between each set of points. Distance will always be 0.00 for the first element of the time-distance array for <code>one_to_many</code>, the last element in a <code>many_to_one</code>, and the first and last elements of a <code>many_to_many</code>. For unfound connections, the value will be <code>null</code>.</li><li><code>time</code>: The computed time between each set of points. Time will always be 0 for the first element of the time-distance array for <code>one_to_many</code>, the last element in a <code>many_to_one</code>, and the first and last elements of a <code>many_to_many</code>. For unfound connections, the value will be <code>null</code>.</li><li><code>to_index</code>: The destination index into the locations array.</li><li><code>from_index</code>: The origin index into the locations array.</li><li><code>date_time</code>: When a user will arrive at/depart from this location. See the part above where we explain how time dependent matices work for further context. Note: If the time is above the setting <code>max_timedep_distance_matrix</code> this is skipped.Note: If the departure/arrival time is unspecified it is not computed.</li><li><code>time_zone_offset</code>, <code>time_zone_name</code>: time zone at the target location. See here on requesting time dependent matrices. Note: this is skipped if the time is greater than <code>max_timedep_distance_matrix</code> or no route was found for the location pair.</li><li><code>begin_heading</code> beta: the heading at the beginning of path in degrees</li><li><code>end_heading</code> beta: the heading at the end of the path in degrees</li><li><code>begin_lat</code> beta: the latitude of the correlated source location for this connection</li><li><code>begin_lon</code> beta: the longitude of the correlated source location for this connection</li><li><code>begin_lat</code> beta: the latitude of the correlated target location for this connection</li><li><code>begin_lon</code> beta: the longitude of the correlated target location for this connection</li></ul>"},{"location":"api/matrix/api-reference/#concise-mode-verbose-false","title":"Concise mode  (<code>\"verbose\": false</code>)","text":"Item Description <code>sources_to_targets</code> Returns an object with <code>durations</code> and <code>distances</code> as row-ordered contents of the values above."},{"location":"api/matrix/api-reference/#demonstration","title":"Demonstration","text":"<p>View an interactive demo.</p>"},{"location":"api/optimized/api-reference/","title":"Optimized Route service API reference","text":"<p>The Optimized Route service provides a quick computation of time and distance between a set of location sources and location targets and returns them in an optimized route order, along with the shape.</p> <p>View an interactive demo</p>"},{"location":"api/optimized/api-reference/#optimized-route-service-action","title":"Optimized route service action","text":"<p>You can request the following action from the Optimized Route service: <code>/optimized_route?</code>. Since an optimized route is really an extension of the many_to_many matrix (where the source locations are the same as the target locations), the first step is to compute a cost matrix by sending a matrix request.  Then, we send our resulting cost matrix (resulting time or distance) to the optimizer which will return our optimized path.</p> Optimized type Description <code>optimized_route</code> Returns an optimized route stopping at each destination location exactly one time, always starting at the first location in the list and ending at the last location. This will result in a route with multiple legs."},{"location":"api/optimized/api-reference/#inputs-of-the-optimized-route-service","title":"Inputs of the optimized route service","text":"<p>The optimized route request run locally takes the form of <code>localhost:8002/optimized_route?json={}</code>, where the JSON inputs inside the <code>{}</code> includes location information (at least four locations), as well as the name and options for the costing model</p> <p>Here is an example of an Optimized Route scenario:</p> <p>Given a list of cities and the distances and times between each pair, a salesperson wants to visit each city one time by taking the most optimized route and end at a destination (either return to origin or a different destination).</p> <pre><code>{\"locations\":[{\"lat\":40.042072,\"lon\":-76.306572},{\"lat\":39.992115,\"lon\":-76.781559},{\"lat\":39.984519,\"lon\":-76.6956},{\"lat\":39.996586,\"lon\":-76.769028},{\"lat\":39.984322,\"lon\":-76.706672}],\"costing\":\"auto\",\"units\":\"miles\"}\n</code></pre> <p>There is an option to name your optimized route request. You can do this by appending the following to your request <code>&amp;id=</code>.  The <code>id</code> is returned with the response so a user could match to the corresponding request.</p>"},{"location":"api/optimized/api-reference/#location-parameters","title":"Location parameters","text":"<p>A location must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. External search/geocoding services can be used to find places and geocode addresses, whose coordinates can be used as input to the service.</p> Location parameters Description <code>lat</code> Latitude of the location in degrees. <code>lon</code> Longitude of the location in degrees. <p>Refer to the route location documentation for more information on specifying locations.</p>"},{"location":"api/optimized/api-reference/#costing-parameters","title":"Costing parameters","text":"<p>The Optimized Route service uses the <code>auto</code>, <code>bicycle</code> and <code>pedestrian</code> costing models available in the Valhalla route service. The multimodal costing is not supported for the Optimized Route service at this time.  Refer to the route costing models and costing options documentation for more on how to specify this input.</p>"},{"location":"api/optimized/api-reference/#other-request-options","title":"Other request options","text":"Options Description <code>id</code> Name your optimized request. If <code>id</code> is specified, the naming will be sent thru to the response."},{"location":"api/optimized/api-reference/#outputs-of-the-optimized-route-service","title":"Outputs of the optimized route service","text":"<p>If an optimized request has been named using the optional <code>&amp;id=</code> input, then the name will be returned as a string <code>id</code>.</p> <p>These are the results of a request to the Optimized Route service.</p> Item Description <code>optimized_route</code> Returns an optimized route path from point 'a' to point 'n'.  Given a list of locations, an optimized route with stops at each intermediate location exactly one time, always starting at the first location in the list and ending at the last location. <code>locations</code> The specified array of lat/lngs from the input request.  The first and last locations in the array will remain the same as the input request.  The intermediate locations may be returned reordered in the response.  Due to the reordering of the intermediate locations, an <code>original_index</code> is also part of the <code>locations</code> object within the response.  This is an identifier of the location index that will allow a user to easily correlate input locations with output locations. <code>units</code> Distance units for output. Allowable unit types are mi (miles) and km (kilometers). If no unit type is specified, the units default to kilometers. <code>warnings</code> (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc."},{"location":"api/optimized/api-reference/#error-checking","title":"Error checking","text":"<p>The service checks the return to see that all locations can be reached. If one or more cannot be reached, it returns an error and lists the location number that cannot be reached.  Currently, one location is listed at this time, even if more than one have an issue.</p> <p>This is an example which should return: <code>400::Location at index 3 is unreachable</code></p> <pre><code>{\"locations\":[{\"lat\":40.306600,\"lon\":-76.900022},{\"lat\":40.293246,\"lon\":-76.936230},{\"lat\":40.448678,\"lon\":-76.932885},{\"lat\":40.419753,\"lon\":-76.999632},{\"lat\":40.211050,\"lon\":-76.777071},{\"lat\":40.306600,\"lon\":-76.900022}],\"costing\":\"auto\"}\n</code></pre> <p>See the HTTP return codes for more on messages you might receive from the service.</p>"},{"location":"api/status/api-reference/","title":"Status service API reference","text":"<p>By default the <code>/status</code> endpoint will return a HTTP status code of 200 with <code>version</code> and <code>tileset_last_modified</code> (as UNIX timestamp) info, which can also be used as a health endpoint for the HTTP API.</p> <p>However, if <code>\"verbose\": true</code> is passed as a request parameter it will return additional information about the loaded tileset. Note that gathering this additional information can be computationally expensive, hence the <code>verbose</code> flag can be disallowed in the configuration JSON (<code>service_limits.status.allow_verbose</code>, default <code>false</code>).</p>"},{"location":"api/status/api-reference/#outputs-of-the-status-service","title":"Outputs of the Status service","text":"<p>If <code>\"verbose\": true</code> is passed as a parameter, the service will output the following response:</p> Response key Type Description <code>version</code> string The current Valhalla version, e.g. <code>3.1.4</code>. <code>tileset_last_modified</code> integer The time the tile_extract or tile_dir were last modified as UNIX timestamp, e.g. 1634903519. <code>has_tiles</code> bool Whether a valid tileset is currently loaded. <code>has_admins</code> bool Whether the current tileset was built using the admin database. <code>has_timezones</code> bool Whether the current tileset was built using the timezone database. <code>has_live_traffic</code> bool Whether live traffic tiles are currently available. <code>bbox</code> object GeoJSON of the tileset extent. <code>warnings</code> (optional) array This array may contain warning objects informing about deprecated request parameters, clamped values etc."},{"location":"api/tile/api-reference/","title":"Valhalla tile service API reference [BETA]","text":"<p>Valhalla's <code>/tile</code> service provides a graph representation as Mapbox Vector Tiles (MVT). Currently the tiles contain 2 layers for edges and nodes with a lot of attributes (akin to <code>verbose</code> /locate requests). It's under active development, hence BETA, however, we don't expect any breaking changes to happen, mostly more \"Valhalla-like\" filtering of the response to decrease tile size, adding <code>style.json</code>(s) or performance improvements.</p> <p>View an interactive demo</p> <p>The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page.</p>"},{"location":"api/tile/api-reference/#request-options","title":"Request options","text":"<p>We support the usual GET &amp; POST with the common \"Slippy Map\"/XYZ request pattern. However, we expect x/y/z to be wrapped in a <code>\"tile\"</code> object. Extra tile-specific options can be added with a <code>tile_options</code> object. Typically one uses some SDK/clients to request tiles like Maplibre or QGIS.</p> Option Description <code>tile.z</code> The zoom level, max 30. Which zoom levels render which road classes depends on the <code>loki.service_defaults.mvt_min_zoom_road_class</code> server configuration. <code>tile.x</code> The \"slippy map\" X coordinate. <code>tile.y</code> The \"slippy map\" Y coordinate. <code>tile_options.exclude_layers</code> An array of layers to exclude in the response, one of [\"edges\", \"nodes\", \"shortcuts\"]. Default none. <code>filters</code> By default, the tiles only contain a small subset of attributes. Use <code>filters</code> to include more attributes:<ul><li><code>attributes</code>: an array of edge/node attributes to include/exclude, see below for a list</li><li><code>action</code>: either <code>include</code> or <code>exclude</code>. If <code>include</code>, we'll add the provided attributes to the default attributes. If <code>exclude</code>, we'll remove the provided attributes from the full list.</li></ul> <code>verbose</code> If <code>true</code>, it'll enable all attributes, regardless of <code>filters</code>. Default <code>false</code>. Note, that the service setting <code>service_limits.status.allow_verbose</code> applies here too. <code>generalize</code> A factor which scales the default (Douglas-Peucker) generalization, akin to tippecanoe's <code>simplification</code> argument. 1.0 returns the highest possible resolution, values &gt; 1.0 more aggressively generalize the line features. Default is 4.0"},{"location":"api/tile/api-reference/#attribute-filters","title":"Attribute filters","text":"<p>While we're re-using the same code as for <code>trace_attributes</code>, we don't support the full list for the tile endpoint and added some which are not implemented for <code>trace_attributes</code>. If not specified otherwise, the meaning of the attribute values is either trivial or available at https://valhalla.github.io/valhalla/api/map-matching/api-reference/#edge-items. <code>access</code> attributes are returning the numeric representation of a bit mask which needs to be decoded, see https://github.com/valhalla/valhalla/blob/c5151e19f65c3b498aa606a9cc9d6d274fba11bc/valhalla/baldr/graphconstants.h#L37-L47, e.g. a value of 1033 (<code>0b10000001001</code>) indicates <code>auto</code>, <code>truck</code> and <code>motorcycle</code> access etc.</p> <p>Note that <code>forward</code>/<code>backward</code> refer to the direction drawn in OSM and can be replaced in <code>&lt;direction&gt;</code>:</p> <pre><code>// bidirectional attributes\nedge.use  // see https://github.com/valhalla/demos/blob/aab1cd6d118703529c0f32e240271592b02e7f82/tile/index.html#L275-L311\nedge.tunnel\nedge.bridge\nedge.roundabout\nedge.is_shortcut\nedge.leaves_tile\nedge.length\nedge.weighted_grade\nedge.max_upward_grade\nedge.max_downward_grade\nedge.curvature\nedge.destination_only\nedge.destination_only_hgv\nedge.indoor\nedge.hov_type  // see https://github.com/valhalla/demos/blob/aab1cd6d118703529c0f32e240271592b02e7f82/tile/index.html#L275-L311\nedge.cycle_lane  // see https://github.com/valhalla/demos/blob/aab1cd6d118703529c0f32e240271592b02e7f82/tile/index.html#L275-L311\nedge.bicycle_network\nedge.truck_route\nedge.speed_type  // see https://github.com/valhalla/demos/blob/aab1cd6d118703529c0f32e240271592b02e7f82/tile/index.html#L275-L311\nedge.country_crossing\nedge.sac_scale  // see https://github.com/valhalla/demos/blob/aab1cd6d118703529c0f32e240271592b02e7f82/tile/index.html#L275-L311\nedge.unpaved\nedge.surface  // see https://github.com/valhalla/demos/blob/aab1cd6d118703529c0f32e240271592b02e7f82/tile/index.html#L275-L311\nedge.ramp\nedge.internal_intersection\nedge.shoulder\nedge.dismount\nedge.use_sidepath\nedge.density\nedge.sidewalk_left\nedge.sidewalk_right\nedge.bss_connection\nedge.lit\nedge.not_thru\nedge.part_of_complex_restriction\nedge.osm_id\nedge.speed_limit\nedge.layer\n\n// directional attributes\nedge.speed_&lt;direction&gt;\nedge.deadend_&lt;direction&gt;\nedge.lanecount_&lt;direction&gt;\nedge.truck_speed_&lt;direction&gt;\nedge.traffic_signal_&lt;direction&gt;\nedge.stop_sign_&lt;direction&gt;\nedge.yield_sign_&lt;direction&gt;\nedge.access_&lt;direction&gt;\nedge.live_speed_&lt;direction&gt;\n\n// node attributes\nnode.drive_on_right\nnode.elevation\nnode.tagged_access\nnode.private_access\nnode.cash_only_toll\nnode.mode_change_allowed\nnode.named_intersection\nnode.timezone\nnode.access\n</code></pre>"},{"location":"api/tile/api-reference/#integration-into-mvt-compatible-clientssdks-etc","title":"Integration into MVT compatible clients/SDKs etc","text":"<p>Most often software supporting MVT lets you specify a URL pattern expecting placeholders like <code>{z}/{x}/{y}?&lt;query_params&gt;</code>. For consistency's sake, we use our common <code>/?json=&lt;post_json&gt;</code> notation. Sadly that inteferes with placeholder parsing and the <code>&lt;post_json&gt;</code> usually has to be URL encoded for use in Maplibre/QGIS et al, e.g. <code>http://localhost:8002/tile?json=%7B%22tile%22%3A%7B%22z%22%3A{z}%2C%22x%22%3A{x}%2C%22y%22%3A{y}%7D%7D</code>. Note how x/y/z <code>{}</code> placeholders aren't encoded.</p> <p>See an example <code>style.json</code> here.</p>"},{"location":"api/tile/api-reference/#errorstatus-codes-and-messages","title":"Error/status codes and messages","text":"Status Code Status Description 174 Invalid tile coordinates Either omitted one of x/y/z OR x or y are out of bounds for z."},{"location":"api/turn-by-turn/api-reference/","title":"Valhalla routing service API reference","text":"<p>Valhalla's routing service (a.k.a. turn-by-turn), is an open-source routing service that lets you integrate routing and navigation into a web or mobile application.</p> <p>View an interactive demo</p> <p>The default logic for the OpenStreetMap tags, keys, and values used when routing are documented on an OSM wiki page.</p>"},{"location":"api/turn-by-turn/api-reference/#inputs-of-a-route","title":"Inputs of a route","text":"<p>The route request run locally takes the form of <code>localhost:8002/route?json={}</code>, where the JSON inputs inside the <code>{}</code> include location information, name and options for the costing model, and output options. Here is the JSON payload for an example request:</p> <pre><code>{\"locations\":[{\"lat\":42.358528,\"lon\":-83.271400,\"street\":\"Appleton\"},{\"lat\":42.996613,\"lon\":-78.749855,\"street\":\"Ranch Trail\"}],\"costing\":\"auto\",\"costing_options\":{\"auto\":{\"country_crossing_penalty\":2000.0}},\"units\":\"miles\",\"id\":\"my_work_route\"}\n</code></pre> <p>This request provides automobile routing between the Detroit, Michigan area and Buffalo, New York, with an optional street name parameter to improve navigation at the start and end points. It attempts to avoid routing north through Canada by adding a penalty for crossing international borders. The resulting route is displayed in miles.</p> <p>There is an option to name your route request. You can do this by appending the following to your request <code>&amp;id=</code>. The <code>id</code> is returned with the response so a user could match to the corresponding request.</p>"},{"location":"api/turn-by-turn/api-reference/#locations","title":"Locations","text":"<p>You specify locations as an ordered list of two or more locations within a JSON array. Locations are visited in the order specified.</p> <p>A location must include a latitude and longitude in decimal degrees. The coordinates can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service, and so on. Note that the Valhalla cannot search for names or addresses or perform geocoding or reverse geocoding. External search services, such as Mapbox Geocoding, can be used to find places and geocode addresses, which must be converted to coordinates for input.</p> <p>To build a route, you need to specify two <code>break</code> locations. In addition, you can include <code>through</code>, <code>via</code> or <code>break_through</code> locations to influence the route path.</p> Location parameters Description <code>lat</code> Latitude of the location in degrees. This is assumed to be both the routing location and the display location if no <code>display_lat</code> and <code>display_lon</code> are provided. <code>lon</code> Longitude of the location in degrees. This is assumed to be both the routing location and the display location if no <code>display_lat</code> and <code>display_lon</code> are provided. <code>type</code> Type of location, either <code>break</code>, <code>through</code>, <code>via</code> or <code>break_through</code>. Each type controls two characteristics: whether or not to allow a u-turn at the location and whether or not to generate guidance/legs at the location. A <code>break</code> is a location at which we allows u-turns and generate legs and arrival/departure maneuvers. A <code>through</code> location is a location at which we neither allow u-turns nor generate legs or arrival/departure maneuvers. A <code>via</code> location is a location at which we allow u-turns but do not generate legs or arrival/departure maneuvers. A <code>break_through</code> location is a location at which we do not allow u-turns but do generate legs and arrival/departure maneuvers. If no type is provided, the type is assumed to be a <code>break</code>. The types of the first and last locations are ignored and are treated as <code>break</code>s. <code>heading</code> (optional) Preferred direction of travel for the start from the location. This can be useful for mobile routing where a vehicle is traveling in a specific direction along a road, and the route should start in that direction. The <code>heading</code> is indicated in degrees from north in a clockwise direction, where north is 0\u00b0, east is 90\u00b0, south is 180\u00b0, and west is 270\u00b0. <code>heading_tolerance</code> (optional) How close in degrees a given street's angle must be in order for it to be considered as in the same direction of the <code>heading</code> parameter. The default value is 60 degrees. <code>street</code> (optional) Street name. The street name may be used to assist finding the correct routing location at the specified latitude, longitude. This is not currently implemented. <code>way_id</code> (optional) OpenStreetMap identification number for a polyline way. The way ID may be used to assist finding the correct routing location at the specified latitude, longitude. This is not currently implemented. <code>minimum_reachability</code> Minimum number of nodes (intersections) reachable for a given edge (road between intersections) to consider that edge as belonging to a connected region. When correlating this location to the route network, try to find candidates who are reachable from this many or more nodes (intersections). If a given candidate edge reaches less than this number of nodes its considered to be a disconnected island and we'll search for more candidates until we find at least one that isn't considered a disconnected island. If this value is larger than the configured service limit it will be clamped to that limit. The default is a minimum of 50 reachable nodes. <code>radius</code> The number of meters about this input location within which edges (roads between intersections) will be considered as candidates for said location. When correlating this location to the route network, try to only return results within this distance (meters) from this location. If there are no candidates within this distance it will return the closest candidate within reason. If this value is larger than the configured service limit it will be clamped to that limit. The default is 0 meters. <code>rank_candidates</code> Whether or not to rank the edge candidates for this location. The ranking is used as a penalty within the routing algorithm so that some edges will be penalized more heavily than others. If <code>true</code> candidates will be ranked according to their distance from the input and various other attributes. If <code>false</code> the candidates will all be treated as equal which should lead to routes that are just the most optimal path with emphasis about which edges were selected. <code>preferred_side</code> If the location is not offset from the road centerline or is closest to an intersection this option has no effect. Otherwise the determined side of street is used to determine whether or not the location should be visited from the <code>same</code>, <code>opposite</code> or <code>either</code> side of the road with respect to the side of the road the given locale drives on. In Germany (driving on the right side of the road), passing a value of <code>same</code> will only allow you to leave from or arrive at a location such that the location will be on your right. In Australia (driving on the left side of the road), passing a value of <code>same</code> will force the location to be on your left. A value of <code>opposite</code> will enforce arriving/departing from a location on the opposite side of the road from that which you would be driving on while a value of <code>either</code> will make no attempt limit the side of street that is available for the route. <code>display_lat</code> Latitude of the map location in degrees. If provided the <code>lat</code> and <code>lon</code> parameters will be treated as the routing location and the <code>display_lat</code> and <code>display_lon</code> will be used to determine the side of street. Both <code>display_lat</code> and <code>display_lon</code> must be provided and valid to achieve the desired effect. <code>display_lon</code> Longitude of the map location in degrees. If provided the <code>lat</code> and <code>lon</code> parameters will be treated as the routing location and the <code>display_lat</code> and <code>display_lon</code> will be used to determine the side of street. Both <code>display_lat</code> and <code>display_lon</code> must be provided and valid to achieve the desired effect. <code>search_cutoff</code> The cutoff at which we will assume the input is too far away from civilisation to be worth correlating to the nearest graph elements. The default is 35 km. <code>node_snap_tolerance</code> During edge correlation this is the tolerance used to determine whether or not to snap to the intersection rather than along the street, if the snap location is within this distance from the intersection the intersection is used instead. The default is 5 meters. <code>street_side_tolerance</code> If your input coordinate is less than this tolerance away from the edge centerline then we set your side of street to none otherwise your side of street will be left or right depending on direction of travel. The default is 5 meters. <code>street_side_max_distance</code> The max distance in meters that the input coordinates or display ll can be from the edge centerline for them to be used for determining the side of street. Beyond this distance the side of street is set to none. The default is 1000 meters. <code>street_side_cutoff</code> Disables the <code>preferred_side</code> when set to <code>same</code> or <code>opposite</code> if the edge has a road class less than that provided by <code>street_side_cutoff</code>. The road class must be one of the following strings: motorway, trunk, primary, secondary, tertiary, unclassified, residential, service_other.  The default value is <code>service_other</code> so that <code>preferred_side</code> will not be disabled for any edges. <code>search_filter</code> A set of optional filters to exclude candidate edges based on their attribution. The following exclusion filters are supported: <ul><li><code>exclude_tunnel</code> (boolean, defaults to <code>false</code>): whether to exclude roads marked as tunnels</li><li><code>exclude_bridge</code> (boolean, defaults to <code>false</code>): whether to exclude roads marked as bridges</li><li><code>exclude_toll</code> (boolean, defaults to <code>false</code>): whether to exclude toll</li><li><code>exclude_ferry</code> (boolean, defaults to <code>false</code>): whether to exclude ferry</li><li><code>exclude_ramp</code> (boolean, defaults to <code>false</code>): whether to exclude link roads marked as ramps, note that some turn channels are also marked as ramps</li><li><code>exclude_closures</code> (boolean, defaults to <code>true</code>): whether to exclude roads considered closed due to live traffic closure. Note: This option cannot be set if <code>costing_options.&lt;costing&gt;.ignore_closures</code> is also specified. An error is returned if both options are specified. Note 2: Ignoring closures at destination and source locations does NOT work for date_time type <code>0/1</code> &amp; <code>2</code> respectively</li><li><code>min_road_class</code> (string, defaults to <code>\"service_other\"</code>): lowest road class allowed</li><li><code>max_road_class</code> (string, defaults to <code>\"motorway\"</code>): highest road class allowed</li><li>BETA <code>level</code> (float): if specified, will only consider edges that are on or traverse the passed floor level. It will set <code>search_cutoff</code> to a default value of 300 meters if no cutoff value is passed. Additionally, if a <code>search_cutoff</code> is passed, it will be clamped to 1000 meters.</li></ul>Road classes from highest to lowest are: motorway, trunk, primary, secondary, tertiary, unclassified, residential, service_other. <code>preferred_layer</code> The layer on which edges should be considered. If provided, edges whose layer does not match the provided value will be discarded from the candidate search. <p>Optionally, you can include the following location information without impacting the routing. This information is carried through the request and returned as a convenience.</p> <ul> <li><code>name</code> = Location or business name. The name may be used in the route narration directions, such as \"You have arrived at &lt;business name&gt;.\")</li> <li><code>city</code> = City name.</li> <li><code>state</code> = State name.</li> <li><code>postal_code</code> = Postal code.</li> <li><code>country</code> = Country name.</li> <li><code>phone</code> = Telephone number.</li> <li><code>url</code> = URL for the place or location.</li> <li><code>waiting</code>: The waiting time in seconds at this location. E.g. when the route describes a pizza delivery tour, each location has a service time, which can be respected by setting <code>waiting</code> on the location, then the departure will be delayed by this amount in seconds. Only works for <code>break</code> or <code>break_through</code> types.</li> <li><code>side_of_street</code> = (response only) The side of street of a <code>break</code> <code>location</code> that is determined based on the actual route when the <code>location</code> is offset from the street. The possible values are <code>left</code> and <code>right</code>.</li> <li><code>date_time</code> = (response only for <code>/route</code>) Expected date/time for the user to be at the location using the ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival.  For example \"2015-12-29T08:00\". If <code>waiting</code> was set on this location in the request, and it's an intermediate location, the <code>date_time</code> will describe the departure time at this location.</li> </ul> <p>Future development work includes adding location options and information related to time at each location. This will allow routes to specify a start time or an arrive by time at each location. There is also ongoing work to improve support for <code>through</code> locations.</p>"},{"location":"api/turn-by-turn/api-reference/#costing-models","title":"Costing models","text":"<p>Valhalla's routing service uses dynamic, run-time costing to generate the route path. The route request must include the name of the costing model and can include optional parameters available for the chosen costing model.</p> Costing model Description <code>auto</code> Standard costing for driving routes by car, motorcycle, truck, and so on that obeys automobile driving rules, such as access and turn restrictions. <code>Auto</code> provides a short time path (though not guaranteed to be shortest time) and uses intersection costing to minimize turns and maneuvers or road name changes. Routes also tend to favor highways and higher classification roads, such as motorways and trunks. <code>bicycle</code> Standard costing for travel by bicycle, with a slight preference for using cycleways or roads with bicycle lanes. Bicycle routes follow regular roads when needed, but avoid roads without bicycle access. <code>bus</code> Standard costing for bus routes. Bus costing inherits the auto costing behaviors, but checks for bus access on the roads. BETA <code>bikeshare</code> A combination of pedestrian and bicycle. Use bike share station(<code>amenity:bicycle_rental</code>) to change the travel mode <code>truck</code> Standard costing for trucks. Truck costing inherits the auto costing behaviors, but checks for truck access, width and height restrictions, and weight limits on the roads. <code>hov</code> DEPRECATED: use <code>auto</code> cost with HOV costing options. <code>taxi</code> Standard costing for taxi routes. Taxi costing inherits the auto costing behaviors, but checks for taxi lane access on the roads and favors those roads. <code>motor_scooter</code> Standard costing for travel by motor scooter or moped.  By default, motor_scooter costing will avoid higher class roads unless the country overrides allows motor scooters on these roads.  Motor scooter routes follow regular roads when needed, but avoid roads without motor_scooter, moped, or mofa access. BETA <code>motorcycle</code> Standard costing for travel by motorcycle.  This costing model provides options to tune the route to take roadways (road touring) vs. tracks and trails (adventure motorcycling). <code>multimodal</code> Currently supports pedestrian and transit. In the future, multimodal will support a combination of all of the above. <code>pedestrian</code> Standard walking route that excludes roads without pedestrian access. In general, pedestrian routes are shortest distance with the following exceptions: walkways and footpaths are slightly favored, while steps or stairs and alleys are slightly avoided. BETA <code>auto_pedestrian</code> A combination of <code>auto</code> and <code>pedestrian</code>, that assumes starting with <code>auto</code> and ending with <code>pedestrian</code>. Uses parking lots to change the travel mode"},{"location":"api/turn-by-turn/api-reference/#costing-options","title":"Costing options","text":"<p>Costing methods can have several options that can be adjusted to develop the route path, as well as for estimating time along the path. Specify costing model options in your request using the format of <code>costing_options.type</code>, such as <code>costing_options.auto</code>.</p> <ul> <li>Cost options are fixed costs in seconds that are added to both the path cost and the estimated time. Examples of costs are <code>gate_costs</code> and <code>toll_booth_costs</code>, where a fixed amount of time is added. Costs are not generally used to influence the route path; instead, use penalties to do this. Costs must be in the range of 0.0 seconds to 43200.0 seconds (12 hours), otherwise a default value will be assigned.</li> <li>Penalty options are fixed costs in seconds that are only added to the path cost. Penalties can influence the route path determination but do not add to the estimated time along the path. For example, add a <code>toll_booth_penalty</code> to create route paths that tend to avoid toll booths. Penalties must be in the range of 0.0 seconds to 43200.0 seconds (12 hours), otherwise a default value will be assigned.</li> <li>Factor options are used to multiply the cost along an edge or road section in a way that influences the path to favor or avoid a particular attribute. Factor options do not impact estimated time along the path, though. Factors must be in the range 0.1 to 100000.0, where factors of 1.0 have no influence on cost. Anything outside of this range will be assigned a default value. Use a factor less than 1.0 to attempt to favor paths containing preferred attributes, and a value greater than 1.0 to avoid paths with undesirable attributes. Avoidance factors are more effective than favor factors at influencing a path. A factor's impact also depends on the length of road containing the specified attribute, as longer roads have more impact on the costing than very short roads. For this reason, penalty options tend to be better at influencing paths.</li> </ul> <p>A special costing option is <code>shortest</code>, which, when <code>true</code>, will solely use distance as cost and disregard all other costs, penalties and factors. It's available for all costing models except multimodal ones (<code>multimodal</code>/<code>transit</code>, <code>bikeshare</code> &amp; <code>auto_pedestrian</code>).</p> <p>Another special case is <code>disable_hierarchy_pruning</code> costing option. As the name indicates, <code>disable_hierarchy_pruning = true</code> will disable hierarchies in routing algorithms, which allows us to find the actual optimal route even in edge cases. For example, together with <code>shortest = true</code> they can find the actual shortest route. When <code>disable_hierarchy_pruning</code> is <code>true</code> and arc distances between source and target are not above the max limit, the actual optimal route will be calculated at the expense of performance. Note that if arc distances between locations exceed the max limit, <code>disable_hierarchy_pruning</code> is <code>true</code> will not be applied. This costing option is available for all motorized costing models, i.e <code>auto</code>, <code>motorcycle</code>, <code>motor_scooter</code>, <code>bus</code>, <code>truck</code> &amp; <code>taxi</code>. For <code>bicycle</code> and <code>pedestrian</code> hierarchies are always disabled by default.</p> <p>Additionally to the main costing option, the <code>recostings</code> option can be used to calculate the travelling time of the found route based on different costing options. By e.g. adding <pre><code>\"recostings\":[\n    {\"costing\":\"auto\",\"fixed_speed\":20,\"name\":\"auto_20\"},\n    {\"costing\":\"auto\",\"fixed_speed\":50,\"name\":\"auto_50\"}\n]\n</code></pre> to the route request, the values <code>time_auto_20</code> and <code>time_auto_50</code> will be added to summaries to show how much time the route would cost with these given costing options. Passing a recosting which make the route impossible to follow (e.g. the main rout is by car over a motorway and recosting with pedestrian costing) leads to a <code>none</code> result of this recosting.</p>"},{"location":"api/turn-by-turn/api-reference/#automobile-and-bus-costing-options","title":"Automobile and bus costing options","text":"<p>These options are available for <code>auto</code>, <code>bus</code>, and <code>truck</code> costing methods.</p> Automobile options Description <code>maneuver_penalty</code> A penalty applied when transitioning between roads that do not have consistent naming\u2013in other words, no road names in common. This penalty can be used to create simpler routes that tend to have fewer maneuvers or narrative guidance instructions. The default maneuver penalty is five seconds. <code>gate_cost</code> A cost applied when a gate with undefined or private access is encountered. This cost is added to the estimated time / elapsed time. The default gate cost is 30 seconds. <code>gate_penalty</code> A penalty applied when a gate with no access information is on the road. The default gate penalty is 300 seconds. <code>private_access_penalty</code> A penalty applied when a gate or bollard with <code>access=private</code> is encountered. The default private access penalty is 450 seconds. <code>destination_only_penalty</code> A penalty applied when entering an road which is only allowed to enter if necessary to reach the destination. <code>toll_booth_cost</code> A cost applied when a toll booth is encountered. This cost is added to the estimated and elapsed times. The default cost is 15 seconds. <code>toll_booth_penalty</code> A penalty applied to the cost when a toll booth is encountered. This penalty can be used to create paths that avoid toll roads. The default toll booth penalty is 0. <code>ferry_cost</code> A cost applied when entering a ferry. This cost is added to the estimated and elapsed times. The default cost is 300 seconds (5 minutes). <code>use_ferry</code> This value indicates the willingness to take ferries. This is a range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. The default value is 0.5. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. <code>use_highways</code> This value indicates the willingness to take highways. This is a range of values between 0 and 1. Values near 0 attempt to avoid highways and values near 1 will favor highways. The default value is 0.5. Note that sometimes highways are required to complete a route so values of 0 are not guaranteed to avoid highways entirely. <code>use_tolls</code> This value indicates the willingness to take roads with tolls. This is a range of values between 0 and 1. Values smaller than 0.5 attempt to avoid tolls and values greater than 0.5 will slightly favor them. The default value is 0.5, indicating no preference. Note that sometimes roads with tolls are required to complete a route so values of 0 are not guaranteed to avoid them entirely. <code>use_living_streets</code> This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values near 1 will favor living streets. The default value is 0 for trucks, 0.1 for cars, buses, motor scooters and motorcycles. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. <code>use_tracks</code> This value indicates the willingness to take track roads. This is a range of values between 0 and 1. Values near 0 attempt to avoid tracks and values near 1 will favor tracks a little bit. The default value is 0 for autos, 0.5 for motor scooters and motorcycles. Note that sometimes tracks are required to complete a route so values of 0 are not guaranteed to avoid tracks entirely. <code>service_penalty</code> A penalty applied for transition to generic service road. The default penalty is 0 trucks and 15 for cars, buses, motor scooters and motorcycles. <code>service_factor</code> A factor that modifies (multiplies) the cost when generic service roads are encountered. The default <code>service_factor</code> is 1. <code>country_crossing_cost</code> A cost applied when encountering an international border. This cost is added to the estimated and elapsed times. The default cost is 600 seconds. <code>country_crossing_penalty</code> A penalty applied for a country crossing. This penalty can be used to create paths that avoid spanning country boundaries. The default penalty is 0. <code>shortest</code> Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings &amp; penalties. Also note, <code>shortest</code> will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is <code>false</code>. <code>use_distance</code> A factor that allows controlling the contribution of distance and time to the route costs. The value is in range between 0 and 1, where 0 only takes time into account (default) and 1 only distance. A factor of 0.5 will weight them roughly equally. Note: this costing is currently only available for auto costing. <code>disable_hierarchy_pruning</code> Disable hierarchies to calculate the actual optimal route. The default is <code>false</code>. Note: This could be quite a performance drainer so there is a upper limit of distance. If the upper limit is exceeded, this option will always be <code>false</code>. <code>top_speed</code> Top speed the vehicle can go. Also used to avoid roads with higher speeds than this value. <code>top_speed</code> must be between 10 and 252 KPH. The default value is 120 KPH for <code>truck</code> and 140 KPH for <code>auto</code> and <code>bus</code>. <code>fixed_speed</code> Fixed speed the vehicle can go. Used to override the calculated speed. Can be useful if speed of vehicle is known. <code>fixed_speed</code> must be between 1 and 252 KPH. The default value is 0 KPH which disables fixed speed and falls back to the standard calculated speed based on the road attribution. <code>ignore_closures</code> If set to <code>true</code>, ignores all closures, marked due to live traffic closures, during routing. Note: This option cannot be set if <code>location.search_filter.exclude_closures</code> is also specified in the request and will return an error if it is. Default is <code>false</code> <code>closure_factor</code> A factor that penalizes the cost when traversing a closed edge (eg: if <code>search_filter.exclude_closures</code> is <code>false</code> for origin and/or destination location and the route starts/ends on closed edges). Its value can range from <code>1.0</code> - don't penalize closed edges, to <code>10.0</code> - apply high cost penalty to closed edges. Default value is <code>9.0</code>. Note: This factor is applicable only for motorized modes of transport, i.e <code>auto</code>, <code>motorcycle</code>, <code>motor_scooter</code>, <code>bus</code>, <code>truck</code> &amp; <code>taxi</code>. <code>ignore_restrictions</code> If set to <code>true</code>, ignores any restrictions (e.g. turn/dimensional/conditional restrictions). Especially useful for matching GPS traces to the road network regardless of restrictions. Default is <code>false</code>. <code>ignore_oneways</code> If set to <code>true</code>, ignores one-way restrictions. Especially useful for matching GPS traces to the road network ignoring uni-directional traffic rules. Not included in <code>ignore_restrictions</code> option. Default is <code>false</code>. <code>ignore_non_vehicular_restrictions</code> Similar to <code>ignore_restrictions</code>, but will respect restrictions that impact vehicle safety, such as weight and size restrictions. <code>ignore_access</code> Will ignore mode-specific access tags. Especially useful for matching GPS traces to the road network regardless of restrictions. Default is <code>false</code>. <code>ignore_construction</code> Will ignore construction tags. Only works when the <code>include_construction</code> option is set before building the graph. Useful for planning future routes. Default is <code>false</code>. <code>speed_types</code> Will determine which speed sources are used, if available. A list of strings with the following possible values: <ul><li><code>freeflow</code></li><li><code>constrained</code></li><li><code>predicted</code></li><li><code>current</code></li></ul> Default is all sources (again, only if available). <code>hierarchy_limits</code> (beta) Pass custom hierarchy limits along with this request (read more about the tile hierarchy here). Needs to be an object with mandatory keys <code>1</code> and <code>2</code>, each value is another object containing numerical values for <code>max_up_transitions</code> and <code>expand_within_distance</code>. The service may either clamp these values or disallow modifying hierarchy limits via the request parameters entirely."},{"location":"api/turn-by-turn/api-reference/#other-costing-options","title":"Other costing options","text":"<p>The following options are available for <code>auto</code>, <code>bus</code>, <code>taxi</code>, and <code>truck</code> costing methods.</p> Vehicle Options Description <code>height</code> The height of the vehicle (in meters). Default 1.9 for car, bus, taxi and 4.11 for truck. <code>width</code> The width of the vehicle (in meters). Default 1.6 for car, bus, taxi and 2.6 for truck. <code>length</code> The length of the vehicle (in meters). Default 2.7 for car, bus, taxi and 21.64 for truck. <code>weight</code> The weight of the vehicle (in tons). Default 0.8 for car, bus, taxi and 21.77 for truck. <code>exclude_unpaved</code> This value indicates whether or not the path may include unpaved roads. If <code>exclude_unpaved</code> is set to 1 it is allowed to start and end with unpaved roads, but is not allowed to have them in the middle of the route path, otherwise they are allowed. Default false. <code>exclude_cash_only_tolls</code> A boolean value which indicates the desire to avoid routes with cash-only tolls. Default false. <code>include_hov2</code> A boolean value which indicates the desire to include HOV roads with a 2-occupant requirement in the route when advantageous. Default false. <code>include_hov3</code> A boolean value which indicates the desire to include HOV roads with a 3-occupant requirement in the route when advantageous. Default false. <code>include_hot</code> A boolean value which indicates the desire to include tolled HOV roads which require the driver to pay a toll if the occupant requirement isn't met. Default false. <code>speed_penalty_factor</code> Penalty factor applied for edges when edge speed is faster than top speed. The default value is 0.05. <p>The following options are available for <code>truck</code> costing.</p> Truck options Description <code>axle_load</code> The axle load of the truck (in metric tons). Default 9.07. <code>axle_count</code> The axle count of the truck. Default 5. <code>hazmat</code> A value indicating if the truck is carrying hazardous materials. Default false. <code>hgv_no_access_penalty</code> A penalty applied to roads with no HGV/truck access. If set to a value less than 43200 seconds, HGV will be allowed on these roads and the penalty applies. Default 43200, i.e. trucks are not allowed. <code>low_class_penalty</code> A penalty (in seconds) which is applied when going to residential or service roads. Default is 30 seconds. <code>use_truck_route</code> This value is a range of values from 0 to 1, where 0 indicates a light preference for streets marked as truck routes, and 1 indicates that streets not marked as truck routes should be avoided. This information is derived from the <code>hgv=designated</code> tag. Note that even with values near 1, there is no guarantee the returned route will include streets marked as truck routes. The default value is 0."},{"location":"api/turn-by-turn/api-reference/#bicycle-costing-options","title":"Bicycle costing options","text":"<p>The default bicycle costing is tuned toward road bicycles with a slight preference for using cycleways or roads with bicycle lanes. Bicycle routes use regular roads where needed or where no direct bicycle lane options exist, but avoid roads without bicycle access. The costing model recognizes several factors unique to bicycle travel and offers several options for tuning bicycle routes. Several factors unique to travel by bicycle influence the resulting route.</p> <ul> <li>The types of roads suitable for bicycling depend on the type of bicycle. Road bicycles (skinny or narrow tires) generally are suited to paved roads or perhaps very short sections of compacted gravel. They are not designed for riding on coarse gravel or most paths and tracks through wooded areas or farmland. Mountain bikes, on the other hand, are able to traverse a wider set of surfaces.</li> <li>Average travel speed can be highly variable and can depend on bicycle type, fitness and experience of the cyclist, road surface, and hills. The costing model assumes a default speed on smooth, flat roads for each supported bicycle type. This speed can be overridden by an input option. The base speed is modulated by surface type (in conjunction with the bicycle type). In addition, speed is modified based on the hilliness of a road section.</li> <li>Bicyclists vary in their tolerance for riding on roads. Most novice bicyclists, and even other bicyclists, prefer cycleways and dedicated cycling paths and would rather avoid all but the quietest neighborhood roads. Other cyclists may be experienced riding on roads and prefer to take roadways because they often provide the fastest way to get between two places. The bicycle costing model accounts for this with a <code>use_roads</code> factor to indicate a cyclist's tolerance for riding on roads.</li> <li>Bicyclists vary in their fitness level and experience level, and many want to avoid hilly roads, and especially roads with very steep uphill or even downhill sections. Even if the fastest path is over a mountain, many cyclists prefer a flatter path that avoids the climb and descent up and over the mountain.</li> </ul> <p>The following options described above for autos also apply to bicycle costing methods: <code>maneuver_penalty</code>, <code>gate_cost</code>, <code>gate_penalty</code>,  <code>destination_only_penalty</code> , <code>country_crossing_cost</code>, <code>country_costing_penalty</code>, and <code>service_penalty</code>.</p> <p>These additional options are available for bicycle costing methods.</p> Bicycle options Description <code>bicycle_type</code> The type of bicycle. The default type is <code>hybrid</code>. <ul><li><code>road</code>: a road-style bicycle with narrow tires that is generally lightweight and designed for speed on paved surfaces. </li><li><code>hybrid</code> or <code>city</code>: a bicycle made mostly for city riding or casual riding on roads and paths with good surfaces.</li><li><code>cross</code>: a cyclo-cross bicycle, which is similar to a road bicycle but with wider tires suitable to rougher surfaces.</li><li><code>mountain</code>: a mountain bicycle suitable for most surfaces but generally heavier and slower on paved surfaces.</li><ul> <code>cycling_speed</code> Cycling speed is the average travel speed along smooth, flat roads. This is meant to be the speed a rider can comfortably maintain over the desired distance of the route. It can be modified (in the costing method) by surface type in conjunction with bicycle type and (coming soon) by hilliness of the road section. When no speed is specifically provided, the default speed is determined by the bicycle type and are as follows:<ul><li><code>road</code> = 25 KPH (15.5 MPH),</li><li><code>cross</code> = 20 KPH (13 MPH),<li></li><code>hybrid</code>/<code>city</code> = 18 KPH (11.5 MPH),<li></li>and <code>mountain</code> = 16 KPH (10 MPH).</li></ul> <code>use_roads</code> A cyclist's propensity to use roads alongside other vehicles. This is a range of values from 0 to 1, where 0 attempts to avoid roads and stay on cycleways and paths, and 1 indicates the rider is more comfortable riding on roads. Based on the <code>use_roads</code> factor, roads with certain classifications and higher speeds are penalized in an attempt to avoid them when finding the best path. The default value is 0.5. <code>use_hills</code> A cyclist's desire to tackle hills in their routes. This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the rider does not fear hills and steeper grades. Based on the <code>use_hills</code> factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. <code>use_ferry</code> This value indicates the willingness to take ferries. This is a range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. The default value is 0.5. <code>use_living_streets</code> This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values from 0.5 to 1 will currently have no effect on route selection. The default value is 0.5. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. <code>avoid_bad_surfaces</code> This value is meant to represent how much a cyclist wants to avoid roads with poor surfaces relative to the bicycle type being used. This is a range of values between 0 and 1. When the value is 0, there is no penalization of roads with different surface types; only bicycle speed on each surface is taken into account. As the value approaches 1, roads with poor surfaces for the bike are penalized heavier so that they are only taken if they significantly improve travel time. When the value is equal to 1, all bad surfaces are completely disallowed from routing, including start and end points. The default value is 0.25. <code>bss_return_cost</code> This value is useful when <code>bikeshare</code> is chosen as travel mode. It is meant to give the time will be used to return a rental bike. This value will be displayed in the final directions and used to calculate the whole duration. The default value is 120 seconds. <code>bss_return_penalty</code> This value is useful when <code>bikeshare</code> is chosen as travel mode. It is meant to describe the potential effort to return a rental bike. This value won't be displayed and used only inside of the algorithm. <code>shortest</code> Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings &amp; penalties. Also note, <code>shortest</code> will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is <code>false</code>."},{"location":"api/turn-by-turn/api-reference/#motor_scooter-costing-options","title":"Motor_scooter costing options","text":"<p>Standard costing for travel by motor scooter or moped.  By default, motor_scooter costing will avoid higher class roads unless the country overrides allows motor scooters on these roads.  Motor scooter routes follow regular roads when needed, but avoid roads without motor_scooter, moped, or mofa access. The costing model recognizes factors unique to motor_scooter travel and offers options for tuning motor_scooter routes. Factors unique to travel by motor_scooter influence the resulting route.</p> <p>All of the options described above for autos also apply to motor_scooter costing methods.  These additional options are available for motor_scooter costing methods.</p> Motor_scooter options Description <code>top_speed</code> Top speed the motorized scooter can go. Used to avoid roads with higher speeds than this value. For <code>motor_scooter</code> this value must be between 20 and 120 KPH. The default value is 45 KPH (~28 MPH) <code>speed_penalty_factor</code> Penalty factor applied for edges when edge speed is faster than top speed. The default value is 0.05. <code>use_primary</code> A rider's propensity to use primary roads. This is a range of values from 0 to 1, where 0 attempts to avoid primary roads, and 1 indicates the rider is more comfortable riding on primary roads. Based on the <code>use_primary</code> factor, roads with certain classifications and higher speeds are penalized in an attempt to avoid them when finding the best path. The default value is 0.5. <code>use_hills</code> A rider's desire to tackle hills in their routes. This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the rider does not fear hills and steeper grades. Based on the <code>use_hills</code> factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. <code>shortest</code> Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings &amp; penalties. Also note, <code>shortest</code> will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is <code>false</code>. <code>disable_hierarchy_pruning</code> Disable hierarchies to calculate the actual optimal route. The default is <code>false</code>. Note: This could be quite a performance drainer so there is a upper limit of distance. If the upper limit is exceeded, this option will always be <code>false</code>."},{"location":"api/turn-by-turn/api-reference/#motorcycle-costing-options-beta","title":"Motorcycle costing options -&gt; BETA","text":"<p>Standard costing for travel by motorcycle.  By default, motorcycle costing will default to higher class roads.  The costing model recognizes factors unique to motorcycle travel and offers options for tuning motorcycle routes.</p> <p>All of the options described above for autos also apply to motorcycle costing methods. The following options are available for motorcycle costing:</p> Motorcycle options Description <code>use_highways</code> A riders's propensity to prefer the use of highways. This is a range of values from 0 to 1, where 0 attempts to avoid highways, and values toward 1 indicates the rider prefers highways. The default value is 0.5. <code>use_trails</code> A riders's desire for adventure in their routes.  This is a range of values from 0 to 1, where 0 will avoid trails, tracks, unclassified or bad surfaces and values towards 1 will tend to avoid major roads and route on secondary roads.  The default value is 0.0. <code>shortest</code> Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings &amp; penalties. Also note, <code>shortest</code> will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is <code>false</code>. <code>disable_hierarchy_pruning</code> Disable hierarchies to calculate the actual optimal route. The default is <code>false</code>. Note: This could be quite a performance drainer so there is a upper limit of distance. If the upper limit is exceeded, this option will always be <code>false</code>."},{"location":"api/turn-by-turn/api-reference/#pedestrian-costing-options","title":"Pedestrian costing options","text":"<p>These options are available for pedestrian costing methods.</p> Pedestrian options Description <code>walking_speed</code> Walking speed in kilometers per hour. Must be between 0.5 and 25 km/hr. Defaults to 5.1 km/hr (3.1 miles/hour). <code>walkway_factor</code> A factor that modifies the cost when encountering roads classified as <code>footway</code> (no motorized vehicles allowed), which may be designated footpaths or designated sidewalks along residential roads. Pedestrian routes generally attempt to favor using these walkways and sidewalks. The default walkway_factor is 1.0. <code>sidewalk_factor</code> A factor that modifies the cost when encountering roads with dedicated sidewalks. Pedestrian routes generally attempt to favor using sidewalks. The default sidewalk_factor is 1.0. <code>alley_factor</code> A factor that modifies (multiplies) the cost when alleys are encountered. Pedestrian routes generally want to avoid alleys or narrow service roads between buildings. The default alley_factor is 2.0. <code>driveway_factor</code> A factor that modifies (multiplies) the cost when encountering a driveway, which is often a private, service road. Pedestrian routes generally want to avoid driveways (private). The default driveway factor is 5.0. <code>step_penalty</code> A penalty in seconds added to each transition onto a path with steps or stairs. Higher values apply larger cost penalties to avoid paths that contain flights of steps. <code>elevator_penalty</code> A penalty in seconds added to each transition via an elevator node or onto an elevator edge. Higher values apply larger cost penalties to avoid elevators. <code>use_ferry</code> This value indicates the willingness to take ferries. This is range of values between 0 and 1. Values near 0 attempt to avoid ferries and values near 1 will favor ferries. The default value is 0.5. Note that sometimes ferries are required to complete a route so values of 0 are not guaranteed to avoid ferries entirely. <code>use_living_streets</code> This value indicates the willingness to take living streets. This is a range of values between 0 and 1. Values near 0 attempt to avoid living streets and values near 1 will favor living streets. The default value is 0.6. Note that sometimes living streets are required to complete a route so values of 0 are not guaranteed to avoid living streets entirely. <code>use_tracks</code> This value indicates the willingness to take track roads. This is a range of values between 0 and 1. Values near 0 attempt to avoid tracks and values near 1 will favor tracks a little bit. The default value is 0.5. Note that sometimes tracks are required to complete a route so values of 0 are not guaranteed to avoid tracks entirely. <code>use_hills</code> This is a range of values from 0 to 1, where 0 attempts to avoid hills and steep grades even if it means a longer (time and distance) path, while 1 indicates the pedestrian does not fear hills and steeper grades. Based on the <code>use_hills</code> factor, penalties are applied to roads based on elevation change and grade. These penalties help the path avoid hilly roads in favor of flatter roads or less steep grades where available. Note that it is not always possible to find alternate paths to avoid hills (for example when route locations are in mountainous areas). The default value is 0.5. <code>use_lit</code> This value is a range of values from 0 to 1, where 0 indicates indifference towards lit streets, and 1 indicates that unlit streets should be avoided. Note that even with values near 1, there is no guarantee the returned route will include lit segments. The default value is 0. <code>service_penalty</code> A penalty applied for transition to generic service road. The default penalty is 0. <code>service_factor</code> A factor that modifies (multiplies) the cost when generic service roads are encountered. The default <code>service_factor</code> is 1. <code>destination_only_penalty</code> A penalty applied when entering an road which is only allowed to enter if necessary to reach the destination <code>max_hiking_difficulty</code> This value indicates the maximum difficulty of hiking trails that is allowed. Values between 0 and 6 are allowed. The values correspond to sac_scale values within OpenStreetMap, see reference here. The default value is 1 which means that well cleared trails that are mostly flat or slightly sloped are allowed. Higher difficulty trails can be allowed by specifying a higher value for max_hiking_difficulty. <code>bss_rent_cost</code> This value is useful when <code>bikeshare</code> is chosen as travel mode. It is meant to give the time will be used to rent a bike from a bike share station. This value will be displayed in the final directions and used to calculate the whole duration. The default value is 120 seconds. <code>bss_rent_penalty</code> This value is useful when <code>bikeshare</code> is chosen as travel mode. It is meant to describe the potential effort to rent a bike from a bike share station. This value won't be displayed and used only inside of the algorithm. <code>shortest</code> Changes the metric to quasi-shortest, i.e. purely distance-based costing. Note, this will disable all other costings &amp; penalties. Also note, <code>shortest</code> will not disable hierarchy pruning, leading to potentially sub-optimal routes for some costing models. The default is <code>false</code>. <code>max_distance</code> Sets the maximum total walking distance of a route. Default is 100 km (~62 miles). <code>multimodal_start_end_max_distance</code> (Note: renamed from <code>transit_start_end_max_distance</code>) A pedestrian option that can be added to the request to extend the defaults (2145 meters or approximately 1.5 miles). This is the maximum walking distance at the beginning or end of a route. <code>transit_transfer_max_distance</code> A pedestrian option that can be added to the request to extend the defaults (800 meters or 0.5 miles). This is the maximum walking distance between transfers. <code>type</code> <ul><li>If set to <code>blind</code>, enables additional route instructions, especially useful for blind users: Announcing crossed streets, the stairs, bridges, tunnels, gates and bollards, which need to be passed on route; information about traffic signals on crosswalks; route numbers not announced for named routes.</li><li>If set to <code>wheelchair</code>, changes the defaults for <code>max_distance</code>, <code>walking_speed</code>, and <code>step_penalty</code> to be better aligned to the needs of wheelchair users.</li></ul> These two options are mutually exclusive. In case you want to combine them, please use <code>blind</code> and pass the options adjusted for <code>wheelchair</code> users manually. Default <code>foot</code> <code>mode_factor</code> A factor which the cost of a pedestrian edge will be multiplied with on multimodal request, e.g. <code>bss</code> or <code>multimodal/transit</code>. Default is a factor of 1.5, i.e. avoiding walking."},{"location":"api/turn-by-turn/api-reference/#transit-costing-options","title":"Transit costing options","text":"<p>These options are available for transit costing when the multimodal costing model is used.</p> Transit options Description <code>use_bus</code> User's desire to use buses. Range of values from 0 (try to avoid buses) to 1 (strong preference for riding buses). <code>use_rail</code> User's desire to use rail/subway/metro. Range of values from 0 (try to avoid rail) to 1 (strong preference for riding rail). <code>use_transfers</code> User's desire to favor transfers. Range of values from 0 (try to avoid transfers) to 1 (totally comfortable with transfers). <code>filters</code> A way to filter for one or more <code>stops</code> (TODO: need to re-enable), <code>routes</code>, or <code>operators</code>. Filters must contain a list of so-called Onestop IDs, which is (supposed to be) a unique identifier for GTFS data, and an <code>action</code>. The OneStop ID is simply the feeds's directory name and the object's GTFS ID separated by an underscore, i.e. a route with <code>route_id: AUR</code> in <code>routes.txt</code> from the feed <code>NYC</code> would have the OneStop ID <code>NYC_AUR</code>, similar with operators/agencies. <ul><li><code>ids</code>: any number of Onestop IDs</li><li><code>action</code>: either <code>exclude</code> to exclude all of the <code>ids</code> listed in the filter or <code>include</code> to include only the <code>ids</code> listed in the filter</li></ul>"},{"location":"api/turn-by-turn/api-reference/#hard-exclusions-experimental","title":"Hard exclusions -&gt; EXPERIMENTAL","text":"<p>The following options are available for all costing methods. Those options are not available by default, the server config must have <code>service_limits.allow_hard_exclusions</code> set to true in order to allow them. If not allowed and any of the hard excludes is set to true, the server will return a warning and ignore the hard excludes.</p> Vehicle Options Description <code>exclude_bridges</code> This value indicates whether or not the path may include bridges. If <code>exclude_bridges</code> is set to true it is allowed to start and end with bridges, but is not allowed to have them in the middle of the route path, otherwise they are allowed. If set to true, it is highly plausible that no path will be found. Default false. <code>exclude_tunnels</code> This value indicates whether or not the path may include tunnels. If <code>exclude_tunnels</code> is set to true it is allowed to start and end with tunnels, but is not allowed to have them in the middle of the route path, otherwise they are allowed. If set to true, it is highly plausible that no path will be found. Default false. <code>exclude_tolls</code> This value indicates whether or not the path may include tolls. If <code>exclude_tolls</code> is set to true it is allowed to start and end with tolls, but is not allowed to have them in the middle of the route path, otherwise they are allowed. If set to true, it is highly plausible that no path will be found. Default false. <code>exclude_highways</code> This value indicates whether or not the path may include highways. If <code>exclude_highways</code> is set to true it is allowed to start and end with highways, but is not allowed to have them in the middle of the route path, otherwise they are allowed. If set to true, it is highly plausible that no path will be found. Default false. <code>exclude_ferries</code> This value indicates whether or not the path may include ferries. If <code>exclude_ferries</code> is set to true it is allowed to start and end with ferries, but is not allowed to have them in the middle of the route path, otherwise they are allowed. If set to true, it is highly plausible that no path will be found. Default false."},{"location":"api/turn-by-turn/api-reference/#sample-json-payloads-for-multimodal-requests-with-transit","title":"Sample JSON payloads for multimodal requests with transit","text":"<p>A multimodal request at the current date and time:</p> <pre><code>{\"locations\":[{\"lat\":40.730930,\"lon\":-73.991379,\"street\":\"Wanamaker Place\"},{\"lat\":40.749706,\"lon\":-73.991562,\"street\":\"Penn Plaza\"}],\"costing\":\"multimodal\",\"units\":\"miles\"}\n</code></pre> <p>A multimodal request departing on 2016-03-29 at 08:00:</p> <pre><code>{\"locations\":[{\"lat\":40.749706,\"lon\":-73.991562,\"type\":\"break\",\"street\":\"Penn Plaza\"},{\"lat\":40.73093,\"lon\":-73.991379,\"type\":\"break\",\"street\":\"Wanamaker Place\"}],\"costing\":\"multimodal\",\"date_time\":{\"type\":1,\"value\":\"2016-03-29T08:00\"}}\n</code></pre> <p>A multimodal request for a route favoring buses and a person walking at a set speed of 4.1 km/h:</p> <pre><code>{\"locations\":[{\"lat\":40.749706,\"lon\":-73.991562,\"type\":\"break\",\"street\":\"Penn Plaza\"},{\"lat\":40.73093,\"lon\":-73.991379,\"type\":\"break\",\"street\":\"Wanamaker Place\"}],\"costing\":\"multimodal\",\"costing_options\":{\"transit\":{\"use_bus\":\"1.0\",\"use_rail\":\"0.0\",\"use_transfers\":\"0.3\"},\"pedestrian\":{\"walking_speed\":\"4.1\"}}}\n</code></pre> <p>A multimodal request with a filter for certain Onestop IDs:</p> <pre><code>{\"locations\":[{\"lat\":40.730930,\"lon\":-73.991379,\"street\":\"Wanamaker Place\"},{\"lat\":40.749706,\"lon\":-73.991562,\"street\":\"Penn Plaza\"}],\"costing\":\"multimodal\",\"costing_options\":{\"transit\":{\"filters\":{\"routes\":{\"ids\":[\"NYC_AUR\"],\"action\":\"exclude\"},\"operators\":{\"ids\":[\"paris_CFG\",\"berlin_VBB\"],\"action\":\"include\"}}}},\"units\":\"miles\"}\n</code></pre>"},{"location":"api/turn-by-turn/api-reference/#directions-options","title":"Directions options","text":"<p>Directions options should be specified at the top level of the JSON object.</p> Options Description <code>units</code> Distance units for output. Allowable unit types are miles (or mi) and kilometers (or km). If no unit type is specified, the units default to kilometers. <code>language</code> The language of the narration instructions based on the IETF BCP 47 language tag string. If no language is specified or the specified language is unsupported, United States-based English (en-US) is used. Currently supported language list <code>directions_type</code> An enum with 3 values. <ul><li><code>none</code> indicating no maneuvers or instructions should be returned.</li><li><code>maneuvers</code> indicating that only maneuvers be returned.</li><li><code>instructions</code> indicating that maneuvers with instructions should be returned (this is the default if not specified).</li></ul> <code>format</code> Four options are available: <ul><li><code>json</code> is default valhalla routing directions JSON format</li><li><code>gpx</code> returns the route as a GPX (GPS exchange format) XML track</li><li><code>osrm</code> creates a OSRM compatible route directions JSON</li><li><code>pbf</code> formats the result using protocol buffers</li></ul> <code>shape_format</code> If <code>\"format\" : \"osrm\"</code> is set: Specifies the optional format for the path shape of each connection. One of <code>polyline6</code> (default), <code>polyline5</code>, <code>geojson</code> or <code>no_shape</code>. <code>banner_instructions</code> If the format is <code>osrm</code>, this boolean indicates if each step should have the additional <code>bannerInstructions</code> attribute, which can be displayed in some navigation system SDKs. <code>voice_instructions</code> If the format is <code>osrm</code>, this boolean indicates if each step should have the additional <code>voiceInstructions</code> attribute, which can be heard in some navigation system SDKs. <code>alternates</code> A number denoting how many alternate routes should be provided. There may be no alternates or less alternates than the user specifies. Alternates are not yet supported on multipoint routes (that is, routes with more than 2 locations). They are also not supported on time dependent routes. <p>For example a bus request with the result in Spanish using the OSRM (Open Source Routing Machine) format with the additional bannerInstructions and voiceInstructions in the steps would use the following json:</p> <pre><code>{\"locations\":[{\"lat\":40.730930,\"lon\":-73.991379},{\"lat\":40.749706,\"lon\":-73.991562}],\"format\":\"osrm\",\"costing\":\"bus\",\"banner_instructions\":true,\"voice_instructions\":true,\"language\":\"es-ES\"}\n</code></pre>"},{"location":"api/turn-by-turn/api-reference/#supported-language-tags","title":"Supported language tags","text":"Language tag Language alias Description <code>bg-BG</code> <code>bg</code> Bulgarian (Bulgaria) <code>ca-ES</code> <code>ca</code> Catalan (Spain) <code>cs-CZ</code> <code>cs</code> Czech (Czech Republic) <code>da-DK</code> <code>da</code> Danish (Denmark) <code>de-DE</code> <code>de</code> German (Germany) <code>el-GR</code> <code>el</code> Greek (Greece) <code>en-GB</code> English (United Kingdom) <code>en-US-x-pirate</code> <code>en-x-pirate</code> English (United States) Pirate <code>en-US</code> <code>en</code> English (United States) <code>es-ES</code> <code>es</code> Spanish (Spain) <code>et-EE</code> <code>et</code> Estonian (Estonia) <code>fi-FI</code> <code>fi</code> Finnish (Finland) <code>fr-FR</code> <code>fr</code> French (France) <code>hi-IN</code> <code>hi</code> Hindi (India) <code>hu-HU</code> <code>hu</code> Hungarian (Hungary) <code>it-IT</code> <code>it</code> Italian (Italy) <code>ja-JP</code> <code>ja</code> Japanese (Japan) <code>nb-NO</code> <code>nb</code> Bokmal (Norway) <code>nl-NL</code> <code>nl</code> Dutch (Netherlands) <code>pl-PL</code> <code>pl</code> Polish (Poland) <code>pt-BR</code> Portuguese (Brazil) <code>pt-PT</code> <code>pt</code> Portuguese (Portugal) <code>ro-RO</code> <code>ro</code> Romanian (Romania) <code>ru-RU</code> <code>ru</code> Russian (Russia) <code>sk-SK</code> <code>sk</code> Slovak (Slovakia) <code>sl-SI</code> <code>sl</code> Slovenian (Slovenia) <code>sv-SE</code> <code>sv</code> Swedish (Sweden) <code>tr-TR</code> <code>tr</code> Turkish (Turkey) <code>uk-UA</code> <code>uk</code> Ukrainian (Ukraine)"},{"location":"api/turn-by-turn/api-reference/#other-request-options","title":"Other request options","text":"Options Description <code>exclude_locations</code> A set of locations to exclude or avoid within a route can be specified using a JSON array of avoid_locations. The avoid_locations have the same format as the locations list. At a minimum each avoid location must include latitude and longitude. The avoid_locations are mapped to the closest road or roads and these roads are excluded from the route path computation. <code>exclude_polygons</code> One or more exterior rings of polygons in the form of nested JSON arrays, e.g. <code>[[[lon1, lat1], [lon2,lat2]],[[lon1,lat1],[lon2,lat2]]]</code>. Roads intersecting these rings will be avoided during path finding. Alternatively, pass a FeatureCollection of polygon features, where each feature may have a <code>levels</code> property, which must be an array of floats. If present, only edges intersecting the rings that also match one of the passed levels will be excluded (see example request below). If you only need to avoid a few specific roads, it's much more efficient to use <code>exclude_locations</code>. Valhalla will close open rings (i.e. copy the first coordinate to the last position). <code>date_time</code> This is the local date and time at the location.<ul><li><code>type</code><ul><li>0 - Current departure time.</li><li>1 - Specified departure time</li><li>2 - Specified arrival time. Not yet implemented for multimodal costing method.</li><li>3 - Invariant specified time. Time does not vary over the course of the path. Not implemented for multimodal or bike share routing</li></ul></li><li><code>value</code> - the date and time is specified in ISO 8601 format (YYYY-MM-DDThh:mm) in the local time zone of departure or arrival.  For example \"2016-07-03T08:06\"</li></ul> <code>elevation_interval</code> Elevation interval (meters) for requesting elevation along the route. Valhalla data must have been generated with elevation data. If no <code>elevation_interval</code> is specified, no elevation will be returned for the route. An elevation interval of 30 meters is recommended when elevation along the route is desired, matching the default data source's resolution. <code>id</code> Name your route request. If <code>id</code> is specified, the naming will be sent thru to the response. <code>linear_references</code> When present and <code>true</code>, the successful <code>route</code> response will include a key <code>linear_references</code>. Its value is an array of base64-encoded OpenLR location references, one for each graph edge of the road network matched by the input trace. <code>prioritize_bidirectional</code> Prioritize <code>bidirectional a*</code> when <code>date_time.type = depart_at/current</code>. By default <code>time_dependent_forward a*</code> is used in these cases, but <code>bidirectional a*</code> is much faster. Currently it does not update the time (and speeds) when searching for the route path, but the ETA on that route is recalculated based on the time-dependent speeds <code>roundabout_exits</code> A boolean indicating whether exit instructions at roundabouts should be added to the output or not. Default is true. <code>admin_crossings</code> When present and <code>true</code>, the successful route summary will include the two keys <code>admins</code> and <code>admin_crossings</code>. <code>admins</code> is an array of administrative regions the route lies within. <code>admin_crossings</code> is an array of objects that contain <code>from_admin_index</code> and <code>to_admin_index</code>, which are indices into the <code>admins</code> array. They also contain <code>from_shape_index</code> and <code>to_shape_index</code>, which are start and end indices of the edge along which an administrative boundary is crossed. <code>turn_lanes</code> When present and <code>true</code>, each maneuver in the route response can include a <code>lanes</code> array describing lane-level guidance. The lanes array details possible <code>directions</code>, as well as which lanes are <code>valid</code> or <code>active</code> for following the maneuver. <code>linear_cost_factors</code> Customized cost factors that influence path finding, specified as an array of JSON objects. Objects can be either a GeoJSON linestring feature and a <code>\"factor\"</code> property or a plain object with a \"shape\" key, whose value needs to be an encoded polyline (with 6 digit precision), and a \"factor\" key whose value needs to be float. Valhalla will perform an edge walk (see the map matching documentation for more info) to match the geometry onto edges and use those factors in costing. Edges with factors larger than 1 will be increasingly avoided, while edges with factors smaller than 1 increasingly favored. <code>reverse_time_tracking</code> (BETA) Which time tracking strategy to use on the non-time aware expansion in the bidirectional routing algorithm: <code>disabled</code> will assume no time, <code>heuristic</code> will try a best guess based on the bee line distance between origin and destination. Default <code>heuristic</code> <p>For <code>exclude_polygons</code>, a request only excluding intersecting edges on given levels may look like this: </p> <pre><code>{\n  \"exclude_polygons\": {\n    \"type\": \"FeatureCollection\",\n    \"features\": [{\n      \"type\": \"Polygon\", \n      \"geometry\": {\n        \"coordinates\": [[[lon_1, lat_1], ..., [lon_i, lat_i]]]\n      }, \n      \"properties\": {\n        \"levels\": [1.0,2.0,3.0]\n      }\n    }]\n  }\n}\n</code></pre>"},{"location":"api/turn-by-turn/api-reference/#outputs-of-a-route","title":"Outputs of a route","text":"<p>If a route has been named in the request using the optional <code>&amp;id=</code> input, then the name will be returned as a string <code>id</code> on the JSON object.</p> <p>The route results are returned as a <code>trip</code>. This is a JSON object that contains details about the trip, including locations, a summary with basic information about the entire trip, and a list of <code>legs</code>.</p> <p>Basic trip information includes:</p> Trip item Description <code>status</code> Status code. <code>status_message</code> Status message. <code>units</code> The specified units of length are returned, either kilometers or miles. <code>language</code> The language of the narration instructions. If the user specified a language in the directions options and the specified language was supported - this returned value will be equal to the specified value. Otherwise, this value will be the default (en-US) language. <code>locations</code> Location information is returned in the same form as it is entered with additional fields to indicate the side of the street. <code>warnings</code> (optional) This array may contain warning objects informing about deprecated request parameters, clamped values etc. <p>The summary JSON object includes:</p> Summary item Description <code>time</code> Estimated elapsed time to complete the trip. <code>length</code> Distance traveled for the entire trip. Units are either miles or kilometers based on the input units specified. <code>has_toll</code> Flag indicating if the path uses one or more toll segments. <code>has_highway</code> Flag indicating if the path uses one or more highway segments. <code>has_ferry</code> Flag indicating if the path uses one or more ferry segments. <code>min_lat</code> Minimum latitude of a bounding box containing the route. <code>min_lon</code> Minimum longitude of a bounding box containing the route. <code>max_lat</code> Maximum latitude of a bounding box containing the route. <code>max_lon</code> Maximum longitude of a bounding box containing the route. <code>level_changes</code> If a trip leg includes level changes (i.e. when navigating inside a building), the summary will include an array in the form of <code>[[shape_index, level], ...]</code> that can be used to split up the geometry along the level changes."},{"location":"api/turn-by-turn/api-reference/#trip-legs-and-maneuvers","title":"Trip legs and maneuvers","text":"<p>A <code>trip</code> contains one or more <code>legs</code>. For n number of <code>break</code> locations, there are n-1 legs. <code>Through</code> locations do not create separate legs.</p> <p>Each leg of the trip includes a summary, which is comprised of the same information as a trip summary but applied to the single leg of the trip. It also includes a <code>shape</code>, which is an encoded polyline of the route path (with 6 digits decimal precision), and a list of <code>maneuvers</code> as a JSON array. For more about decoding route shapes, see these code examples.</p> <p>If <code>elevation_interval</code> is specified, each leg of the trip will return <code>elevation</code> along the route as a JSON array. The <code>elevation_interval</code> is also returned. Units for both <code>elevation</code> and <code>elevation_interval</code> are either meters or feet based on the input units specified.</p> <p>Each maneuver includes:</p> Maneuver item Description <code>type</code> Type of maneuver. See below for a list. <code>instruction</code> Written maneuver instruction. Describes the maneuver, such as \"Turn right onto Main Street\". <code>verbal_transition_alert_instruction</code> Text suitable for use as a verbal alert in a navigation application. The transition alert instruction will prepare the user for the forthcoming transition. For example: \"Turn right onto North Prince Street\". <code>verbal_pre_transition_instruction</code> Text suitable for use as a verbal message immediately prior to the maneuver transition. For example \"Turn right onto North Prince Street, U.S. 2 22\". <code>verbal_post_transition_instruction</code> Text suitable for use as a verbal message immediately after the maneuver transition. For example \"Continue on U.S. 2 22 for 3.9 miles\". <code>street_names</code> List of street names that are consistent along the entire nonobvious maneuver. <code>begin_street_names</code> When present, these are the street names at the beginning (transition point) of the nonobvious maneuver (if they are different than the names that are consistent along the entire nonobvious maneuver). <code>time</code> Estimated time along the maneuver in seconds. <code>length</code> Maneuver length in the units specified. <code>begin_shape_index</code> Index into the list of shape points for the start of the maneuver. <code>end_shape_index</code> Index into the list of shape points for the end of the maneuver. <code>toll</code> True if the maneuver has any toll, or portions of the maneuver are subject to a toll. <code>highway</code> True if a highway is encountered on this maneuver. <code>rough</code> True if the maneuver is unpaved or rough pavement, or has any portions that have rough pavement. <code>gate</code> True if a gate is encountered on this maneuver. <code>ferry</code> True if a ferry is encountered on this maneuver. <code>sign</code> Contains the interchange guide information at a road junction associated with this maneuver. See below for details. <code>roundabout_exit_count</code> The spoke to exit roundabout after entering. <code>depart_instruction</code> Written depart time instruction. Typically used with a transit maneuver, such as \"Depart: 8:04 AM from 8 St - NYU\". <code>verbal_depart_instruction</code> Text suitable for use as a verbal depart time instruction. Typically used with a transit maneuver, such as \"Depart at 8:04 AM from 8 St - NYU\". <code>arrive_instruction</code> Written arrive time instruction. Typically used with a transit maneuver, such as \"Arrive: 8:10 AM at 34 St - Herald Sq\". <code>verbal_arrive_instruction</code> Text suitable for use as a verbal arrive time instruction. Typically used with a transit maneuver, such as \"Arrive at 8:10 AM at 34 St - Herald Sq\". <code>transit_info</code> Contains the attributes that describe a specific transit route. See below for details. <code>verbal_multi_cue</code> True if the <code>verbal_pre_transition_instruction</code> has been appended with the verbal instruction of the next maneuver. <code>travel_mode</code> Travel mode.<ul><li>\"drive\"</li><li>\"pedestrian\"</li><li>\"bicycle\"</li><li>\"transit\"</li></ul> <code>travel_type</code> Travel type for drive.<ul><li>\"car\"</li><li>\"motorcycle\"</li><li>\"motor_scooter\"</li><li>\"truck\"</li><li>\"bus\"</li></ul>Travel type for pedestrian.<ul><li>\"foot\"</li><li>\"wheelchair\"</li></ul>Travel type for bicycle.<ul><li>\"road\"</li><li>\"hybrid\"</li><li>\"cross\"</li><li>\"mountain\"</li></ul>Travel type for transit.<ul><li>Tram or light rail = \"tram\"</li><li>Metro or subway = \"metro\"</li><li>Rail = \"rail\"</li><li>Bus = \"bus\"</li><li>Ferry = \"ferry\"</li><li>Cable car = \"cable_car\"</li><li>Gondola = \"gondola\"</li><li>Funicular = \"funicular\"</li></ul> <code>bss_maneuver_type</code> Used when <code>travel_mode</code> is <code>bikeshare</code>. Describes bike share maneuver. The default value is \"NoneAction <ul><li>\"NoneAction\"</li><li>\"RentBikeAtBikeShare\"</li><li>\"ReturnBikeAtBikeShare\"</li></ul> <code>bearing_before</code> The clockwise angle from true north to the direction of travel immediately before the maneuver. <code>bearing_after</code> The clockwise angle from true north to the direction of travel immediately after the maneuver. <code>lanes</code> An array describing lane-level guidance. Used when <code>turn_lanes</code> is enabled. See below for details. <p>For the maneuver <code>type</code>, the following are available:</p> <pre><code>kNone = 0;\nkStart = 1;\nkStartRight = 2;\nkStartLeft = 3;\nkDestination = 4;\nkDestinationRight = 5;\nkDestinationLeft = 6;\nkBecomes = 7;\nkContinue = 8;\nkSlightRight = 9;\nkRight = 10;\nkSharpRight = 11;\nkUturnRight = 12;\nkUturnLeft = 13;\nkSharpLeft = 14;\nkLeft = 15;\nkSlightLeft = 16;\nkRampStraight = 17;\nkRampRight = 18;\nkRampLeft = 19;\nkExitRight = 20;\nkExitLeft = 21;\nkStayStraight = 22;\nkStayRight = 23;\nkStayLeft = 24;\nkMerge = 25;\nkRoundaboutEnter = 26;\nkRoundaboutExit = 27;\nkFerryEnter = 28;\nkFerryExit = 29;\nkTransit = 30;\nkTransitTransfer = 31;\nkTransitRemainOn = 32;\nkTransitConnectionStart = 33;\nkTransitConnectionTransfer = 34;\nkTransitConnectionDestination = 35;\nkPostTransitConnectionDestination = 36;\nkMergeRight = 37;\nkMergeLeft = 38;\nkElevatorEnter = 39;\nkStepsEnter = 40;\nkEscalatorEnter = 41;\nkBuildingEnter = 42;\nkBuildingExit = 43;\n</code></pre> <p>The maneuver <code>sign</code> may contain four lists of interchange sign elements as follows:</p> <ul> <li><code>exit_number_elements</code> = list of exit number elements. If an exit number element exists, it is typically just one value.</li> <li><code>exit_branch_elements</code> = list of exit branch elements. The exit branch element text is the subsequent road name or route number after the sign.</li> <li><code>exit_toward_elements</code> = list of exit toward elements. The exit toward element text is the location where the road ahead goes - the location is typically a control city, but may also be a future road name or route number.</li> <li><code>exit_name_elements</code> = list of exit name elements. The exit name element is the interchange identifier - typically not used in the US.</li> </ul> <p>Each maneuver sign element includes:</p> Maneuver sign element item Description <code>text</code> Interchange sign text. <ul><li>exit number example: 91B.</li><li>exit branch example: I 95 North.</li><li>exit toward example: New York.</li><li>exit name example: Gettysburg Pike.</li><ul> <code>consecutive_count</code> The frequency of this sign element within a set a consecutive signs. This item is optional. <p>A maneuver <code>transit_info</code> includes:</p> Maneuver transit route item Description <code>onestop_id</code> Global transit route identifier. <code>short_name</code> Short name describing the transit route. For example \"N\". <code>long_name</code> Long name describing the transit route. For example \"Broadway Express\". <code>headsign</code> The sign on a public transport vehicle that identifies the route destination to passengers. For example \"ASTORIA - DITMARS BLVD\". <code>color</code> The numeric color value associated with a transit route. The value for yellow would be \"16567306\". <code>text_color</code> The numeric text color value associated with a transit route. The value for black would be \"0\". <code>description</code> The description of the transit route. For example \"Trains operate from Ditmars Boulevard, Queens, to Stillwell Avenue, Brooklyn, at all times. N trains in Manhattan operate along Broadway and across the Manhattan Bridge to and from Brooklyn. Trains in Brooklyn operate along 4<sup>th</sup> Avenue, then through Borough Park to Gravesend. Trains typically operate local in Queens, and either express or local in Manhattan and Brooklyn, depending on the time. Late night trains operate via Whitehall Street, Manhattan. Late night service is local\". <code>operator_onestop_id</code> Global operator/agency identifier. <code>operator_name</code> Operator/agency name. For example, \"BART\", \"King County Marine Division\", and so on.  Short name is used over long name. <code>operator_url</code> Operator/agency URL. For example, \"https://web.mta.info/\". <code>transit_stops</code> A list of the stops/stations associated with a specific transit route. See below for details. <p>A <code>transit_stop</code> includes:</p> Transit stop item Description <code>type</code> Type of stop (simple stop=0; station=1). <code>name</code> Name of the stop or station. For example \"14 St - Union Sq\". <code>arrival_date_time</code> Arrival date and time using the ISO 8601 format (YYYY-MM-DDThh:mm). For example, \"2015-12-29T08:06\". <code>departure_date_time</code> Departure date and time using the ISO 8601 format (YYYY-MM-DDThh:mm). For example, \"2015-12-29T08:06\". <code>is_parent_stop</code> True if this stop is a marked as a parent stop. <code>assumed_schedule</code> True if the times are based on an assumed schedule because the actual schedule is not known. <code>lat</code> Latitude of the transit stop in degrees. <code>lon</code> Longitude of the transit stop in degrees. <p>Continuing with the earlier routing example from the Detroit, Michigan area, a maneuver such as this one may be returned with that request: <code>{\"begin_shape_index\":0,\"length\":0.109,\"end_shape_index\":1,\"instruction\":\"Go south on Appleton.\",\"street_names\":[\"Appleton\"],\"type\":1,\"time\":0}</code></p> <p>A <code>lanes</code> includes:</p> <p>When <code>turn_lanes</code> is enabled, each maneuver may include a <code>lanes</code> array describing lane-level guidance. Each lane object can include the following fields:</p> Field Description <code>directions</code> A bitmask indicating all possible turn directions for that lane. <code>valid</code> (Optional) A bitmask indicating valid turn directions for following the route initially. A lane is marked valid if it can be used at the start of the maneuver but might require further lane changes. <code>active</code> (Optional) A bitmask indicating active turn directions for continuing along the route without needing additional lane changes. A lane is marked active if it is the best lane for following the maneuver as intended. <p>The directions, valid, and active fields use the following bitmask values:</p> Decimal Value Name Description 0 Empty No turn lane or undefined 1 None No specific direction 2 Through Goes straight 4 SharpLeft Turns sharply to the left 8 Left Turns left 16 SlightLeft Turns slightly to the left 32 SlightRight Turns slightly to the right 64 Right Turns right 128 SharpRight Turns sharply to the right 256 Reverse U-turn 512 MergeToLeft Lane merges to the left 1024 MergeToRight Lane merges to the right <p>Example of a lanes array with two lanes: the first lane can only turn left and is marked as the preferred (active) lane for left turns. The second lane allows going left or straight, but it is marked as valid only for left turns in this maneuver context:</p> <pre><code>\"lanes\": [\n  {\n    \"directions\": 8,   // bitmask for Left (8)\n    \"active\": 8        // indicates this lane should be preferred for a left turn\n  },\n  {\n    \"directions\": 10,  // bitmask for Left (8) + Straight (2)\n    \"valid\": 8         // indicates this lane can be used for a left turn\n  }\n]\n</code></pre> <p>In the future, look for additional maneuver information to enhance navigation applications, including landmark usage.</p>"},{"location":"api/turn-by-turn/api-reference/#http-status-codes-and-conditions","title":"HTTP status codes and conditions","text":"<p>The following is a table of HTTP status error code conditions that may occur for a particular request. In general, the service follows the HTTP specification. That is to say that <code>5xx</code> returns are generally ephemeral server problems that should be resolved shortly or are the result of a bug. <code>4xx</code> returns are used to mark requests that cannot be carried out, generally due to bad input in the request or problems with the underlying data. A <code>2xx</code> return is expected when there is a successful route result or <code>trip</code>, as described above.</p> Status Code Status Description 200 your_trip_json A happy bit of json describing your <code>trip</code> result 400 Failed to parse json request You need a valid json request 400 Failed to parse location You need a valid location object in your json request 400 Failed to parse correlated location There was a problem with the location once correlated to the route network 400 Insufficiently specified required parameter 'locations' You forgot the locations parameter 400 No edge/node costing provided You forgot the costing parameter 400 Insufficient number of locations provided You didn't provide enough locations 400 Exceeded max route locations of X You are asking for too many locations 400 Locations are in unconnected regions. Go check/edit the map at osm.org You are routing between regions of no connectivity 400 No costing method found for 'X' You are asking for a non-existent costing mode 400 Path distance exceeds the max distance limit You want to travel further than this mode allows 400 No suitable edges near location There were no edges applicable to your mode of travel near the input location 400 No data found for location There was no route data tile at the input location 400 No path could be found for input There was no path found between the input locations 404 Try any of: '/route' '/locate' You asked for an invalid path 405 Try a POST or GET request instead We only support GET and POST requests 500 Failed to parse intermediate request format Had a problem reading an intermediate request format 500 Failed to parse TripPath Had a problem reading the computed path from Protobuf 500 Could not build directions for TripPath Had a problem using the trip path to create TripDirections 500 Failed to parse TripDirections Had a problem using the trip directions to serialize a json response 501 Not implemented Not Implemented"},{"location":"api/turn-by-turn/api-reference/#internal-error-codes-and-conditions","title":"Internal error codes and conditions","text":"<p>The following is a table of exception internal error code conditions that may occur for a particular request. An error code utility header file can be included by any of the Valhalla service projects.</p> <p>The codes correspond to code returned from a particular Valhalla project.</p> Error code Error 1xx Loki project codes 100 Failed to parse json request 101 Try a POST or GET request instead 102 The config actions for Loki are incorrectly loaded 103 Missing max_locations configuration 104 Missing max_distance configuration 105 Path action not supported 106 Try any of 107 Not Implemented 110 Insufficiently specified required parameter 'locations' 111 Insufficiently specified required parameter 'time' 112 Insufficiently specified required parameter 'locations' or 'sources &amp; targets' 113 Insufficiently specified required parameter 'contours' 114 Insufficiently specified required parameter 'shape' or 'encoded_polyline' 120 Insufficient number of locations provided 121 Insufficient number of sources provided 122 Insufficient number of targets provided 123 Insufficient shape provided 124 No edge/node costing provided 125 No costing method found 126 No shape provided 130 Failed to parse location 131 Failed to parse source 132 Failed to parse target 140 Action does not support multimodal costing 141 Arrive by for multimodal not implemented yet 142 Arrive by not implemented for isochrones 143 ignore_closure in costing and exclude_closure in search_filter cannot both be specified 150 Exceeded max locations 151 Exceeded max time 152 Exceeded max contours 153 Too many shape points 154 Path distance exceeds the max distance limit 155 Outside the valid walking distance at the beginning or end of a multimodal route 156 Outside the valid walking distance between stops of a multimodal route 157 Exceeded max avoid locations 158 Input trace option is out of bounds 160 Date and time required for origin for date_type of depart at 161 Date and time required for destination for date_type of arrive by 162 Date and time is invalid.  Format is YYYY-MM-DDTHH:MM 163 Invalid date_type 170 Locations are in unconnected regions. Go check/edit the map at osm.org 171 No suitable edges near location 199 Unknown 2xx Odin project codes 200 Failed to parse intermediate request format 201 Failed to parse TripPath 210 Trip path does not have any nodes 211 Trip path has only one node 212 Trip must have at least 2 locations 213 Error - No shape or invalid node count 220 Turn degree out of range for cardinal direction 230 Invalid TripDirections_Maneuver_Type in method FormTurnInstruction 231 Invalid TripDirections_Maneuver_Type in method FormRelativeTwoDirection 232 Invalid TripDirections_Maneuver_Type in method FormRelativeThreeDirection 299 Unknown 3xx Skadi project codes 300 Failed to parse json request 301 Try a POST or GET request instead 302 The config actions for Skadi are incorrectly loaded 303 Path action not supported 304 Try any of 305 Not Implemented 310 No shape provided 311 Insufficient shape provided 312 Insufficiently specified required parameter 'shape' or 'encoded_polyline' 313 'resample_distance' must be &gt;= 314 Too many shape points 399 Unknown 4xx Thor project codes 400 Unknown action 401 Failed to parse intermediate request format 410 Insufficiently specified required parameter 'locations' 411 Insufficiently specified required parameter 'shape' 412 No costing method found 420 Failed to parse correlated location 421 Failed to parse location 422 Failed to parse source 423 Failed to parse target 424 Failed to parse shape 430 Exceeded max iterations in CostMatrix::SourceToTarget 440 Cannot reach destination - too far from a transit stop 441 Location is unreachable 442 No path could be found for input 443 Exact route match algorithm failed to find path 444 Map Match algorithm failed to find path 445 Shape match algorithm specification in api request is incorrect. Please see documentation for valid shape_match input. 499 Unknown 5xx Tyr project codes 500 Failed to parse intermediate request format 501 Failed to parse TripDirections 504 GeoTIFF serialization not supported by service 599 Unknown"},{"location":"api/turn-by-turn/overview/","title":"Routing overview","text":"<p>The Valhalla route service (a.k.a. turn-by-turn) is an open-source routing service that lets you integrate routing and navigation into a web or mobile application. The service works globally, and provides dynamic and customizable routing by driving, walking, bicycling, and using multimodal and transit options, with clear directions for maneuvers along the route.</p>"},{"location":"api/turn-by-turn/overview/#route-requests-and-results","title":"Route requests and results","text":"<p>When you request a route, you are sending and receiving JSON, which is a human-readable text format. In the JSON array, you need to specify the locations to visit on the route, the costing model that represents the mode of travel, such as car or bicycle, and your API key. The location coordinates, given in decimal degrees, can come from many input sources, such as a GPS location, a point or a click on a map, a geocoding service such as Mapbox Geocoding, and so on. Costing methods can have several options that can be adjusted to develop the route path and estimate the time along the path.</p> <p>The service route results provide details about the trip, including locations, a summary with basic information about the entire trip and a list of legs. Each leg has its own summary, a shape, which is an encoded polyline of the route path, and a list of maneuvers. These maneuvers provide written narrative instructions, plus verbal alerts that can be used as audio guidance in navigation apps.</p> <p>The JSON returned from the route query can be drawn on a map and shown as instructions for maneuvers along the route. You can display Valhalla routes on web and mobile maps, e.g. https://valhalla.openstreetmap.de.</p>"},{"location":"api/turn-by-turn/overview/#data-sources-in-turn-by-turn","title":"Data sources in Turn-by-Turn","text":"<p>Valhalla draws data from OpenStreetMap for the major part of the routing graph and can optionally include elevation data from the TileZen project hosted on the AWS Open Data platform, user-provided GTFS feeds, reproducible timezone data, custom historical traffic data, live traffic and incident feeds.</p> <p>The source code is open to view and modify, and contributions are welcomed.</p>"},{"location":"meili/algorithms/","title":"Map Matching in a Programmer's Perspective","text":"<p>Meili uses a Hidden Markov Model (HMM) approach, proposed by Paul Newson and John Krumm in 2009, to solve the map matching problem. The map-matching problem is modelled as follows: given a sequence of GPS measurements (observations in terms of HMM), each measurement has to match one of a set of potential candidate road segments (hidden states in terms of HMM), the problem is to find the most likely sequence of candidates.</p> <p></p> <p>In this figure we see a noisy GPS sequence of 4 measurements, from green to red. Each measurement could match one of its candidates nearby (the small markers in cyan) but which is the most likely one? The answer is <code>0, 4, 9, 11</code> respectively. That is our most likely sequence of candidates, which constructs the red matched route.</p> <p>A good explanation about the modelling can be found here and here.</p> <p>The problem can be formulated as a graph search problem that is familiar to programmers. Here we briefly introduce the problem formulation and then introduce several solutions, followed by improvements and experiments.</p>"},{"location":"meili/algorithms/#graphical-model","title":"Graphical Model","text":"<p>Put the example above in a graphical model, it looks like this:</p> <p></p> <p>It is a Directed Acyclic Graph (DAG).</p> <p>Each measurement has a column of nodes associated. A node (a hidden state in terms of HMM) in the graph represents a candidate, namely a tuple <code>(road segment, offset)</code> that tells a location on a road segment on the map. An edge <code>(u, v)</code> means that node <code>u</code> is able to affect the decision about <code>v</code>. Take the edge <code>(node 9, node 12)</code> as an example: since it takes a much longer way than it looks from node 9 to node 12, node 12 is therefore unlikely to be the match to the last measurement. As you can see in the graph a measurement can be affected only by its previous measurement.</p> <p>Two probability models are used together to quantify how likely a measurement would be to match a node. The emission probability tells that closer a node stays to its measurement more likely the measurement is to match it, while the transition probability tells that closer the walk distance from <code>u</code> to <code>v</code> is to the measurement distance, the more likely <code>v</code>'s measurement is to match it.</p> <pre><code># A gaussian distribution\ndef emission_prob(u):\n    c = 1 / (SIGMA_Z * math.sqrt(2 * math.pi))\n    return c * math.exp(-great_circle_distance(u.measurement, u)**2)\n\n# A empirical distribution\ndef transition_prob(u, v):\n    c = 1 / BETA\n    # Calculating route distance is expensive.\n    # We will discuss how to reduce the number of calls to this function later.\n    delta = math.abs(route_distance(u, v) - great_circle_distance(u.measurement, v.measurement))\n    return c * math.exp(-delta)\n</code></pre> <p>A path is a list of edges. The probability of a path is defined as follows:</p> <pre><code>def path_prob(path):\n    assert path\n    u, v = path[0]\n    joint_prob = emission_prob(u)\n    for u, v in path:\n        joint_prob *= transition_prob(u, v) * emission_prob(v)\n    return joint_prob\n</code></pre> <p>The task is to find the most likely sequence over all possible sequences. For convenience's sake, we added two virtual nodes, the source node <code>s</code> and the target node <code>t</code>, and corresponding virtual edges to the graph with all emission and transition probabilities to be 1.0. The task hence becomes: find a path from <code>s</code> to <code>t</code> that maximizes the path probability.</p>"},{"location":"meili/algorithms/#solutions","title":"Solutions","text":"<p>To make the problem clear, a brute-force solution is given first. Given a graph represented by a Adjacency List, a source node and a target node, the procedure <code>maximum_path_prob</code> tries hard to list all paths in between and then selects the optimal one among them.</p> <pre><code>def maximum_path_prob(adjacency_list, s, t):\n    return max((path_prob(path), path)\n        for path in all_paths(adjacency_list, s, t),\n        key=lambda prob, path: prob)\n\n# Generate all paths from s to t recursively\ndef all_paths(adjacency_list, s, t):\n    if s == t: return [[]]\n    paths = []\n    for v in adjacency_list[s]:\n        for path in all_paths(adjacency_list, v, t):\n            paths.append([(s, v)] + path)\n    return paths\n</code></pre> <p>Viterbi Algorithm is usually used to find the most likely sequence in HMM. In the DAG the Viterbi Algorithm works like Breath-First-Search (BFS) algorithm that searches the target level by level. During the search/expansion, the Viterbi Algorithm also remembers each node's optimal solution (the optimal path from the source and the path probability) and use them to find optimal solutions for next level.</p> <pre><code>def viterbi_search(adjacency_list, s, t):\n    # Initialize joint probability for each node\n    joint_prob = {}\n    for u in adjacency_list:\n        joint_prob[u] = 0\n    predecessor = {}\n    queue = FIFOQueue()\n\n    queue.push(s)\n    joint_prob[s] = emission_prob(s)\n    predecessor[s] = None\n    while not queue.empty():\n        # Extract node u\n        u = queue.pop()\n        # Guarantee the optimal solution to u is found\n        assert joint_prob[u] == maximum_path_prob(adjacency_list, s, u)[0]\n        if u == t: break\n        for v in adjacency_list[u]:\n            # Relaxation\n            new_prob = joint_prob[u] * transition_prob(u, v) * emission_prob(v)\n            if joint_prob[v] &lt; new_prob:\n                joint_prob[v] = new_prob\n                predecessor[v] = u\n            if v not in queue:\n                queue.push(v)\n\n    return joint_prob[t], construct_path(predecessor, s, t)\n</code></pre> <p>The Viterbi Algorithm is the one used in the paper to find the optimal path, while another approach is to use Topological Sort in the DAG. Both algorithms have to explore all edges to find the path. However in the map-matching model exploring an edge is expensive. During the exploration of an edge <code>(u, v)</code>, it needs to find the shortest path between <code>u</code> and <code>v</code> in the road network for calculating its transition probability. Suppose that, given a sequence of <code>S</code> measurements and each measurement has average <code>T</code> states, the Viterbi Algorithm or the topological sort approach will traverse all edges i.e. do <code>S * T * T</code> times of shortest path calculations. This is not good, especially in dense urban areas where you can easily get a large average <code>T</code>.</p> <p>To reduce the number of transition probability calculations, we use the Dijkstra's algorithm to avoid extracting those unlikely nodes as many as possible. Like the Viterbi Algorithm, the Dijkstra's algorithm solves the problem in a Dynamic Programming approach. The advantage of the Dijkstra's algorithm is that it extracts nodes in a greedy way, i.e. extracts the most likely node every time. With this strategy, as soon as the target is extracted, the optimal solution is guaranteed to be found and thus the rest of nodes can be safely thrown away.</p> <p>Before applying the Dijkstra's algorithm we should notice that our objective is to find the most likely path, whereas the Dijkstra's algorithm is designed to solve shortest path problem, i.e. minimizing a certain objective. Therefore we need to transform the maximization problem to a minimization problem in the following way:</p> <p>With following prerequisites: <pre><code>T = transition_prob\nE = emission_prob\nlg = math.log10\nassert 0 &lt;= E(u) &lt;= 1.0 and 0 &lt;= T(u, v) &lt;= 1.0\n</code></pre></p> <p>We are maximizing <code>path_prob(path)</code> among a set of paths. Expanding <code>path_prob(path)</code> we get:</p> <pre><code># For simplicity we ignored the last node\nproduct(E(u) * T(u, v) for u,v in path)\n</code></pre> <p>which is equivalent to maximizing:</p> <pre><code>lg(product(E(u) * T(u, v) for u,v in path))\n# equivalent to\nsum(lg(E(u)) + lg(T(u, v)) for u,v in path)\n# because lg(a * b) == lg(a) + lg(b)\n</code></pre> <p>which is equivalent to minimizing:</p> <pre><code>-sum(lg(E(u)) + lg(T(u, v)) for u,v in path)\n# equivalent to\nsum(-lg(E(u)) + -lg(T(u, v)) for u,v in path)\n\n# Must be non-negative\nassert 0 &lt;= -lg(E(u)) and 0 &lt;= -lg(T(u, v))\n</code></pre> <p>After the transformation, the emission probability of a node turns to the node cost, and the transition probability of an edge turns to the edge cost.</p> <pre><code>def node_cost(u):\n    return -1 * math.log10(emission_prob(u))\n\ndef edge_cost(u, v):\n    return -1 * math.log10(transition_prob(u, v))\n</code></pre> <p>The problem becomes find a path from <code>s</code> to <code>t</code> that minimizes <code>sum(node_cost(u) + edge_cost(u, v) for u, v in path)</code> which can be efficiently solved by the Dijkstra's algorithm. Thanks to the similarity to the Viterbi Algorithm, changing the FIFO queue in the <code>viterbi_search</code> procedure to a priority queue, and the probability calculation to the cost calculation should get you a rough Dijkstra based solution, a greedy, lazy but faster version of the Viterbi Algorithm.</p>"},{"location":"meili/algorithms/#todo-experiments","title":"<code>TODO</code> Experiments","text":"<p><code>TODO</code> comparison between the original Viterbi Algorithm and the Dijkstra Viterbi Algorithm, and comparisons with and without tweaks.</p>"},{"location":"meili/configuration/","title":"Configuration","text":"<p>To launch a Meili service or instantiate a <code>MapMatcherFactor</code>, you need to pass it the Valhalla configuration file, which holds all configurations for Meili at the node <code>meili</code>.</p>"},{"location":"meili/configuration/#map-matching-parameters","title":"Map Matching Parameters","text":"<p>The map matching parameters control accuracy and performance of the map matching process. All transport mode nodes (<code>auto</code>, <code>pedestrian</code>, <code>bicycle</code>, <code>multimodal</code>) can hold its own settings of these parameters, otherwise the setting in <code>default</code> node will be used.</p> <p>All transport modes can specify following parameters:</p> Parameters Description Default <code>sigma_ z</code> A non-negative value to specify the GPS accuracy (the variance of the normal distribution) of an incoming GPS sequence. It is also used to weight emission costs of measurements. 4.07 <code>beta</code> A non-negative emprical value to weight the transition cost of two successive candidates. 3 <code>max_route_distance_factor</code> A non-negative value used to limit the routing search range which is the distance to next measurement multiplied by this factor. 5 <code>max_route_time_factor</code> A non-negative value used to limit the routing search range which is the time to next measurement multiplied by this factor. 5 <code>breakage_distance</code> A non-negative value. If two successive measurements are far than this distance, then connectivity in between will not be considered. 2000 (meters) <code>interpolation_distance</code> If two successive measurements are closer than this distance, then the later one will be interpolated into the matched route. 10 (meters) <code>search_radius</code> A non-negative value to specify the search radius (in meters) within which to search road candidates for each measurement. 50 (meters) <code>max_search_radius</code> Specify the upper bound of <code>search_radius</code> 100 (meters) <code>turn_penalty_factor</code> A non-negative value to penalize turns from one road segment to next. 0 (meters)"},{"location":"meili/configuration/#service-parameters","title":"Service Parameters","text":"<p>The service parameters below are only used in the Meili service:</p> Parameters Description Default <code>mode</code> Specify the default transport mode. <code>multimodal</code> <code>customizable</code> Specify which parameters are allowed to be customized by URL query parameters. <code>[\"mode\", \"search_radius\"]</code> <code>verbose</code> Control verbose output for debugging. <code>false</code>"},{"location":"meili/implementation_details/","title":"Implementation Details","text":""},{"location":"meili/implementation_details/#overview","title":"Overview","text":"<pre><code>                  Measurements\n\n                    /  |  \\\n                   |   |   |\n                   V   V   V\n  +-------------------------------------------------------+\n  |                                                       |\n  |            [ Candidate Query ]                        |\n  |                                                       |\n  |               /    |    \\                             |\n  |  Candidate   |     |     |  Candidate                 | &lt;-- Map Matcher\n  |  cluster     V     V     V  cluster                   |\n  |                                                       |\n  |            [  Map Matching  ] &lt;--- [ Viterbi Search ] |\n  |                                \\__ [ Routing ]        |\n  |              /     |      \\                           |\n  +-------------|------|-------|--------------------------+\n                V      V       V\n\n                 Match  Results\n</code></pre>"},{"location":"meili/implementation_details/#candidate-query","title":"Candidate Query","text":"<p><code>valhalla/meili/candidate_query.h</code></p> <p>Given a position and a radius, this component finds all underlying road segments lying within this radius around the position. For every incoming measurement we need to perform such a query to find a cluster of candidates around it, which will be used as input to the map matching component.</p> <p>The spatial query algorithm used in Meili is simple and efficient. Before the query, we spatially divide a road network (i.e. a graph tile) into a grid of 500x500 (<code>grid.size</code>) squares. Then we precompute which road segments each square intersects, and add them to the square. The query is simply to retrieve all road segments from the squares that the radius range covers. See [this slide] (https://www.cs.princeton.edu/courses/archive/fall05/cos226/lectures/geosearch.pdf) at page 7 for details.</p>"},{"location":"meili/implementation_details/#map-matching","title":"Map Matching","text":"<p><code>valhalla/meili/map_matching.h</code></p> <p>The <code>MapMatching</code> class is the core component that implements the HMM-based map matching algorithm. It takes a sequence of candidate clusters as input, and picks one candidate from each cluster to form the most likely sequence of candidates (Viterbi path). It delegates the actual search task to the Viterbi Search module, but it defines how to quantify the likelihood. Concretely speaking it inherits from the <code>ViterbiSearch</code> class and implements its virtual costing functions namely <code>ViterbiSearch::TransitionCost</code> and <code>ViterbiSearch::EmissionCost</code>.</p>"},{"location":"meili/implementation_details/#state","title":"State","text":"<p><code>valhalla/meili/map_matching.h</code></p> <p>When feeding a cluster of candidates into the component, an unique ID and an identical time will be attached to each candidate. The ID identifies a state, whereas the time tells from which cluster a candidate comes. Internally we name the wrapped candidate as a state.</p>"},{"location":"meili/implementation_details/#viterbi-search","title":"Viterbi Search","text":"<p><code>valhalla/meili/viterbi_search.h</code></p> <p>This module focus on finding the most likely sequence (Viterbi path) in a trellis graph in context of HMM model. It provides an uniform interface <code>IViterbiSearch</code> and two implementations: <code>NaiveViterbiSearch</code> implements the naive Viterbi Algorithm and <code>ViterbiSearch</code> implements the lazy Dijkstra-based Viterbi Algorithm. Both implementations are able to find the optimal path. <code>NaiveViterbiSearch</code> is able to work with both maximum and minimum objectives, whereas <code>ViterbiSearch</code> only works with minimum objectives as it's Dijkstra-based.</p> <p>We derive <code>MapMatching</code> from <code>ViterbiSearch</code> for it has better performance in theory. You can develop your own map matching algorithm to work with other road network sources (e.g. pgRouting) as <code>MapMatching</code> does: inherit from either implementation (depending on your objectives) and implement <code>IViterbiSearch::TransitionCost</code> and <code>IViterbiSearch::EmissionCost</code>.</p> <p>The details about these algorithms are described here.</p>"},{"location":"meili/implementation_details/#routing","title":"Routing","text":"<p><code>valhalla/meili/routing.h</code></p> <p>This module focuses on finding the shortest path (SP) between two candidates in the road network. The path distance is required in the transition cost calculation (<code>MapMatching::TransitionCost</code>). The path will be the inferred path between their respective measurements if both candidates are picked as part of the most likely sequence.</p> <p>The SP algorithm is based on AStar, and it routes from single origin to multiple destinations. AStar fits here because the destination set is a cluster of candidates around their measurement (provided by the candidate query above). So the algorithm can estimate the heuristic cost by targeting at the measurement's position.</p> <p>The SP algorithm doesn't construct the paths for you. Instead it gives back the search tree (i.e. <code>LabelSet</code>) directly. Then we store the search tree in the origin state for path construction later.</p> <p>Turn cost between road segments along the path is aggregated during the path finding. This cost contributes as an independent part of the transition cost (<code>MapMatching::TransitionCost</code>) to penalize paths with turns.</p> <p>Unlike path algorithms in Thor, the SP algorithm scans nodes instead of edges, so turn restriction is not considered here.</p>"},{"location":"meili/implementation_details/#viterbi-search-vs-routing","title":"Viterbi Search VS. Routing","text":"<p>It is worth mentioning that they share some similarities but also some differences. Both are finding optimal paths but different objectives (most likely sequence vs. shortest distance path). Both are based on the Dijkstra algorithm (thank you Dijkstra!) but different graphical models (trellis graph vs. road network).</p>"},{"location":"meili/implementation_details/#map-matcher","title":"Map Matcher","text":"<p><code>valhalla/meili/map_matcher.h</code></p> <p>A map matcher is a facade component that connects the candidate query component and map matching component, and provides simple interfaces for use. As shown in the overview, you can think of it as a black box that takes measurements as input and gives back match results. In addition, it does some internal filtering work before measurements feeding into the map matching component.</p>"},{"location":"meili/implementation_details/#interpolation","title":"Interpolation","text":"<p><code>valhalla/meili/map_matcher.h</code></p> <p>One thing, which is not shown in the overview, is that not all incoming measurements are sent to the map matching component. If some successive measurements are too spatially close to each other, then only the first measurement will be sent; the rest of measurements will be interpolated into the match route.</p> <p>For example, assume the numbers below represent a sequence of measurements (in order by numbers) along a straight road, and each space is one meter long. If the <code>interpolation_distance</code> is set to 10 meters, we will only send measurements <code>1*</code>, <code>4*</code> and <code>7*</code> because they are farther apart than 10 meters; measurements <code>2</code> and <code>3</code> will be interpolated into the route from <code>1*</code> to <code>4*</code>; measurement <code>5</code> will be interpolated into the route from <code>4*</code> to <code>7*</code>, and so on.</p> <pre><code>1* 2  3                    4*  5                  8 7* 9 10\n</code></pre> <p>The first rationale of this design is that for high-density traces it can reduce the number of measurements involved in map matching. Secondly if two successive measurements are too close, the later one is possible to be found at the upstream of the earlier one due to noise error. This error can result in wrong path inference in some modes such as <code>auto</code>, <code>bicycle</code> where U-turns are forbidden. For example, the true location of <code>8</code> should be at the downstream (right side) of <code>7*</code>, but the noise can shift it to upstream (left side). In <code>auto</code> mode, this slight shift can result in either wrong path or no path found from <code>7*</code> to <code>8</code>. If we interpolate measurement <code>8</code> instead of map matching it, this issue can be avoided.</p>"},{"location":"meili/implementation_details/#match-result","title":"Match Result","text":"<p><code>valhalla/meili/match_result.h</code></p> <p>Each measurement corresponds to a match result. The match result tells you on which road segment the measurement gets matched or interpolated, the match position, and the distance to the position, etc. The corresponding state ID is attached to the result if the measurement gets matched. Since we have stored route search trees to states, you can find the state with this ID and reconstruct the route with the helpers from <code>valhalla/meili/match_route.h</code>.</p>"},{"location":"meili/implementation_details/#map-matcher-factory","title":"Map Matcher Factory","text":"<p><code>valhalla/meili/map_matcher_factory.h</code></p> <p>The map matcher factory can facilitate map matcher creation. Pass it the Valhalla configuration and the travel mode, it reads the parameters and creates a map matcher for this mode. The factory also maintains a graph tile reader instance and a candidate query instance and shares them among all its matchers. Because of the data sharing it is cheap to create a map matcher from a factory. Note that both factory and matcher are not thread-safe.</p>"},{"location":"meili/library_api/","title":"Library API","text":"<p>The API is still in testing and will be changed any time. Any  suggestions are welcome to share at  GitHub Issues.</p> <p><code>TODO</code> The API listed here is not complete but ready for simple use.</p>"},{"location":"meili/library_api/#measurement","title":"Measurement","text":"<p>A <code>Measurement</code> object is a measured point read from GPS devices and it is usually inaccurate and noisy therefore needed to be matched. Extra attributes such as accuracy and search radius can be optionally attached to this object to help improve matching performance.</p> <pre><code>#include &lt;valhalla/meili/measurement.h&gt;\nusing namespace valhalla;\n\n// Constructor\nconst midgard::PointLL lnglat(13.44, 53.67); // the noisy location read from GPS device\nfloat gps_accuracy = 4.07,                   // GPS accuracy in meters\n      search_radius = 30;                    // in the area specified by the radius in meters search road candidates\nmeili::Measurement(lnglat, gps_accuracy, search_radius);\n</code></pre> <p>See <code>valhalla/meili/measurement.h</code> for more information.</p>"},{"location":"meili/library_api/#map-matcher-factory","title":"Map Matcher Factory","text":"<p>A <code>MapMatcherFactory</code> object produces <code>MapMatcher</code> objects for a specific transport mode. Other than that, it also manages in-memory data structures (e.g. tiles) shared among its matchers for you. It is recommended to instantiate it only once; but you have to keep it until all its matchers get destroyed.</p> <p>Pass it a valid configuration object, otherwise it throws <code>std::invalid_argument</code>.</p> <pre><code>#include &lt;valhalla/meili/map_matcher_factory.h&gt;\n\nboost::property_tree::ptree config;\nboost::property_tree::json_parser read(config, \"conf/valhalla.json\");\n\n// Constructor\nmeili::MapMatcherFactory(const boost::property_tree::ptree&amp; config);\n</code></pre> <p>To create a <code>MapMatcher</code> object of a specific transport mode:</p> <pre><code>// Possibly throw std::invalid_argument if invalid parameters are\n// found in this mode's configuration\nmeili::MapMatcher*\nmeili::MapMatcherFactory::Create(const std::string&amp; mode_name);\n</code></pre> <p>You should take care of the raw <code>MapMatcher</code> pointer returned by the factory.</p>"},{"location":"meili/library_api/#map-matcher","title":"Map Matcher","text":"<p><code>MapMatcher</code> object is responsible for matching sequences to the road network. It is created by <code>MapMatcherFactory</code>.</p> <p>To match a sequence offline: <pre><code>std::vector&lt;MatchResult&gt;\nmeili::MapMatcher::OfflineMatch(const std::vector&lt;Measurement&gt;&amp; sequence);\n</code></pre></p> <p>It returns a sequence of <code>MatchResult</code> objects corresponding to the sequence of <code>Measurement</code> objects.</p>"},{"location":"meili/library_api/#match-result","title":"Match Result","text":"<p>A <code>MatchResult</code> object contains information about which road and where the corresponding measurement is matched, and how to construct the route from previous result. It is usually generated by a <code>MapMatcher</code> object as one result of a sequential matching procedure.</p> <p>Here are some attributes: <pre><code>// Matched coordinate\nconst valhalla::midgard::PointLL&amp;\nmeili::MatchResult::lnglat();\n\n// Distance from measurement to the matched coordinate\nfloat meili::MatchResult::distance();\n\n// GraphId identify edges and nodes internally in Valhalla tiled data\nvalhalla::baldr::GraphId&amp;\nmeili::MatchResult::edgeid();\n</code></pre></p> <p>See the header file <code>valhalla/meili/match_result.h</code> for more information.</p>"},{"location":"meili/overview/","title":"Overview","text":"<p>Meili is a namespace within valhalla which is responsible for providing map matching functionality in the library. This scope of this functionality is essentially limited to the approach defined in the siminole microsoft paper outlining the technique: https://www.microsoft.com/en-us/research/publication/hidden-markov-map-matching-noise-sparseness/</p> <p>The important thing to note here is that Meili is not responsible for packaging the results of the map match into a route path as defined in our primary routing module Thor. Thus there is a non-trivial amount of effort to take the output of Meili and convert it to the expected format.</p>"},{"location":"meili/overview/#meili-code-layout","title":"Meili Code Layout","text":""},{"location":"meili/overview/#appendmeasurements","title":"AppendMeasurements","text":"<p>The first step Meili does is decide which tracepoints its going to map match. You might think that it map matches every point (and it does) but it doesnt actually do the routing computation using every point if it can avoid it. We allow specifying an interpolation distance which groups close together points such that only one will be used and the rest will be interpolated onto the map match after it is performed. This not only speeds up the code but it also avoids problems with GPS jitter of stationary objects. This work is done in the function <code>AppendMeasurements</code> which append tracepoints into what can be thought of as a matrix.</p> <p>Whats in this matrix? For every input point that <code>AppendMeasurements</code> decides it will use in the routing calculations a column is made in the matrix. Each column can have 1 or more rows but they will not all have the same number of rows. Each row represents an edge candidate for a given trace point. An edge candidate is a snap point along an edge in the graph within the radius of the input trace point.</p> <p></p> <p>The above is an image of the 4 magenta edge candidates for an input trace point with a 50m radius. <code>AppendMeasurements</code> eventually calls down into <code>CandidateQuery::Query</code> to get the list of candidates for a given trace point. It should be noted that <code>CandidateQuery</code> provides the same functionality <code>Loki::Search</code> does however there are some key differences. The main difference is that <code>CandidateQuery</code> keeps a fine resolution in-memory spatial index/cache of route network geometries. What this means is that it can have much higher throughput (once the cache is warm) than loki for high numbers of points. This is a key difference between map matching and routing use-cases. In routing we dont expect 1000s of way points but GPS traces are frequently reported at 1hz. Which means a 15 minute trace is already close to 1000 points. In the future we'd like to remove <code>CandidateQuery</code> and replace it with functionality from <code>Loki::Search</code> but at this time performance considerations keep us from doing so.</p>"},{"location":"meili/overview/#viterbi","title":"Viterbi","text":"<p>Viterbi is a dynamic programming algorithm used to find paths (eg. Markov chains) through a hidden state diagram such as a hidden Markov model. Read more about it here: https://en.wikipedia.org/wiki/Viterbi_algorithm. Within Meili we use the algorithm to determine the highest probability map match while doing the least number of routing calculations possible. You can think of the matrix described above as a series of nodes in a state diagram. Each row in each column has a connection to each row in the previous and next column in the diagram. We refer to these unique column/row pairs as <code>State</code>s through out the code and each is given a <code>StateId</code> which represents which column (0..n) and which candidate (0..m) it refers to. In the figure below candidates 0 1 and 2 are in column 0 whereas candidates 3, 4, 5 and 6 are in column 1.</p> <p></p> <p><code>ViterbiSearch</code> is run by iterating over pairs of columns and running routes between their candidates (rows). While doing so we measure two metrics, emission and transition cost. These costs are inversely related to the probabilities in the hidden markov model. Emmission cost is simply a measure of how close to the road network a given candidate is where as transition cost is a function of network distance along the route between two candidates in the graph.</p> <p>At the end of the viterbi search a highest probability (lowest cost) path, ie a sequence of <code>StateId</code>s, is returned. There may or may not be sections of the path where no route was possible between a given pair of <code>State</code>s or even between columns (all pairs of candidates in 2 adjacent columns).</p>"},{"location":"meili/overview/#match-points","title":"Match Points","text":"<p>After a path through the state diagram as been computed we need to get the first part of the output from Meili which is to say which candidates were used in the final path. To do that we call <code>FindMatchResults</code> which loops over the states and an returns a vector of <code>MatchResult</code> objects. The <code>MatchResult</code> contains information about which edge it matched to, what the lat,lon is once snapped to the edge, the distance along the edge as a percentage among other things. This is useful because the final service APIs mapmatching output contains this metadata, either indirectly via a origin/destination location or directly in trace_attributes or the osrm flavored output.</p>"},{"location":"meili/overview/#interpolation","title":"Interpolation","text":"<p>The <code>MatchResult</code>s that we got back only included those points which <code>AppendMeasurements</code> deemed necessary for the routing calculation. That means that for some of the input points, as mentioned earlier, we didnt actually attach a column to them or any states. This is kind of what it looks like in an ascii diagram:</p> <pre><code>p1p2------p3-------p4p5p6-----------p7--------------p8-----------p9p10\n</code></pre> <p>In the above <code>{p2, p5, p6, p9}</code> are all interpolated because they are close in distance to a prior point or in <code>p9</code>s case close to the last point which cannot be interpolated. So what we do next is we loop over pairs of states again and if between those two states there were unused (ie interpolated) input points then we project each of those points in succession onto the route between them. Using the example above, if we found a route between p4 and p7, then we would project p5 and p6 onto this route geometry to compute their <code>MatchResults</code>. Interpolation also guarantees that sequence ordering remains unchanged, ie p4 comes before p5 comes before p6 comes before p7 in the final route geometry.</p>"},{"location":"meili/overview/#route-building","title":"Route Building","text":"<p>Next we get the second part of Meil's output which is the actual path through the graph that was taken. We compute this with a call to <code>ConstructRoute</code>. Construct route uses the <code>States</code> to get at sequences of edges stored as a collection of <code>EdgeLabel</code>s in a <code>LabelSet</code>. The <code>LabelSet</code> contains all the edge labels a graph expansion saw. For a given <code>State</code> we know which was the last label it saw when it reached the destination <code>State</code>. So to get the route out we simply follow the chain of <code>EdgeLabel</code>s back to the origin <code>State</code>. Its like a linkedlist but without pointers, instead it uses indices into the <code>LabelSet</code>. The <code>MergeRoute</code> function is responsible for this recovery of a path between two states.</p> <p>From these <code>EdgeLabels</code> we make a vector of <code>EdgeSegment</code> objects, which is the final object that is returned. The <code>EdgeSegment</code> stores information about which edge in the graph it is, how much of it was used and what was the first and last <code>MatchResult</code> that got matched onto this <code>EdgeSegment</code>. It also contains information about whether or not there is a discontinuity after this <code>EdgeSegment</code>. As described before a discontinuity occurs when no paths for any candidates can be found from between two columns.</p> <p>During this process we also take care to cut <code>EdgeSegment</code>s where a <code>MatchResult</code> is marked as a <code>break</code> or <code>break_through</code> location. These types of locations denote where we want to have route legs in the final output. So that we don't have to break them down later in serialization, we make sure to split edges when constructing the route.</p>"},{"location":"meili/overview/#alternatives","title":"Alternatives","text":"<p>Meili supports the notion of alternatives. The API calls this \"best_paths\" but should be refactored to use \"alternatives\". What this allows a user to do is get the <code>top k</code> most probable paths with a couple caveats.</p> <p>The first caveat is that if there is a discontinuity in one of the results we will not return any more results after that. So if the first match had a discontinuity you'll only get 1 result even if you asked for 2.</p> <p>The second caveat is that redundant paths are not returned. What is a redundant path? Its a path that has already been seen in a previous result. Technically this means that the sequence of <code>EdgeSegments</code> has already been seen. Why would this happen? It is common that a <code>MatchResult</code> has two candidates, but no matter which one is used, the sequence of edges in the path remains the same. Basically the <code>MatchResults</code> may move around but the path is the same. This commonly occurs at intersections where one candidate may be some distance along the edge and the alternative candidate will be at the end of the previous edge. Either way both edges are on the path, the path didn't materially change.</p>"},{"location":"meili/overview/#complications","title":"Complications","text":"<p>The biggest complication in map matching by far is that of dealing with node snapped candidates. That is to say when an input trace points closest point on the graph is a node in the graph connecting 2 or more edges. This type of candidate presents 2 problems. The first is one of performance. You could say, no problem we'll just put a candidate for every edge at that node, but this is very wasteful as each candidate added increases the number of permutations of routes that viterbi will cause to be computed. So instead of doing that we have special logic in the router there handles node snapped candidates as a single candidate. The second problem with node candidates is that of ambiguity. Because a node does not refer to an edge but all of our other datastructures do (<code>MatchResult</code> and <code>EdgeSegment</code>) we end up needing to put a bunch of special case logic to patch things up if they are happening at a node. Specifically when we have a trace point that is the split between two legs in a route, we end up having the end of one leg on one edge and the beginning of the next leg on another edge and using the same <code>MatchResult</code> (which only stores one edge reference) means that it disagrees with one of the legs.</p>"},{"location":"meili/overview/#thor-contract","title":"Thor Contract","text":"<p>Meili itself does not have an external API. It kind of used to but has since been refactored to be accessed via the rest of our routing APIs. What this means is that it must fulfill the same contract that Thor does. That contract consists of a series of <code>Location</code>s with the chosen candidate for each <code>Location</code> getting filled out (in this case we translate the <code>MatchResult</code> into this) as well as a path which is a series of <code>PathInfo</code>s representing the edgs on the path and their cost/duration.</p> <p>The bulk of what has been described about Meili above was referring to its main entry point <code>OfflineMatch</code> (offline refers to the type of algorithm, see here: https://en.wikipedia.org/wiki/Online_algorithm). Thor must take the results of this function which, as described earlier, is a series of <code>MatchResults</code> and a series of <code>EdgeSegments</code> and convert them. This conversion takes place first via <code>FormPath</code> (every path finding algorithm implements one of these) and then via a call to <code>TripLegBuilder::Build</code> for each leg of the route. <code>FormPath</code> builds the vector of <code>PathInfo</code> objects from the <code>EdgeSegments</code>. The <code>MatchResults</code> are used to build origin and destination <code>Location</code>s. The <code>PathInfo</code>s and <code>Location</code>s are then sent to <code>TripLegBuilder::Build</code> as with every other routing operation.</p>"},{"location":"meili/service_api/","title":"Service API","text":"<p>The API is still in testing and will be changed any time. Any  suggestions are welcome to share at  GitHub Issues.</p>"},{"location":"meili/service_api/#request","title":"Request","text":"<p>The service accepts a GeoJSON feature or geometry (of type <code>MultiPoint</code> or <code>LineString</code>) in the <code>POST</code> request body.</p> URL Parameter Description Default <code>mode</code> Transport mode of the sequence. Possible modes are: <code>auto</code>, <code>bicycle</code>, <code>pedestrian</code> and <code>multimodal</code>. <code>multimodal</code> <code>search_radius</code> A numeric value in range <code>[0, 100]</code> to specify a radius (in meters) within which to search road candidates for each measurement. 40 <ul> <li> <p>Specifying a transport mode can limit the type of roads to match   (e.g. <code>auto</code> will only consider drivable roads), and therefore   improve the matching accuracy and speed. If the mode is unknown, use   the default <code>multimodal</code>, i.e. consider all types of roads,   even a   tree row.</p> </li> <li> <p>When GPS accuracy information is unknown, specifying a large   <code>search_radius</code> may slow down the matching procedure while a small   one may miss possible road candidates.</p> </li> </ul>"},{"location":"meili/service_api/#response","title":"Response","text":"<p>The service returns matched routes of the sequence as a GeoJSON <code>MultiLineString</code> feature. Matched coordinates are saved in the property <code>matched_coordinates</code> as a JSON array. If a measurement is not matched to any road, then the corresponding matched coordinate is <code>null</code>.</p>"},{"location":"meili/service_api/#examples","title":"Examples","text":"<p>Example request:</p> <pre><code>curl -X POST \"https://localhost:8002?search_radius=35&amp;mode=auto\"\n</code></pre> <p>Example request body: <pre><code>{\n  \"coordinates\": [\n    [ 13.288925, 52.438512 ],\n    [ 13.288938, 52.438938 ],\n    [ 13.288904, 52.439169 ],\n    [ 13.288821, 52.439398 ],\n    [ 13.288824, 52.439491 ],\n    [ 13.288824, 52.439563 ]\n  ]\n}\n</code></pre></p> <p>Example response: <pre><code>{\n  \"status\": 200,\n  \"message\": \"OK\",\n  \"data\": {\n    \"type\": \"Feature\",\n    \"geometry\": {\n      \"type\": \"MultiLineString\",\n      \"coordinates\": [\n        [\n          [ 13.288884, 52.438507 ],\n          [ 13.288852, 52.438835 ],\n          [ 13.288844, 52.439090 ],\n          [ 13.288825, 52.439136 ],\n          [ 13.288805, 52.439159 ],\n          [ 13.288601, 52.439365 ],\n          [ 13.288538, 52.439384 ],\n          [ 13.288719, 52.439636 ]\n        ]\n      ]\n    },\n    \"properties\": {\n      \"matched_coordinates\": [\n        [ 13.288884, 52.438507 ],\n        [ 13.288848, 52.438934 ],\n        [ 13.288805, 52.439159 ],\n        [ 13.288601, 52.439365 ],\n        [ 13.288685, 52.439590 ],\n        [ 13.288719, 52.439640 ]\n      ]\n    }\n  }\n}\n</code></pre></p>"},{"location":"mjolnir/admins/","title":"Administrative data","text":""},{"location":"mjolnir/admins/#why-is-administrative-attribution-important","title":"Why is administrative attribution important?","text":"<p>[x] Rental Car</p> <p>[x] Laptop</p> <p>[x] Cell</p> <p>[x] Luggage</p> <p>[ ] Passport</p> <p>D\u2019oh!  Facepalm!  I totally forgot that my passport has expired.  The fastest route from Detroit, MI to Buffalo, NY is via Canada.   For a US citizen, it is best to use a passport when driving through Canada; therefore, I must seek an alternate route.  What drives me nuts is the fact that most of the routing sites do not provide an option to avoid country crossings.  However, Valhalla does provide the ability to avoid country borders.</p>"},{"location":"mjolnir/admins/#admins-and-costing","title":"Admins and Costing","text":"<p>Mjolnir pulverizes data into a usable form.  Well, not really...It does, however, give the option to apply attribution to the Valhalla routing data.  An administrative database is created via pbfadminbuilder and can then be used to flag country crossings on edges during the building of the graph data.</p> <p>Now costing comes into play\u2026Valhalla uses dynamic, run-time costing to form the route path. (Read more about SIF and dynamic costing in our previous blog post.)  A route request to Valhalla includes the name of the costing model and can include optional parameters accepted by the costing mode.  In our case, we are using the Auto costing model and the optional parameters:</p> <ul> <li> <p>country_crossing_cost = A cost that is applied when a country crossing is encountered. This cost is added to the estimated time / elapsed time. The default cost is 600 seconds.</p> </li> <li> <p>country_crossing_penalty = A penalty that is applied to the cost when a country crossing is encountered. This penalty can be used to create paths that avoid country crossings. The default penalty is 0.</p> </li> </ul> <p>Let\u2019s try it out.   Running the route from Detroit, MI to Buffalo, NY takes us through Canada.  Obviously, this will not work for me as my passport has expired.</p> <p></p> <p>However, if I boost the country_crossing_penalty to say 25 minutes or 1500 seconds, we avoid Canada and the use of the passport for this route.</p> <p></p> <p>Now my trip can begin!  I started my passport renewal process and I am jumping into the car with directions that avoid country crossings.</p>"},{"location":"mjolnir/admins/#administrative-attribution-is-important","title":"Administrative attribution is important.","text":"<p>As you can see, administrative attribution is important for avoidance.  We could set the country_crossing_penalty to a very high value to always avoid country crossings.</p> <p>Valhalla will also use the administrative information for providing country and state or province information in the narrative (e.g., Crossing into New York, United States or Crossing into France).  In the future, we will also use the country ISO code to create logic in ODIN that will be used to determine the base names of streets internationally.  The base names will enable us to produce a cleaner narrative by collapsing maneuvers appropriately.</p> <p>Currently, when max_speed tag is not present, Valhalla assigns a speed based on the highway tag.  There are country specific guidelines for speed limits per highway tag.  We could use these default speed limit matrices for each country in order to provide more accurate time estimation and the best route (Maxspeed).</p>"},{"location":"mjolnir/admins/#whats-next-for-admins-in-valhalla","title":"What\u2019s next for admins in Valhalla?","text":"<p>Valhalla uses admins to determine if we drive on the right or left; however, default access restrictions per country are not assigned yet. Can I walk on a trunk road in France?  What about in the United States?  How about in Germany?  Admins will help Valhalla create default access restrictions for each country where available (Access-Restrictions).</p>"},{"location":"mjolnir/attribution/","title":"Attribution","text":"<p>Attribution is required for many of our data providers. Example language is provided below, but you are responsible for researching each project to follow their license terms. More details are available on the Data Sources page.</p> <p>Required attribution:</p> <p>\u00a9 OpenStreetMap contributors</p> <p>Required attribution for projects using elevation data:</p> <p>\u00a9 OpenStreetMap contributors, U.S. Geological Survey, and U.S. National Oceanic and Atmospheric Administration</p>"},{"location":"mjolnir/attribution/#where-to-attribute","title":"Where to attribute","text":"<p>Attribution needs to \"appear in a place that is reasonable to the medium or means you are utilising.\" Specific examples are given by the OSM Foundation and are generally best practices for giving credit to any source.</p>"},{"location":"mjolnir/data_sources/","title":"Data sources in Valhalla","text":"<p>Valhalla routing tiles are created from several different open data sets. We owe a tremendous debt of gratitude to the individuals and communities which produced them. This document identifies the data sources and licensing of these data sources.</p> <p>Attribution is required for many of our data providers. See the Attribution document for more information.</p>"},{"location":"mjolnir/data_sources/#openstreetmap","title":"OpenStreetMap","text":"<p>OpenStreetMap is a community-driven, editable map of the world. It prioritizes local knowledge and individual contributions over bulk imports, which often means it has excellent coverage even in remote areas where no large-scale mapping efforts have been attempted. OpenStreetMap contains information on landmarks, buildings, roads, and natural features. Valhalla primarily uses the road information from OSM to create its routing network. Valhalla also uses the relations information to provide extra attribution to roads and to create restrictions. The higher-level administrative polygon information is also used to identify country and state/province information for roads.</p> <p>All OpenStreetMap data is licensed under the ODbL, a share-alike license, which also requires attribution.</p> <p>Please consider donating to the OSM Foundation to help cover the administration and server costs.</p>"},{"location":"mjolnir/data_sources/#elevation-data","title":"Elevation data","text":"<p>Valhalla uses terrain data for building elevation-influenced routes, such as for bicycles. You can find more about the license and attribution requirements for elevation data here.</p>"},{"location":"mjolnir/data_sources/#boost-timezone-data","title":"Boost Timezone Data","text":"<p>Valhalla attaches timezone information to every node/intersection in the road network. The timezone data comes from tz_world. This data contains polygon definitions of the various timezones throughout the world. Timezone specifications within each region and conversions of time between timezones are derived using Boost.</p> <p>Please notify us if you believe that an open data project has not been properly noted.</p>"},{"location":"mjolnir/geojson/","title":"Map Roulette Geojson Generation","text":"<p>To generate the geojson, you'll need to detect the cases, gather the required data, and define how the geojson should be created.</p>"},{"location":"mjolnir/geojson/#detection","title":"Detection","text":"<p>You will have to design an algorithm that can detect the cases that you are looking for. Once you are able to detect the cases, you now need to capture the useful data.</p> <p>For an example of existing detection please see the function bool IsUnroutableNode in <code>valhalla_build_statistics.cc</code>.</p>"},{"location":"mjolnir/geojson/#gathering-the-data","title":"Gathering the Data","text":"<p>At a minimum, you will need some sort of geojson feature to display on the Map Roulette interface. This can be a point or linestring or a combination of them. At some point in the data capture you must capture a lat-long pair (PointLL) that is unique for each case you detect. This will be used later as the identifier in the geojson. You will need to modify the <code>roulettedata</code> struct to hold your new data.</p>"},{"location":"mjolnir/geojson/#geojson","title":"Geojson","text":"<p>To have your geojson correctly recognized by Map Roulette and the automation scripts you will need to have a specific format. You will need to implement something like this that creates your geojson and adds it to a collection. A single task's geojson should look something like the following:</p> <pre><code>{\n    \"instruction\": \"This node is either unreachable or unleavable. Edit the surrounding roads so that the node can be accessed properly\",\n    \"properties\": {\n        \"key\": 4770031602477192848,\n        \"type\": \"Node\"\n    },\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [8.64613, 44.63913]\n    }\n}\n</code></pre> <p>The <code>properties.key</code> field here is the hashed PointLL (lat-long) used as the id. Look at the previous link about geojson creation  to see how to create the hash.</p> <p>That should be it, now you can start automating your Map Roulette tasks.</p>"},{"location":"mjolnir/getting_started_guide/","title":"Mjolnir: Getting started guide","text":"<p>The mjolnir library is essentially a set of applications, data structures and algorithms which deal with things like: parsing OpenStreetMap data extracts, cutting routable \"graph\" tiles, generating tile hierarchies and testing for data deficiencies.</p> <p>If you would like to create your own routing tiles, this guide will help you get started.</p>"},{"location":"mjolnir/getting_started_guide/#data","title":"Data","text":"<p>You can download extracts from Geofabrik GmbH.  If you wish to convert the entire planet, we have successfully run conversions on quad-cores(CPU @ 2.70GHz) machines with 16 gigs of RAM utilizing a SSD.  Conversions with administrative areas and timezones, but without elevation data will take around 15 hours.  This route graph will include motor vehicle, pedestrian, and bicycle route information.</p> <p>For more information on what tags and values we use from OSM please consult our tag parsing guide.</p>"},{"location":"mjolnir/getting_started_guide/#creating-data","title":"Creating Data","text":"<p>Build valhalla and its various tools:</p> <pre><code>mkdir build\ncd build\ncmake ..\nmake all check -j$(nproc)\n</code></pre> <p>You'll see <code>valhalla_build_tiles</code> under the build directory. One level up you'll find <code>scripts/valhalla_build_config</code> which you can use to generate the config file needed to build routing tiles. Check the <code>--help</code> text for all the various configuration options in the config file.</p> <p>Generate your config:</p> <pre><code>../scripts/valhalla_build_config &gt; valhalla.json\n</code></pre> <p>Then build some tiles from an extract:</p> <pre><code>./valhalla_build_tiles --config  /path_to_your_config/valhalla.json /data/osm_data/your_osm_extract.pbf\n</code></pre>"},{"location":"mjolnir/getting_started_guide/#optional-prerequisites","title":"Optional Prerequisites","text":""},{"location":"mjolnir/getting_started_guide/#administrative-areas","title":"Administrative Areas","text":"<p>An administrative database is created via <code>valhalla_build_admins</code> and is used to flag country crossings on edges during the building of the graph data.  Moreover, we also use admins to determine if we drive on the right or left (default: right).  In the future, we will use admins to set the default access restrictions per country.</p> <p>We recommend running the <code>valhalla_build_admins</code> on the planet; otherwise, parent admin information maybe lost or not all admins will get saved to the database.  This usually happens when a way is missing from the extract, but is part of the admin relation.  Most likely the extract polygon does not cover the entire admin relation.</p> <p>If you would like administrative information within the route graph, please follow the following steps:</p> <ol> <li>Download your osm data.</li> <li>If needed, update the admin value under mjolnir in your valhalla.json config.  Default filename and directory is <code>/data/valhalla/admin.sqlite</code>.</li> <li>Run <code>valhalla_build_admins</code> under the valhalla directory. <code>./valhalla_build_admins --config  /path_to_your_config/valhalla.json /data/osm_data/your_osm_extract.pbf</code></li> <li>The next time you run <code>valhalla_build_tiles</code>, admin information will be added to the route graph.</li> </ol>"},{"location":"mjolnir/getting_started_guide/#timezones","title":"Timezones","text":"<p>Timezones are used if you want to set your departure or arrival date and time.</p> <p>If you would like timezone information within the route graph, please follow the following steps:</p> <ol> <li>If needed, update the timezone value under mjolnir in your valhalla.json config.  Default filename and directory is <code>/data/valhalla/tz_world.sqlite</code>.</li> <li>Go to <code>your_valhalla_directory/scripts</code>.</li> <li>Run <code>valhalla_build_timezones &gt; /path_to_your/tz_world.sqlite</code></li> <li>The next time you run <code>valhalla_build_tiles</code>, timezone information will be added to the route graph.</li> </ol>"},{"location":"mjolnir/getting_started_guide/#elevation","title":"Elevation","text":"<p>If you want to add elevation information to your route tiles you can do so using SRTMv3 tiles as the input.</p> <ol> <li>If needed run <code>valhalla_build_elevation</code>. I will create an elevation dataset which is about 1.6TB for the whole world</li> <li>Point your <code>valhalla.json</code> configuration to this directory so it can be referenced when building the graph tiles. The proper configuration value for this can be sent when running <code>valhalla_build_config</code> using the <code>--additional-data-elevation</code> argument.</li> <li>The next time you run <code>valhalla_build_tiles</code>, elevation information will be added to the route graph.</li> </ol>"},{"location":"mjolnir/getting_started_guide/#transit-data","title":"Transit Data","text":"<p>If you want to add transit data to your route tiles you can follow these steps:</p> <ol> <li>Use <code>valhalla_build_transit</code> to create an initial set of transit tiles for your region.</li> <li>Configure <code>valhalla.json</code> using <code>valhalla_build_config</code> and the <code>--mjolnir-transit-dir</code> argument.</li> <li>The next time you run <code>valhalla_build_tiles</code>, transit graph will be connected to the route graph.</li> </ol>"},{"location":"mjolnir/historical_traffic/","title":"Traffic in Valhalla","text":"<p>Traffic data for routing engines can be divided into two different types:</p> <ul> <li>Historical traffic describes the typically observed speed on a road at a specific point in time. So e.g. the typical speed on a Monday morning at 8 o'clock.</li> <li>Live traffic describes the currently observed speed on a road according to the actual traffic situation.</li> </ul> <p>Valhalla supports both types of traffic for all APIs, excluding multimodal costing. For more information about how to route with traffic data and time information, check the respective API documentation. In the following it will be explained how to integrate historical traffic data into the valhalla graph.</p>"},{"location":"mjolnir/historical_traffic/#graph-association","title":"Graph Association","text":""},{"location":"mjolnir/historical_traffic/#with-osm-ids","title":"With OSM IDs","text":"<p>If the available traffic data is associated to OSM ways, these ways have to be mapped on valhallas internal graph ids to then add the traffic data to the routing graph. The valhalla tool <code>valhalla_ways_to_edges</code> can be used to generate a mapping from OSM way ids to the valhalla graph ids. An example for an <code>way_edges.txt</code> file created by the tool looks like this: <pre><code>1175181586,1,112642252344\n984719585,1,110964530744,1,112508034616,1,112843578936\n</code></pre> The format of each row is <code>&lt;osm_way_id&gt;,[&lt;direction: 0 | 1&gt;, &lt;graph_id&gt;]</code>. Accordingly, the <code>osm_way_id</code> is mapped to multiple <code>graph_id</code>'s. An <code>graph_id</code> can be converted to the required string format according to the <code>to_string</code> function of the class <code>valhalla::baldr::GraphId</code>, whose implementation can be found in the valhalla repository. The result is a string of the following form <code>level/tile_id/id</code> (e.g. <code>1/47701/130</code>).</p>"},{"location":"mjolnir/historical_traffic/#historical-traffic","title":"Historical Traffic","text":"<p>Valhalla requires the historical speed information in following CSV file format:</p> <pre><code>edge_id,freeflow_speed,constrained_speed,historical_speeds\n1/47701/130,50,40,AQ0AAAAAAA...\n1/47701/131,50,40,AQ0AAAAAAA...\n</code></pre> <p>The first three columns are required to assign historical traffic to an edge, while the <code>historical_speeds</code> column is optional for providing more detailed speed information. The <code>edge_id</code> column represents the internal <code>graph_id</code> of ways in the valhalla graph. Check the previous section to see how your data can be mapped on these <code>graph_id</code>'s. The columns <code>freeflow_speed</code> represents the typical speed during night and <code>constrained_speed</code> is the typical speed during day (in km/h). </p> <p>The <code>historical_speeds</code> column contains more detailed information about how the traffic on a segment changes over the week. It requires the estimated speed (in km/h) of a road segment in 5 minute intervals covering a whole week. This leads to a total of 2016 speed values per road segment, which should start at Sunday 0:00. The <code>historical_speeds</code> column contains an DCT-II encoded version of the 2016 speed values. It can be obtained by using functions whose implementation can be found in the valhalla source code. First <code>compress_speed_buckets(const float* speeds)</code> can be called to obtain an array of coefficients. In a next step <code>encode_compressed_speeds(const int16_t* coefficients)</code> can be used to convert these to the string encoded version of the speed values, which can be put into the CSV-file.</p> <p>Finally, the speed of each way has to be put into the correct place in a folder hierarchy. This folder hierarch should look similar to valhalla\u2019s tile hierarchy. An example tile hierarchy could look like this: <pre><code>.\n|-- 0\n|   `-- 003\n|       `-- 015.gph\n|-- 1\n|   `-- 047\n|       `-- 701.gph\n</code></pre></p> <p>The traffic folder structure, containing the traffic CSV files, should accordingly look like this: <pre><code>.\n|-- 0\n|   `-- 003\n|       `-- 015.csv\n|-- 1\n|   `-- 047\n|       `-- 701.csv\n</code></pre></p> <p>If a way's information is found in <code>0/003/015.gph</code>, then its matching speed values have to be saved in <code>0/003/015.csv</code>. To find the path in the tile hierarchy to save a speed value in, the function <code>GraphTile::FileSuffix</code>can be used to obtain the path from a <code>graph_id</code>. Its implementation can be found in the valhalla source code.</p> <p>In a last step, the traffic data has to be added to the routing graph. This can be done by using the <code>valhalla_add_predicted_traffic</code> tool. Its parameter <code>-t</code> can be used to hand over the folder which contains the traffic CSV files.</p>"},{"location":"mjolnir/map_roulette/","title":"Automatic Map Roulette Task Updates","text":""},{"location":"mjolnir/map_roulette/#overview","title":"Overview","text":"<p>The tool is located under <code>mjonir/py/challenge_admin/</code> as  <code>admin_tool.py</code> and is run from the command line. This tool works in conjunction with <code>valhalla_build_statistics</code> which detects errors in the OpenStreetMap data set and outputs those errors as a geojson file. This tool then reads the geojson file and compares it to the existing tasks already uploaded to Map Roulette and uploads the new tasks. Optionally, the tool can also detect when tasks have been marked as fixed, but have shown up again during the detection process.</p>"},{"location":"mjolnir/map_roulette/#configuring","title":"Configuring","text":"<p>A sample configuration file can be found at valhalla/conf/maproulette.json and must be configured before this tool will work properly. Additionally, you will have to do some setup on the maproulette website.</p>"},{"location":"mjolnir/map_roulette/#perform-map-roulette-setup","title":"Perform Map Roulette Setup","text":""},{"location":"mjolnir/map_roulette/#create-a-challenge","title":"Create a challenge","text":"<p>To get started you'll need to create a challenge using the interface on the website. Once you have created a challenge, you will just need the challenge ID. You will put the challenge ID into your configuration file later.</p>"},{"location":"mjolnir/map_roulette/#get-an-api-key","title":"Get an API key","text":"<p>On the Map Roulette website click on your username at the top right, then select \"Profile\". Your API key can be found in the side panel on the left.</p>"},{"location":"mjolnir/map_roulette/#modify-the-config-file","title":"Modify the Config File","text":"<p>Now that you have the information you need, substitute your api key into the config file. Then, you have to set up your challenges entry. A simple entry will look something like:</p> <pre><code>\"challenges\":\n    {\n        \"18\": [\"Loop\", \"Node\"]\n    }\n</code></pre> <p>This simply specifies that challenge number 18 will contain tasks of type Loop and Node. The challenge number is the one that you found after creating the challenge. The task types are the types of tasks you specified in the geojson. If you have gotten here and don't know what geojson you should have, click here to learn more.</p> <p>Finally, make sure that you change the <code>server_url</code> field to reflect the actual server (https://maproulette.org) if not running the server locally.</p>"},{"location":"mjolnir/map_roulette/#using-this-tool","title":"Using this tool","text":"<p>Usage of the tool is fairly simple as it is designed to be largely automatic. All you need to do is provide some command line arguments.</p>"},{"location":"mjolnir/map_roulette/#required-arguments","title":"Required Arguments","text":"<p>There are two required Arguments:</p> <pre><code>-c, --config    json config file to use\n-i, --geojson   geojson to build new tasks from\n</code></pre> <p>There are also others available:</p> <pre><code>-h, --help      how to call the program\n-r, --resubmit  try to detect tasks that have not been fixed,\n                if there are unfixed tasks marked as fixed,\n                resubmit them as new tasks\n</code></pre>"},{"location":"mjolnir/map_roulette_blog/","title":"Map Roulette and Valhalla","text":"<p>Not so long ago the routing team started to notice that occasionally the origin or destination of a route would be unreachable. These routes weren't anything extravagant or extraordinary, but for some reason they were failing. After some investigation we realized that certain errors in OpenStreetMap could easily cause the routes to fail. The most obvious of these seemed to be when the direction of one way roads was switched. To differentiate between routes that fail because two locations are disconnected in real life and routes that were doomed from the start by these errors, we started trying to detect them. Once we were detecting them we had to figure out what to do with them. Do we manually edit them all ourselves? Do we ignore them and hope they get fixed down the road? There could be hundreds or thousands of these types of errors in OSM that could impact routing.</p> <p>To demonstrate what this might look like, here is the same route before and after an error was fixed. A one way road in the red box was reversed, causing the route to go further than needed.</p> <p></p> <p></p> <p>Enter Map Roulette: A platform that allows contributors to submit sets of errors so that the OSM community can fix them. After we found out about this, we started working on code designed specifically to look for these errors, and once we had a collection of these errors we planned to submit them to Map Roulette. As we got closer to doing this, we realized that eliminating the errors only once would not prevent errors from being created in the future. We also thought that we could probably automate the process to minimize manual intervention in the process. To start testing this we needed the help of Martijn Van Exel, the creator of Map Roulette. He helped us get local instances of the Map Roulette server running as well as answered other questions we had along the way.</p> <p>The automation process seemed like a good fit for a bit of Python. After building a few tools for testing the Map Roulette API and our collection of errors, we brought it all together to create a tool that can be run without any manual intervention. We now run this tool right after checking the latest set of tiles for errors, allowing any new errors to be automatically uploaded to Map Roulette. Additionally, the tool can also detect errors that were marked as fixed but were not fixed correctly.</p> <p>The result of all this work is a framework that allows for detection, submission, and eventual resolution of OSM errors. To start doing this for a new type of error, the only thing we would need to do would be to write a detection algorithm, create a geojson representation of the error, and add the new type of error to the tool's configuration file.</p> <p>Currently, we only have one type of error being detected and automatically submitted, but look forward to seeing what other issues we can fix and how much we can help improve OSM.</p>"},{"location":"mjolnir/tag_parsing/","title":"OSM Tag Usage","text":""},{"location":"mjolnir/tag_parsing/#table-of-contents","title":"Table of Contents","text":"<ol> <li>OSM Data Model Overview</li> <li>OSM Processing Overview</li> <li>Lua Tag Processing</li> <li>C++ Tag Processing</li> <li>Common Pitfalls and Debugging</li> </ol>"},{"location":"mjolnir/tag_parsing/#osm-data-model-overview","title":"OSM Data Model Overview","text":"<p>OSM's data is mostly schemaless. It currently has a top level structure which consists of 3 element types. Those are nodes, ways and relations. Nodes are point features, ways are linear features (comprised of nodes) and relations are multi features (comprised of nodes and/or ways). See here for more on the types of elements within the OSM dataset.</p> <p>Each of these objects can have any number of key value pairs, called tags associated with it. The tags are used to delineate physical, political, temporal, etc attribution of the element to which they are attached.</p> <p>Valhalla creates a routable graph directly from OSM elements and their tags. The connectivity of the graph is a direct result of how the nodes, ways and relations are correlated in the data model. The attribution on edges and nodes in the resulting graph come directly from the tags on those OSM elements. Note that many OSM elements, because of their tags (or lack thereof), will not be useful in creating a routable graph and are simply ignored.</p>"},{"location":"mjolnir/tag_parsing/#osm-processing-overview","title":"OSM Processing Overview","text":"<p>The basic flow valhalla follows when creating routing tiles is as follows:</p> <ul> <li>Parse all the ways and their tags</li> <li>Parse all the relations and their tags</li> <li>Parse all the nodes and their tags</li> </ul> <p>Each of the step uses a combination of <code>lua</code> and <code>c++</code> to transform the tags into a structured set of values. From <code>c++</code> we call into <code>lua</code> passing it a single element. What comes out is a <code>map</code> of <code>keys</code> to <code>values</code> where both have been massaged to fit into a small (compared to the original data) set of permutations. Then the <code>c++</code> side of things will turn an element's key value pair strings into well defined structures for storage. The result of this is a vector of fixed-size (static number of bytes) structures (think of a <code>c++</code> <code>struct</code>) for each element type. Because we turn the tags into fixed-size structures we can store these in a file and use memory mapping to complete this process on very large datasets (the planet) with very modest hardware. Note that we don't store relations in a file simply because they require very little space.</p> <p>Once we've gotten all of the basic structures parsed out of the OSM data model into a well-defined set of structures we simply iterate over those structures to create the graph. We take care to sort the structures so that we can iterate over ways and then, within a given way, over the nodes that comprise it (in the right order).</p>"},{"location":"mjolnir/tag_parsing/#lua-tag-processing","title":"Lua Tag Processing","text":"<p>The concept of using <code>lua</code> to transform OSM tags into a discrete set of keys and values is inspired by <code>osm2pgsql</code>. This allows those who want to change the way tags are interpreted to do so without having to recompile valhalla. Additionally, <code>lua</code> is quite simplistic so one could argue that its barrier to entry is pretty low. Valhalla comes with default <code>lua</code> transformation functions which can be found here. If you'd like to override these you may do so by changing arguments in the <code>valhalla.json</code> configuration used with <code>valhalla_build_tiles</code>.</p> <p>The process of boiling down all the different permutations of OSM values into a discrete set is quite formidable (one could argue that it's never done). An interesting resource for inspecting what type of tags on what types of elements exist in wild can be found at TagInfo. This is great when you want to figure out what tags your parser should target to get as much of the desired attribution as possible. TagInfo also publishes a list of different projects that use OSM data and what tag permutations lead to what attribution in those respective projects. Valhalla publishes a file called taginfo.json which allows the TagInfo website to list the tags that valhalla parses. For more see here.</p>"},{"location":"mjolnir/tag_parsing/#c-tag-processing","title":"C++ Tag Processing","text":"<p>The basic principle of this part of the process is that we take the string outputs from the <code>lua</code> calls and marshal them into what are essentially integral types. There may be some other interesting things that happen at this point in time such as marking which OSM nodes which will become graph nodes (because more than one way references them), and marking loops in ways (because the same node happens more than once) or storing turn restriction information.</p>"},{"location":"mjolnir/tag_parsing/#common-pitfalls-and-debugging","title":"Common Pitfalls and Debugging","text":"<p>When you find a problem with the quality of a route or with route tile creation, one of the first places to look will be at the data. There can be a few places you want to check.</p> <ul> <li>Missing or wrong tags on OSM elements</li> <li>Missing lua code to parse particular tags</li> <li>Incorrect error handling of tag values</li> </ul>"},{"location":"mjolnir/tag_parsing/#failure-to-cut-tiles","title":"Failure to Cut Tiles","text":"<p>Take a look at the log that comes out of <code>valhalla_build_tiles</code>. There are many phases of this process. If the process failed at the beginning (in the parsing phase) there is a good chance we have a bug within the <code>c++</code> marshalling of strings to integers. You'll want to get a copy of the <code>pbf</code> OSM data that was being used when the program crashed (it usually crashes in this case). If you can get a backtrace or even a core file then you can localize this without running it yourself but otherwise simply run <code>valhalla_build_tiles</code> and find where it's crashing. Chances are there is an unprotected <code>std::stoi</code> or something similar.</p>"},{"location":"mjolnir/tag_parsing/#route-quality-issue","title":"Route Quality Issue","text":"<p>If you are having a route quality issue where the route is using a particular road it shouldn't or not using a particular road that it should you'll want to see what valhalla interpreted the particular street to have. We have a tool for this. The first step here is to get the tile set with the quality issue and run a server with it. You can then crack open this debug tool which is pointed at <code>localhost</code> (or you can point it at another server). Simply click the problem road. You'll get a green result (or multiple). Click which ever green result is nearest to the problem you are experiencing. The side panel will show you detailed attribution that valhalla stores for this graph edge (or node if you clicked one of those). Carefully inspect the information. Do any of the access flags tell you anything you wouldn't expect? Once you notice what attribution looks incorrect you can then sift through the details to find the way id. Take the way id and plug it into osm.org, like https://osm.org/way/way_id_here. From there you can see the tags table which should show you the attributes valhalla sees when its parsing. At this point there is either wrong data in OSM or wrong interpretation in valhalla.</p>"},{"location":"mjolnir/why_tiles/","title":"Why tiles?","text":""},{"location":"mjolnir/why_tiles/#routing-tiles-the-who-what-when-where-how-and-why","title":"Routing Tiles - the Who, What, When, Where, How and Why?","text":""},{"location":"mjolnir/why_tiles/#a-bit-of-the-who-when-and-how","title":"A bit of the Who, When and How","text":"<p>We had just started our new endeavor at Mapzen and were kicking around fundamental ideas of what our system should look like. Here's a bit of a transcript of how we got here:</p> <p>17/11/14 01:27 EST Kevin: wakes up in a cold sweat and begins to fumble around for his phone</p> <p>17/11/14 01:28 EST Kevin: violently stubs his toe on the sharpest lego he's ever witnessed</p> <p>17/11/14 01:30 EST Kevin: cursing and slightly bloody, he manages to ring Dave</p> <p>17/11/14 01:32 EST Dave: Uhnnng...</p> <p>17/11/14 01:32 EST Kevin: Dave! What if we route on tiled data!?</p> <p>17/11/14 01:33 EST Dave: Um... yeah... you've been working in the mapping world for far too long</p> <p>17/11/14 01:33 EST Dave: throws his phone to the furthest corner of the room</p> <p>17/11/14 01:34 EST Kevin: Dave??</p> <p>17/11/14 01:35 EST Kevin: begins pacing</p> <p>17/11/14 04:17 EST Kevin: still pacing</p> <p>17/11/14 07:01 EST Kevin: rings dave once again</p> <p>17/11/14 07:02 EST Kevin: But Dave... We can have levels of detail, regional extracts, offline mobile routing... and we can open source it all</p> <p>17/11/14 07:03 EST Dave: Hmm... Tiled. Hierarchical. Open. Routing. We could call it THOR. That's a pretty sweet acronym! That will make a great project name. But yeah... I'm not sure it'll work.</p> <p>Ok, so the above is slightly embellished (everyone knows Dave stopped answering his phone after that one weekend call about traffic on the NJ Turnpike), and let's just say Kevin's proposal was met with some degree of skepticism. But after reasoned consideration the team decided that tiled, hierarchical routing data had merits and was worth pursuing.</p> <p>Several months later, we have found that a tiled routing graph is possible and have begun exploring some of the benefits we'd hoped it would provide us and especially you!</p> <p>This GIF gives a conceptual overview of the tiles used in a resultant graph traversal and how the level of detail needed may change depending on the connectivity of the road network in a given region.</p> <p></p>"},{"location":"mjolnir/why_tiles/#show-me-the-what-where-and-why","title":"Show me the What, Where and Why!","text":"<p>So you can find all of our software at our Valhalla github organization. There's a lot of software there but most of it is modern c++ with a little bit of python for prototypes, a bit of ruby for chef style deployment and a bit of javascript for demo'ing some of the functionality. </p>"},{"location":"mjolnir/why_tiles/#onto-the-why","title":"Onto the Why!","text":"<p>We hope to enjoy some key benefits of a tile based approach to routing, they are as follows:</p> <ul> <li> <p>Reduced memory requirements  a connected graph can take up a lot of space in memory. By cutting the graph into a tiled structure you more easily impose limits on how much of the graph resides in memory at any one time. This could enable on device routing capabilities on even the most meager of hardware which could improve access to those in developing regions.</p> </li> <li> <p>Cacheability  imagine a multi-level cache where an S3 bucket has a setting of constantly updated route tiles with proper http cache headers etc. Follow that up with a client side disk cache used to back a memory cache that the routing algorithm actually uses in graph traversal computations. </p> </li> <li> <p>Updateability  updates to the graph could be highly parallelized simply because the graph is already broken up into a tiled structure. Faster turn around times on edits would be spectacular.</p> </li> <li> <p>Regional Extracts and Off-line Routing  you're headed to Switzerland for vacation and you don't want to pony up the Francs to get a SIM card? Before you go, or while you're on wifi, download an extract of the region. Afterall it's only 100mb or so.</p> </li> <li> <p>Return to Route  most phone based navigation applications require contacting a server when a user deviates from the specified route path, even for common cases like stopping for fuel or food. With graph tiles downloaded along the route path, the navigation application can find a path back to the route without an expensive call to the routing server. </p> </li> <li> <p>Enhanced Navigation tiles along the route allow more detailed information to be presented along the route without having to increase the payload in the initial call to the routing service. Exits along the highway, names of upcoming roads, and other information can be presented when graph tiles are present.</p> </li> </ul> <p>We're excited with what we've accomplished so far, and look forward to showing you more soon. We plan to launch an open routing service as well as downloadable tiles later in the year. In the meantime though, have a quick browse of the code and reach out if something doesn't make sense!</p>"},{"location":"sif/dynamic-costing/","title":"Dynamic costing","text":""},{"location":"sif/dynamic-costing/#sif-dynamic-costing-within-valhalla","title":"SIF - Dynamic Costing within Valhalla","text":"<p>Two core components of the Valhalla open source routing engine are Thor and Sif. These 2 companions (in Norse mythoogy Thor and Sif are husband and wife) form the basis of Valhalla's path generation algorithm. Thor contains the path computation algorithms and traverses the routing tiles, while Sif performs costing that is central to forming the best path. Rather than baking costs into the routing graph data, Valhalla uses dynamic, run-time costing to generate costs based on a rich set of attributes stored in the routing graph tiles. This allows run-time generation of different types of routes (or routes with different characteristics) simply by using different costing methods and options within those methods.</p>"},{"location":"sif/dynamic-costing/#path-costing-introduction","title":"Path Costing Introduction","text":"<p>Routing from one location to another is solved by a class of algorithms known as shortest path algorithms. This is somewhat misleading, as often one is interested in a route that is shortest time or one that makes fewer turns. A better term for shortest path algorithms is least cost algorithms - this properly indicates that the method is minimizing cost, be it distance, time, or some other metric.</p> <p>Naive assignment of cost to edges of the routing graph will lead to poor routing solutions. Simple costing based solely on distance or on time (based solely on speed) can lead to poor route paths with excessive turns and stops. Considerations such as turn types, classifications of roads at intersections along the route, road surface type, elevation change, road curvature, and a host of other considerations can be important.  It is also important to note that different costing considerations are needed for bicycle routing than pedestrian routing or automobile routing.</p>"},{"location":"sif/dynamic-costing/#dynamic-costing","title":"Dynamic Costing","text":"<p>Valhalla uses dynamic, run-time costing when computing route paths and can consider much more than strict time or distance. Different route types can be computed from a single set of route data tiles. There is no need to configure data each time a new routing profile is needed. Simply change the costing methods or apply different options to existing costing methods, the data stays the same.</p>"},{"location":"sif/dynamic-costing/#costing-interface","title":"Costing Interface","text":"<p>Costing methods have access to all attributes of an edge (road section between 2 intersections) to form the cost along the edge and when transitioning between edges. Within Sif, costing methods are created by deriving a class from the base dynamic costing class or one of the existing costing classes. Each costing method must override 3 different methods to create the unique costing logic:</p> <pre><code>virtual bool Allowed(const baldr::NodeInfo* node) const = 0;\n</code></pre> <p>Checks if access is allowed for the provided node. For example, node access can be restricted for specific modes of travel if bollards are present.</p> <pre><code>virtual bool Allowed(const baldr::DirectedEdge* edge, const EdgeLabel&amp; pred) const = 0;\n</code></pre> <p>Checks if access is allowed for the provided directed edge based on the prior edge along the path. This is generally based on mode of travel and the access modes allowed on the edge. It can also be used to prohibit turns where turn restrictions exist, prohibit Uturns, and to prohibit entering roads that do not have through paths.</p> <pre><code>virtual Cost EdgeCost(const baldr::DirectedEdge* edge, const uint32_t density) const = 0;\n</code></pre> <p>This method gets the cost to traverse the specified directed edge. Cost includes a path cost along with the actual time (seconds) to traverse the edge. Path costs are generally time or distance and can include artificial cost penalties to avoid roads/edges with specific attributes. By returning the actual elapsed time in seconds the costing method can be applied to time dependent and schedule based routing (e.g. transit).</p> <p>Costing methods can also compute edge transition costs, sometimes called turn costs. These costs are applied at the node/intersection when transitioning from one edge to another. A fourth costing method can be defined in the costing class to account for this:</p> <pre><code>virtual Cost TransitionCost(const baldr::DirectedEdge* edge, const baldr::NodeInfo* node,\n                            const EdgeLabel&amp; pred) const;\n</code></pre> <p>Edge transition costs generally consider 3 things:</p> <ul> <li>Turn type - whether the turn is a left turn, right turn, or is crossing another road. The cost applied to the turn type also needs to know if driving is done on the left side or right side of the road. While left turns are generally more costly in the US than right turns, the opposite holds in UK.</li> <li>Likelihood of stopping - higher costs should be applied where there is a high likelihood of stopping when going from one road to another. Examples are when crossing a higher class road while on a lower class road. The opposite occurs when on a higher class road - transitions at intersections with lower class roads usually do not require a stop.</li> <li>Name consistency - this one is less intuitive. By applying small cost penalties when going from a road with one name onto one with a different name can lead to \"simpler\" route paths where there are less maneuvers or turns that need description.</li> </ul> <p>In addition to these general cases, edge transition costing can be used to apply penalties for specific cases like crossing a country border, going onto a toll road, entering a road that has private access, and other cases where the route path might want to avoid specific roads or types of conditions!</p> <p>A good example of how edge transition costs can affect a route path is a driving route in a gridded downtown area. A shortest time or distance path can make many different turns as it zig-zags from the origin to the destination. Applying edge transition costs will reduce the number of turns and create a much simpler route that is often shorter time in practice. The first image below is without edge transition costs - it makes additional turns that complicate the path description. The second image shows the path with edge transition costs applied - there are fewer turns leading to a simpler route. Note also in the first image that the estimated time is much less - this shows how important edge transition costs are to estimating the time along a route.</p> <p></p> <p></p> <p>SIF costing for driving routes (auto) penalizes left hand turns more than right hand turns by default (in countries where driving occurs on the left hand side of the road the opposite occurs). The simple example below shows a case where a longer path is taken so that left turns are avoided. In this case, two right hand turns are made and the route is much longer (almost 700 meters rather than 100 meters).</p> <p></p>"},{"location":"sif/elevation_costing/","title":"Elevation influenced bicycle routing","text":""},{"location":"sif/elevation_costing/#elevation-influenced-bicycle-routing","title":"Elevation Influenced Bicycle Routing","text":"<p>Mapzen and the Valhalla team recently announced updates to their bicycle routing service: Bicycle Routing with Valhalla. Now we have taken it to greater heights by adding \"elevation influenced\" bicycle routing. We are pleased to announce the addition of elevation and grade factors into the bicycle costing model. How badly do you want to avoid those steep hills on your next ride!?</p> <p>Bicycle routing presents several unique challenges. Among the challenges are the wide range of user abilities, preferences, and equipment. Bicyclists vary in their experience and comfort level using roadways shared with larger vehicles (e.g. automobiles, buses, trucks). Different bicycle types are more or less suitable to the wide variety of road and path surfaces. The wide range of physical ability of bicyclists also comes into play when selecting routes in locations where hills and steep grades might be present. The Valhalla team at Mapzen feels these factors all play into one of the strengths of the Valhalla routing engine - its dynamic, run-time costing module known as Sif. Further background on Sif can be found in our prior blog post: Dynamic Costing in Valhalla.</p>"},{"location":"sif/elevation_costing/#addition-of-elevation-factors-into-valhalla-routing-tiles","title":"Addition of Elevation Factors into Valhalla Routing Tiles","text":"<p>In order to measure the change in elevation over a given segment of road, we've built a library (and service) called Skadi; the goddess of the mountains. Skadi has the ability to efficiently query world-wide digital elevation model data. We use this library when building routing tiles to estimate the prevaling grade/slope of a given section of road. We call this the weighted grade. Here's how it works.</p> <p></p> <p>Given a segment of road, we evenly sample points (at 60m apart) along it. At each sample, we measure the elevation. We then compute the grade/slope between each pair of sample points and weight it using the above function. This is essentially a linear combination designed to approximate the overall grade/slope of a given segment of road. You'll notice that sections with higher upward slope are weighted more and that conversely higher downward slopes are weighted less.</p> <p>The intuition is that steeper sections will require more \"cost\" to traverse whether walking, biking or driving. If you're biking the unit of cost might be time, since you can't ride as fast up steep hills. When driving the unit of cost might be the fuel used to overcome inertia. In any case, we are attempting to measure approximately how much energy might be needed to traverse a given section of road so that we can minimize (or maximize!?) it, along with other factors, when computing your path!</p>"},{"location":"sif/elevation_costing/#adding-grade-factors-to-dynamic-costing","title":"Adding Grade Factors to Dynamic Costing","text":"<p>The weighted grade is used within bicycle costing in 2 ways:</p> <p>Weighted grade impacts the speed / resulting time along an edge. The default speed used for bicycle routing is assumed to be the average speed the bicyclist can mainatin on level grades over the length of the route. This speed is modulated based on the weighted grade: increased for grades indicating a descent, and decreased for uphill grades. The higher the weighting factor the steeper the \"average\" grade along the edge, resulting in a higher reduction of speed results. Thus, the weighted grade of an edge impacts the time along the edge and helps avoid steep grades. It also helps provide a better estimate of the actual time along the route. In general, routes with hills take longer than routes on level ground.</p> <p>A second use for weighted grade considers the bicyclists desire to avoid or use hills in the route. A single option called use_hills has been added to the Valhalla bicycle costing module. This option is similar to the use_roads option. It is a value from 0 to 1.0 indicating the bicyclists comfort level with hills and steep grades. A value of 1.0 indicates a strong, experienced cyclists who does not mind a path with hills. A value of 0.0 indicates the cyclist wishes to find paths that try to avoid hills. Based on this fact, extra cost (penalties) are applied to edges based on the grade. Note that penalties are applied to downhill grades as well! The old adage among cyclists is that what goes down, eventually must go up so after every long downhill there will eventually be a long uphill! </p>"},{"location":"sif/elevation_costing/#examples","title":"Examples","text":"<p>The following cases illustrate a set of hills I used to ride in my early days of cycling. This is an area near Ellicott City, MD starting at a point on Illchester Road along the Patapsco River and ending near the end of Illchester Road close to Montgomery Road. </p> <p>The shortest path is to head straight up Illchester Road. The problem is the initial part of the hill is roughly 16-18% for the first 400 meters. A hill-climb time trial race is held on this hill, so it is only for strong riders or those looking for a challenge. After the initial steep section, Illchester Road continues with a more gradual climb and then levels off. With a use_hills factor of 1.0 the shortest distance and shortest time path is taken - straight up the steep hill.</p> <p></p> <p>For those with less inclination to tackle steep grades, we can try to find an alternate path by setting the use_hills factor to 0.5. This might be for someone who doesn't want to go too far out of the way to avoid a hill. In this example the path avoids the steep section of Illchester Road, instead choosing a less steep uphill path (Bonnie Branch Road onto Beechwood Road then back onto Illchester) to get to the top of Illchester hill. Here the elevation slowly rises from 30 meters to 150 meters over approximately 2km. This is an average grade of 6% - still uphill but much less strenuous.</p> <p></p> <p>For a novice bicyclist or one who wishes to avoid hills, we can try a use_hills factor of 0.0. Here, a longer path up the more gradual climb along Bonnie Branch Road (approximately 5% average grade) is taken the entire way to Montgomery Road and then the path backtracks to get to the destination along Illchester Road. Here the route is nearly 1km longer than the shortest route (4.35km vs 3.5 km) and takes 3 minutes longer (14 minutes vs. 11 minutes), but with the extra cost penalties applied to the steeper grades the path ends up along the most gradual path out of the river valley.</p> <p></p> <p>The sample images here were created using a combination of Valhalla routing including the elevation influenced bicycle route API as well as the new Mapzen Elevation Service API to get the range/height profile information to create the elevation chart. The output route path information (an encoded string of latitude,longitude positions along the path) is sent directly to the elevation service to get the heights along the path for charting.</p>"},{"location":"test/gurka/","title":"Valhalla Gurka Tests","text":"<p>Test in <code>test/gurka/</code> directory are \"integration\" level tests.  They check the full pipeline from map parsing through to route / match / etc result generation.</p>"},{"location":"test/gurka/#test-structure","title":"Test structure","text":"<p>Inside the <code>test/gurka/</code> directory, every file called <code>test_*.cc</code> is built as a distinct executable.</p> <p>A file called <code>test/gurka/test_turns.cc</code> will end up as <code>build/test/gurka/gurka_turns</code>.</p>"},{"location":"test/gurka/#using-gurka","title":"Using Gurka","text":"<p>The <code>gurka.h</code> header provides helper functions for generating small test maps from ASCII art, building tiles from them, executing Valhalla API requests against those tiles, and helpers for checking parts of the API response for expected results.</p> <p>To create a new test:</p> <ol> <li>Create a file <code>test/gurka/test_&lt;your-test-name&gt;.cc</code>.</li> <li>Populate a test case.</li> </ol> <p>A minimal example test looks like this:</p> <pre><code>#include &lt;gtest/gtest.h&gt;\n#include \"gurka.h\"\n\nTEST(TestSuite, TestName) {\n\n    const std::string &amp;ascii_map = R\"(\n        A----B----C\n    )\";\n    const gurka::ways ways = {{\"ABC\", {{\"highway\", \"primary\"}}}};\n\n    auto map = gurka::buildtiles(ascii_map, 100, ways, {}, {}, \"test/data/example\");\n\n    auto result = gurka::route(map, \"A\", \"C\", \"auto\");\n\n    EXPECT_EQ(result.directions().routes_size(), 1);\n    EXPECT_EQ(result.directions().routes(0).legs_size(), 1);\n\n}\n</code></pre> <p>Note</p> <p>Some tests need the timezone db to be loaded. To build timezone db initially, you can run <code>make -j$(nproc) gurka_time_tracking</code>.</p>"},{"location":"test/gurka/#building-and-running","title":"Building and Running","text":"<p>After timezone exists in your <code>build/test/data</code> directory, you can:</p> <ul> <li> <p>Run tests individually by running <code>make run-gurka_example</code> or by running something like this:</p> <pre><code>./test/gurka/gurka_conditional_restrictions \\\n  --gtest_filter=ConditionalRestrictions.NoRestrictionAuto\n</code></pre> </li> <li> <p>Build and execute all integration tests with <code>make run-gurka</code>.</p> </li> </ul>"},{"location":"test/gurka/#how-to-construct-a-map","title":"How to construct a map","text":"<p>Check out Beginner's guide on OpenStreetMap Wiki to understand OSM data format.</p> <p>You need 4 things to build a test map.</p> <p>Step 1. Define the positions of OSM nodes on the map by drawing an ASCII representation.</p> <p>The map is interpreted as a 2D grid (see <code>gridsize</code> below). The letters <code>A-Za-z0-9</code> represent the nodes. Only node positions are interpreted from the ASCII grid, but you can use any other character to help give context (i.e. use <code>----</code> to indicate that two nodes will be connected by a way).</p> <p>Using C++ Raw String Literals (6) is an easy way to to draw multilinestring maps.</p> <p>Example:</p> <pre><code>const std::string ascii_map = R\"(\n    A---B---C     j\n        |        /\n    D---E---f---h\n)\";\n</code></pre> <p>Note</p> <p>Only the position of the <code>A-Za-z0-9</code> characters matter - other characters are ignored and are just helpful for describing your intent.</p> <p>Step 2. Define how the nodes are connected together as OSM ways.</p> <p>You need to build a <code>gurka::ways</code> object to represent the ways and relevant tags. This object has a <code>std::string</code> key which defines a sequence of nodes that are connected, then a <code>std::vector</code> of key/value pairs that describe the tags to go on a way. C++ initializer list syntax allows for a fairly compact expression of a list of ways and their tags.</p> <p>Example:</p> <pre><code>const gurka::ways ways = {\n    { \"ABC\",   // String referencing nodes to be connected in order\n      { {\"highway\",\"motorway\"},  // key/value tags to be put on the way\n        {\"access\",\"none\"},\n        {\"name\",\"Test Road\"} }\n    },\n    { \"BE\",\n      { {\"highway\",\"motorway\"},\n        {\"access\",\"none\"},\n        {\"name\",\"Test Connector\"} }\n    },\n    ...\n};\n</code></pre> <p>Step 3. Define OSM tags on the nodes, if any.</p> <p>Here, you need a <code>gurka::nodes</code> object. Construction is identical to the <code>gurka::ways</code> object, except that the primary key should just be a single character (not a <code>char</code>, but a 1-character <code>std::string</code>).</p> <pre><code>const gurka::nodes nodes = {\n    { \"A\",   // String referencing nodes to be connected in order\n      { {\"barrier\", \"block\"} } // key/value tags to put on the node\n    },\n    ...\n};\n</code></pre> <p>Step 4. Define a list of OSM relations.</p> <p>A common example is a restriction relation, which restricts possible maneuvers. You need to build a <code>gurka::relation</code> object. Construction here is a little more complex, but C++ initializer list syntax still works (get used to lots of <code>{}</code>).</p> <pre><code>const gurka::relations relations = {\n    {\n        { // List of the members on the relation\n            gurka::relation_member{gurka::way_member, \"kh\", \"from\"},\n            gurka::relation_member{gurka::way_member, \"il\", \"to\"},\n            gurka::relation_member{gurka::way_member, \"hi\", \"via\"}\n        },\n        { // List of the key/value tags on the relation\n            {\"type\", \"restriction\"},\n            {\"restriction\", \"no_right_turn\"}\n        }\n    },\n    ...\n};\n</code></pre> <p>Once you have all these elements, you can now use them to build an OSM PBF file, and generate tiles for it, using:</p> <pre><code>auto map = gurka::buildtiles(ascii_map, 100, ways, nodes, relations, \"test/data/example\");\n</code></pre> <p>The <code>map.pbf</code> and tiles will be written to <code>test/data/example</code>. The value <code>100</code> is the size of the grid to be used. It's in meters, and decides the distance between the nodes in the ASCII map.</p> <p>The returned <code>map</code> object has two properties:</p> <ul> <li><code>config</code> - the <code>boost::property_tree</code> that was used to generate the tiles.</li> <li><code>nodes</code> - an <code>std::unordered_map</code>, where keys are nodes, and values are corresponding <code>PointLL</code> coordinates on a generated map.</li> </ul>"},{"location":"test/gurka/#using-a-generated-map","title":"Using a generated map","text":"<p>Once you have map tiles, you can use them in tests. Gurka provides helpers to make it easy to perform some normal interactions.</p> <pre><code>valhalla::Api\nroute(const gurka::map&amp; map,\n      const std::vector&lt;std::string&gt;&amp; waypoints,\n      const std::string&amp; costing);\n</code></pre> <p>This performs a route request on the map. You can use named waypoints that you've drawn on the map as positions to route between.</p> <pre><code>valhalla::Api\nmatch(const gurka::map&amp; map,\n      const std::vector&lt;std::string&gt;&amp; waypoints,\n      const bool break_at_waypoints,\n      const std::string&amp; costing);\n</code></pre> <p>This performs a trace request with the waypoints provided. You can toggle the <code>type: break</code> parameter by setting <code>break_at_waypoints</code>.</p>"},{"location":"test/gurka/#assertions","title":"Assertions","text":"<p>Gurka provides helper functions to make it easy to test various aspects of an API response.</p>"},{"location":"test/gurka/#gurkaassertraw","title":"<code>gurka::assert::raw</code>","text":"<p>By default, <code>gurka::route</code> and <code>gurka::match</code> functions return a <code>valhalla::Api</code> object, which is the raw Protocol Buffers object that Valhalla passes around. You can check some things directly on this with the helpers in the <code>gurka::assert::raw</code> namespace.</p> <pre><code>// namespace gurka::assert::raw\n\nvoid expect_maneuvers(\n    const valhalla::Api&amp; result,\n    const std::vector&lt;valhalla::DirectionsLeg_Maneuver_Type&gt;&amp; expected_maneuvers);\n\nvoid expect_maneuver_begin_path_indexes(\n    const valhalla::Api&amp; result,\n    const std::vector&lt;uint32_t&gt;&amp; expected_indexes);\n\nvoid expect_instructions_at_maneuver_index(\n    const valhalla::Api&amp; result,\n    int maneuver_index,\n    const std::string&amp; expected_text_instruction,\n    const std::string&amp; expected_verbal_transition_alert_instruction,\n    const std::string&amp; expected_verbal_pre_transition_instruction,\n    const std::string&amp; expected_verbal_post_transition_instruction);\n\nvoid expect_path_length(const valhalla::Api&amp; result,\n                        const float expected_length_km,\n                        const float error_margin = 0);\n\nvoid expect_path(const valhalla::Api&amp; result,\n                 const std::vector&lt;std::string&gt;&amp; expected_names);\n</code></pre>"},{"location":"test/gurka/#gurkaassertosrm","title":"<code>gurka::assert::osrm</code>","text":"<p>Valhalla can also return responses in OSRM-compatible format. To test that results contain things you expect when serialized to OSRM form, you can use the helpers in the <code>gurka::assert::osrm</code> namespace. These functions will first serialize the raw <code>valhalla::Api</code> object into a JSON document (using <code>tyr::serializeDirections</code>), then perform assertions within the JSON document only.</p> <pre><code>// namespace gurka::assert::osrm\n\nvoid expect_steps(valhalla::Api&amp; raw_result,\n                  const std::vector&lt;std::string&gt;&amp; expected_names,\n                  bool dedupe = true);\n\nvoid expect_match(valhalla::Api&amp; raw_result,\n                  const std::vector&lt;std::string&gt;&amp; expected_names,\n                  bool dedupe = true);\n</code></pre>"},{"location":"test/gurka/#utility-functions","title":"Utility functions","text":"<p>The main purpose of Gurka is to write high-level, end-to-end tests on minimaps. There are some low-level helper functions available in case you want to do something a little more custom:</p> <ul> <li><code>gurka::detail::build_config(workdir)</code> - builds a <code>boost::property_tree</code> for tile generation in <code>workdir</code>.</li> <li><code>gurka::detail::map_to_coordinates(ascii_map, gridsize)</code> - calculates coordinates for all the <code>A-Za-z0-9</code> nodes in the <code>ascii_map</code> given the <code>gridsize</code>.</li> <li><code>gurka::detail::build_pbf(node_locations, ways, nodes, relations, pbf_filename)</code> - generates an OSM PBF for the nodes, ways, and relations you've defined. The <code>nodemap</code> is the result of <code>gurka::detail::map_to_coordinates</code>.</li> </ul>"},{"location":"test/gurka/#debugging-help","title":"Debugging help","text":"<p>You can print your gurka map and visually inspect it at geojson.io by dumping out the GeoJSON via <code>dump_geojson_graph</code> function:</p> <pre><code>auto result = gurka::do_action(valhalla::Options::route, map, {\"1\", \"3\"}, \"auto\");\nstd::cout &lt;&lt; gurka::dump_geojson_graph(map) &lt;&lt; std::endl;\n</code></pre> <p>The graph expansion can be visually inspected with the expansion demo by calling the expansion action. Copy the GeoJSON into the expansion demo and move the slider via the arrow keys.</p> <pre><code>auto result = gurka::do_action(\n    valhalla::Options::expansion, map, {\"1\", \"3\"}, \"auto\");\n</code></pre>"},{"location":"thor/isochrones/","title":"Isochrones","text":""},{"location":"thor/isochrones/#what-are-isochrone-maps","title":"What are Isochrone Maps?","text":"<p>Recently valhalla has gained the ability to return these amazing structures called isochrones. What's an isochrone? The word is a combination of two greek roots <code>iso</code> meaning equal and <code>chrono</code> meaning time. So indeed, an isochrone is a structure representing equal time. In our case it's a line that represents constant travel time about a given location. One can think of isochrone maps as somewhat similar to the familiar topographic maps except that instead of lines of constant height, lines are of constant travel time are depicted. For this reason other terms common in topography apply such as contours or isolines.</p> <p> In this image the green, yellow, orange and red contour lines represent 15, 30, 45 and 60 minutes of driving time respectively.</p>"},{"location":"thor/isochrones/#how-are-isochrone-maps-useful","title":"How are Isochrone Maps Useful?","text":"<p>Isochrone maps can be used to make informed decisions about travel at both an individual level and en masse. You can get quantitative answers to questions like:</p> <ul> <li>What are our lunch options within 5 minutes from here?</li> <li>How much of the city lives within walking range of public transit?</li> <li>What would adding/removing this road/bus stop/bridge do to travel times?</li> <li>Where can I find housing that still has a reasonable commute to the office?</li> </ul> <p>In other words planning departments of DOTs all the way down to consumer applications will have use-cases that call for such an isochrone map service.</p>"},{"location":"thor/isochrones/#technical-details","title":"Technical Details","text":"<p>Isochrones are formed in Valhalla by first creating a 2-D grid in latitiude,longitude about the location. This 2-D grid or array is used to define the time or cost it takes to get from the target location to each other grid location. This grid is populated by doing a breadth-first, least-cost first search (basically Dijkstra) from the origin location. At each iteration, the grid cells that are touched by a road segment or graph edge are marked with the time and cost from the origin, if less than the currently marked time. Once the expansion of the graph exceeds the maximum isochrone contour time the grid-marking process terminates. This leaves a 2-D grid or array that has the time or cost to reach each grid location.</p> <p>The 2-D grid is used to find the isocrhone contours by using a well-known contouring method developed by Paul Bourke in the 1980s: contouring. This method finds grid cells that have neighboring cells where values lie on opposing sides of the contour value: for example the current cell has a time value above the contour value and a neighbor has a time value below the contour value. The contouring algorithm generates line segments through grid cells corners or centers based on several possible cases. The tricky part is pieceing these line segments together to form closed contour lines.</p> <p>After forming sets of contour polygons, KEVIN -please write a paragraph or 2 to describe how the contours are formed and output!</p> <p>This 2-D grid can be useful for other purposes as well. It provides a very fast way to query a single location to see how long it takes to get there from the test location. Ultimately this could be a way to do very large one-to-many matrices.</p>"},{"location":"thor/isochrones/#where-is-it","title":"Where is it?","text":"<p>You can find the API documentation here and you see a live demo of it right here.</p>"},{"location":"thor/path-algorithm/","title":"Path algorithm","text":""},{"location":"thor/path-algorithm/#thor-determining-the-best-path","title":"Thor - Determining the Best Path","text":"<p>Two core components of the Valhalla open source routing engine are Thor and Sif. These 2 companions (in Norse mythology Thor and Sif are husband and wife) form the basis of Valhalla's path generation algorithm. Thor contains the path computation algorithms and traverses the routing tiles, while Sif performs costing that is central to forming the best path. Rather than baking costs into the routing graph data, Valhalla uses dynamic, run-time costing to generate costs based on a rich set of attributes stored in the routing graph tiles. This allows run-time generation of different types of routes (or routes with different characteristics) simply by using different costing methods and options within those methods.</p>"},{"location":"thor/path-algorithm/#path-algorithm-introduction","title":"Path Algorithm Introduction","text":"<p>Routing from one location to another is solved by a class of algorithms known as shortest path algorithms. This is somewhat misleading, as often one is interested in a route that is shortest time or one that makes fewer turns. A better term for shortest path algorithms is least cost algorithms - this properly indicates that the method is minimizing cost, be it distance, time, or some other metric. Naive assignment of cost to edges of the routing graph will lead to poor routing solutions. Simple costing based solely on distance or on time (based solely on speed) can lead to poor route paths with excessive turns and stops. Considerations such as turn types, classifications of roads at intersections along the route, road surface type, elevation change, road curvature, and a host of other considerations can be important.  It is also important to note that different costing considerations are needed for bicycle routing than pedestrian routing or automobile routing. Dynamic costing is described here.</p> <p>Valhalla uses several levels of road hierarchies to enhance performance. The lowest level hierarchy is called the local level. The local level includes all roads and paths that are routable (using various access methods). The next hierarchy level is called arterial. This level drops out all paths and residential roads. The highest level is called the highway level. This level includes just motorways, trunk roads, and primary roads - these are roads needed for long routes. By transitioning to the higher hierarchy levels as the route path moves away from the origin or destination the path finding algorithm considers less roads - improving performance. Also, shortcut edges are formed on the arterial and highway hierarchies. These edges bypass intersections that only connect to lower hierarchy edges. This allows several edges to be combined into one longer edge, which also improves performance. </p> <p>Thor uses several different algorithms to compute the least cost path. These algorithms are described below.</p>"},{"location":"thor/path-algorithm/#a","title":"A*","text":"<p>The basic algorithm provided within Thor is an A* algorithm. This algorithm searches in one direction - from the origin towards the destination. The A* heuristic is added to the cost to help guide the search more rapidly towards the destination. The A* method has been superseded for most cases by the bidirectional A* algorithm which has better performance. Also, the A* algorithm does not work as well with transitions to upper hierarchy levels as the path approaches the destination.</p>"},{"location":"thor/path-algorithm/#bidirectional-a","title":"Bidirectional A*","text":"<p>The primary algorithm used for most types of routes is a bidirectional A* method. This algorithm searches for the lowest cost path in two directions: one from the origin towards the destination and the other \"backwards\" from the destination towards the origin. This algorithm has better performance then the A* algorithm since it more effectively cuts the search space. However, there are some complexities added to handle the backwards progression from the destination to the origin. Turn restrictions and transition costing is more complicated. Also, the determination of the connection point between the two searches (determination of route completion) is more complex. Another strength of the bidirectional A* method is that hierarchy transitions near the destination are simplified. Currently bidirectional A* performs only invariant behaviour of traffic update, there is no algorithm implemented for correct evaluation of edge passing time.</p> <p>Pedestrian and bicycle routes use just the local graph hierarchy. They never transition to the arterial or highway levels and thus never use shortcut edges.</p> <p>The bidirectional A* algorithm makes use of edge markings that enter regions where no through path exists. These are areas of the routing graph that represent cul-de-sas, dead-end roads, and even larger communities where there is only one entrance. The search paths can exclude ever entering an edge that is marked as \"not-though\".</p>"},{"location":"thor/path-algorithm/#multi-modal","title":"Multi-modal","text":"<p>Multi-modal routes use an A* method that is enahanced to allow time-dependency and mode changes. Public transit information includes schedule information that find the next departure along directed edges between transit stops. Unique pairs of transit stops and routes create separate graph edges with a unique line-id to which departure schedules can be associated.</p>"},{"location":"thor/path-algorithm/#a-heuristic","title":"A* Heuristic","text":"<p>A simple class within Thor handles the A* heuristic computation. At the beginning of PathAlgorithm::GetBestPath the A* heuristic is initialized with the latitude, longitude of the destination and a costing factor to multiply distance estimates with. This factor needs to be tied to the costing model to multiply distance that will underestimate the cost to the destination, but keep close to a reasonable true cost so that performance is kept high. For example, in automobile costing the factor is based on the highest speed expected - thus any straight line distance estimate from a specific location will undersestimate the true cost on any path on real roads to get to the destination. Distance estimates are computed using a distance approximation method that computes a Euclidean distance using meters per degree of latitude and an estimate of meters per degree of longitude based on the destination latitude. This produces a close approximation of the arc distance along the surface of the earth while providing a distance measure that is locally stable (nearby locations will get consistent and close distance approximations).</p>"},{"location":"thor/path-algorithm/#edge-labeling","title":"Edge Labeling","text":"<p>Thor marks directed edges in the routing graph rather than nodes. This allows a node to be traversed multiple times in a route with different directed edges. This allows turn restrictions to be incorporated into the data and the path algorithm. This is demonstrated in the following example where a left turn is not allowed at an intersection. Rather the route must take a separate turn lane to the right and loop back through the intersection. The least cost path to the intersection node is to proceed straight. If the node were marked it would prevent traversing the node after using the turn lane since that path is higher cost. </p> <p>Each directed edge in the routing graph can have three states:</p> <ul> <li>Not Visited - An edge that is not visited has not yet been encountered within the PathAlgorithm graph traversal.</li> <li>Temporary - An edge that has been visited or encountered but there could still be a lower cost path to this edge. This edge will be \"adjacent\" or connected to an edge that is permanently labeled. Temporary edges are noted in the Adjacency List and are sorted such that they are \"expanded\" in order of lowest cost.</li> <li>Permanent - Lowest cost path to this edge has been found.</li> </ul> <p>Edges that have been visited are stored in a vector with an EdgeLabel structure that contains information about the path up to this edge. In particular the predecessor edge is stored. This allows the shortest path of directed edges to be constructed by using each edges predecessor information to walk the path backwards. Additional information about the path to get to the directed edge is also kept. This information includes:</p> <ul> <li>Edge Id - Graph Id of the edge.</li> <li>Opposing edge Id - Graph Id of the opposing edge (for bidirectional A*).</li> <li>End node - GraphId of the end node of the edge. This allows the expansion to occur by reading the node and not having to re-read the directed edge to find its end node.</li> <li>Cost - Cost and elapsed time in seconds along the path to this edge.</li> <li>Sort cost - Cost including includes A* heuristic. </li> <li>Distance - An estimate of the straight line distance to the destination.</li> <li>Predecessor edge - Index to the predecessor edge label information within the EdgeLabels list.</li> </ul> <p>Several other pieces of information about the prior edge are also kept to avoid having to re-read an edge. In addition, several transit specific attributes are added for multi-modal routes.</p>"},{"location":"thor/path-algorithm/#edge-status","title":"Edge Status","text":"<p>An unordered map (hash map) is used to identify the state of directed edges. The map contains tile id as key and array of EdgeStatusInfo which contains  index of the edge in the EdgeLabels vector and the current edge label state: kUnreachedOrReset, temporary or permanent. Whenever a new tile (new edge in previously unvisited tile) is encountered a new value in the map is inserted with key as tile id and EdgeStatusInfo array of length equal to number of directed edges in the tile as value, all directed edges in the new array are initialized with kUnreachedOrReset status.</p> <p>The index of edge in EdgeStatusInfo array is equal to it's id in the tile</p> <p>EdgeStatus is constructed given an initial size of the edge status map. To avoid rehashing the initial size should be large enough.</p> <ul> <li>Set - Sets the status of a directed edge given its GraphId.</li> <li>Update - Updates the status of a directed edge given its GraphId.</li> <li>Get - Gets the status info of a directed edge given its GraphId.</li> </ul>"},{"location":"thor/path-algorithm/#adjacency-list","title":"Adjacency List","text":"<p>The AdjacencyList class provides a sorting order to the edge labels that are marked as temporary and are adjacent to edges that have lowest cost path found. The adjacency list uses a bucket sort implementation for performance. An \"overflow\" bucket is maintained to allow reduced memory use - costs outside the current bucket range get placed into the overflow bucket and are moved into the low-level buckets as needed. The adjacency list stores indexes into a list (vector) of labels where complete cost and predecessor information are stored. The adjacency list simply provides a fast sorting method. Benchmarks show a marked improvement over using an STL priority_queue, even in cases where the overflow bucket is utilized.</p> <p>An AdjacencyList is constructed using a minimum cost (based on the A* heuristic distance from the origin location to the destination location), a range of costs held within the bucket sort, and a bucket size. All costs above mincost + range are stored in an \"overflow\" bucket. The following methods are provided in the AdjacencyList class:</p> <ul> <li>Add - Adds a label index to the sorted list. Adds it to the appropriate bucket given the sort cost. If the sortcost is greater than maxcost_ the label is placed in the overflow bucket. If the sortcost is &lt; the current bucket cost then the label is placed at the front of the current bucket (this prevents underflow).</li> <li>DecreaseCost - The specified label index now has a smaller cost.  Reorders it in the sorted bucket list.</li> <li>Clear - Clear all labels from from the adjacency list. Called at the start of the path finding algorithm,</li> <li>Remove - Removes the lowest cost label index from the sorted list.</li> <li>EmptyOverflow - Empties the overflow bucket by placing the label indexes into the low level buckets. This method is private and is called from the Remove method when needed.</li> </ul>"}]}