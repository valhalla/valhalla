apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Chart.Name }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "labels" . | indent 4 }}
  annotations:
    {{- include "annotations" . | indent 4 }}
spec:
  replicas: {{ .Values.replicas }}
  strategy:
    type: {{ .Values.strategy.type }}
    rollingUpdate:
      maxSurge: {{ .Values.strategy.surge }}
      maxUnavailable: {{ .Values.strategy.unavailable }}
  selector:
    matchLabels:
      app: {{ .Chart.Name }}
      release: {{ .Release.Name }}
  template:
    metadata:
      labels:
        {{- include "labels" . | indent 8 }}
        date: "{{ now | unixEpoch }}"
      annotations:
        {{- include "annotations" . | indent 8 }}
    spec:
      imagePullSecrets:
        - name: {{ .Chart.Name }}-registry
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000

      affinity:
        podAntiAffinity:      # Makes sure only one osrm-routing pod is scheduled on each valhalla node
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: "app"
                    operator: In
                    values:
                      - {{ .Chart.Name }}
              topologyKey: "kubernetes.io/hostname"   # Applies this rule to each node (i.e. each unique host name in the cluster)
      volumes:
        - name: graph-storage
          azureFile:
            secretName: {{ .Chart.Name }}-storage
            shareName: {{ .Values.graph.share.name }}
            readOnly: true
      containers:
        - name: valhalla
          image: {{ include "image" . }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          resources:
            limits:
              memory: {{ .Values.container.valhalla.resourceLimits.memory }}
              cpu: {{ .Values.container.valhalla.resourceLimits.cpu }}
            requests:
              memory: {{ .Values.container.valhalla.resourceRequests.memory }} # All the memory used by the routing service is shared, it requires almost nothing
              cpu: {{ .Values.container.valhalla.resourceRequests.cpu }}       # Routing can be parallelized, so we reserve all the CPU we can get
          securityContext:
            runAsUser: 1000
            runAsGroup: 1000
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
              add:
                - NET_BIND_SERVICE
          command: ["valhalla_service"]
          args: 
            - "/etc/valhalla/valhalla.json"
            - "{{ .Values.valhalla.numberOfThreads }}"
          ports:
            - containerPort: {{ .Values.container.valhalla.port }}
          volumeMounts:
            - mountPath: /data/valhalla
              name: graph-storage
          env:
            - name: DD_AGENT_HOST
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          livenessProbe:
            httpGet:
              path: /status
              port: {{ .Values.container.valhalla.port }}
            initialDelaySeconds: 10
            failureThreshold: 10
            timeoutSeconds: 5
          readinessProbe:
            httpGet:
              path: /status
              port: {{ .Values.container.valhalla.port }}
            initialDelaySeconds: 10
            failureThreshold: 10
            periodSeconds: 30
            timeoutSeconds: 5