// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#include "trip.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace valhalla {
constexpr TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : from_lanes_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , to_lanes_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , from_way_id_(uint64_t{0u}){}
struct TripLeg_LaneConnectivityDefaultTypeInternal {
  constexpr TripLeg_LaneConnectivityDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_LaneConnectivityDefaultTypeInternal() {}
  union {
    TripLeg_LaneConnectivity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
constexpr TripLeg_TrafficSegment::TripLeg_TrafficSegment(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : segment_id_(uint64_t{0u})
  , begin_percent_(0)
  , end_percent_(0)
  , starts_segment_(false)
  , ends_segment_(false){}
struct TripLeg_TrafficSegmentDefaultTypeInternal {
  constexpr TripLeg_TrafficSegmentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_TrafficSegmentDefaultTypeInternal() {}
  union {
    TripLeg_TrafficSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
constexpr TripLeg_Restriction::TripLeg_Restriction(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0u){}
struct TripLeg_RestrictionDefaultTypeInternal {
  constexpr TripLeg_RestrictionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_RestrictionDefaultTypeInternal() {}
  union {
    TripLeg_Restriction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
constexpr TripLeg_Edge::TripLeg_Edge(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_()
  , lane_connectivity_()
  , traffic_segment_()
  , turn_lanes_()
  , tagged_value_()
  , sign_(nullptr)
  , transit_route_info_(nullptr)
  , restriction_(nullptr)
  , length_km_(0)
  , speed_(0)
  , road_class_(0)

  , begin_heading_(0u)
  , end_heading_(0u)
  , begin_shape_index_(0u)
  , end_shape_index_(0u)
  , traversability_(0)

  , use_(0)

  , toll_(false)
  , unpaved_(false)
  , tunnel_(false)
  , bridge_(false)
  , surface_(0)

  , travel_mode_(0)

  , roundabout_(false)
  , internal_intersection_(false)
  , drive_on_left_(false)
  , bicycle_network_(false)
  , vehicle_type_(0)

  , pedestrian_type_(0)

  , bicycle_type_(0)

  , id_(uint64_t{0u})
  , transit_type_(0)

  , weighted_grade_(0)
  , way_id_(uint64_t{0u})
  , max_upward_grade_(0)
  , max_downward_grade_(0)
  , lane_count_(0u)
  , cycle_lane_(0)

  , sidewalk_(0)

  , density_(0u)
  , speed_limit_(0u)
  , truck_speed_(0)
  , mean_elevation_(0)
  , truck_route_(false)
  , has_time_restrictions_(false)
  , destination_only_(false)
  , is_urban_(false)
  , default_speed_(0)
  , source_along_edge_(0)
  , target_along_edge_(0)
  , sac_scale_(0)

  , shoulder_(false)
  , indoor_(false){}
struct TripLeg_EdgeDefaultTypeInternal {
  constexpr TripLeg_EdgeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_EdgeDefaultTypeInternal() {}
  union {
    TripLeg_Edge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
constexpr TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sign_(nullptr)
  , begin_heading_(0u)
  , prev_name_consistency_(false)
  , curr_name_consistency_(false)
  , driveability_(0)

  , cyclability_(0)

  , walkability_(0)

  , use_(0)

  , road_class_(0)

  , lane_count_(0u){}
struct TripLeg_IntersectingEdgeDefaultTypeInternal {
  constexpr TripLeg_IntersectingEdgeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_IntersectingEdgeDefaultTypeInternal() {}
  union {
    TripLeg_IntersectingEdge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
constexpr TripLeg_Cost::TripLeg_Cost(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seconds_(0)
  , cost_(0){}
struct TripLeg_CostDefaultTypeInternal {
  constexpr TripLeg_CostDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_CostDefaultTypeInternal() {}
  union {
    TripLeg_Cost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
constexpr TripLeg_PathCost::TripLeg_PathCost(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : elapsed_cost_(nullptr)
  , transition_cost_(nullptr){}
struct TripLeg_PathCostDefaultTypeInternal {
  constexpr TripLeg_PathCostDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_PathCostDefaultTypeInternal() {}
  union {
    TripLeg_PathCost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
constexpr TripLeg_Node::TripLeg_Node(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : intersecting_edge_()
  , recosts_()
  , time_zone_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , edge_(nullptr)
  , transit_platform_info_(nullptr)
  , transit_station_info_(nullptr)
  , transit_egress_info_(nullptr)
  , cost_(nullptr)
  , bss_info_(nullptr)
  , admin_index_(0u)
  , type_(0)

  , fork_(false){}
struct TripLeg_NodeDefaultTypeInternal {
  constexpr TripLeg_NodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_NodeDefaultTypeInternal() {}
  union {
    TripLeg_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
constexpr TripLeg_Admin::TripLeg_Admin(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : country_code_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , country_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_code_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct TripLeg_AdminDefaultTypeInternal {
  constexpr TripLeg_AdminDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_AdminDefaultTypeInternal() {}
  union {
    TripLeg_Admin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
constexpr TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : time_()
  , _time_cached_byte_size_(0)
  , length_()
  , _length_cached_byte_size_(0)
  , speed_()
  , _speed_cached_byte_size_(0)
  , speed_limit_()
  , _speed_limit_cached_byte_size_(0){}
struct TripLeg_ShapeAttributesDefaultTypeInternal {
  constexpr TripLeg_ShapeAttributesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_ShapeAttributesDefaultTypeInternal() {}
  union {
    TripLeg_ShapeAttributes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
constexpr TripLeg_Incident::TripLeg_Incident(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : metadata_(nullptr)
  , begin_shape_index_(0u)
  , end_shape_index_(0u){}
struct TripLeg_IncidentDefaultTypeInternal {
  constexpr TripLeg_IncidentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_IncidentDefaultTypeInternal() {}
  union {
    TripLeg_Incident _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
constexpr TripLeg_Closure::TripLeg_Closure(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct TripLeg_ClosureDefaultTypeInternal {
  constexpr TripLeg_ClosureDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_ClosureDefaultTypeInternal() {}
  union {
    TripLeg_Closure _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
constexpr TripLeg::TripLeg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : location_()
  , node_()
  , admin_()
  , incidents_()
  , algorithms_()
  , closures_()
  , shape_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , bbox_(nullptr)
  , shape_attributes_(nullptr)
  , osm_changeset_(uint64_t{0u})
  , trip_id_(uint64_t{0u})
  , leg_id_(0u)
  , leg_count_(0u){}
struct TripLegDefaultTypeInternal {
  constexpr TripLegDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLegDefaultTypeInternal() {}
  union {
    TripLeg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLegDefaultTypeInternal _TripLeg_default_instance_;
constexpr TripRoute::TripRoute(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : legs_(){}
struct TripRouteDefaultTypeInternal {
  constexpr TripRouteDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripRouteDefaultTypeInternal() {}
  union {
    TripRoute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripRouteDefaultTypeInternal _TripRoute_default_instance_;
constexpr Trip::Trip(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : routes_(){}
struct TripDefaultTypeInternal {
  constexpr TripDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripDefaultTypeInternal() {}
  union {
    Trip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace valhalla
namespace valhalla {
bool TripLeg_Node_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Node_Type_strings[15] = {};

static const char TripLeg_Node_Type_names[] =
  "kBikeShare"
  "kBollard"
  "kBorderControl"
  "kBuildingEntrance"
  "kElevator"
  "kGate"
  "kMotorwayJunction"
  "kParking"
  "kStreetIntersection"
  "kSumpBuster"
  "kTollBooth"
  "kTollGantry"
  "kTransitEgress"
  "kTransitPlatform"
  "kTransitStation";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Node_Type_entries[] = {
  { {TripLeg_Node_Type_names + 0, 10}, 7 },
  { {TripLeg_Node_Type_names + 10, 8}, 2 },
  { {TripLeg_Node_Type_names + 18, 14}, 10 },
  { {TripLeg_Node_Type_names + 32, 17}, 13 },
  { {TripLeg_Node_Type_names + 49, 9}, 14 },
  { {TripLeg_Node_Type_names + 58, 5}, 1 },
  { {TripLeg_Node_Type_names + 63, 17}, 9 },
  { {TripLeg_Node_Type_names + 80, 8}, 8 },
  { {TripLeg_Node_Type_names + 88, 19}, 0 },
  { {TripLeg_Node_Type_names + 107, 11}, 12 },
  { {TripLeg_Node_Type_names + 118, 10}, 3 },
  { {TripLeg_Node_Type_names + 128, 11}, 11 },
  { {TripLeg_Node_Type_names + 139, 14}, 4 },
  { {TripLeg_Node_Type_names + 153, 16}, 6 },
  { {TripLeg_Node_Type_names + 169, 15}, 5 },
};

static const int TripLeg_Node_Type_entries_by_number[] = {
  8, // 0 -> kStreetIntersection
  5, // 1 -> kGate
  1, // 2 -> kBollard
  10, // 3 -> kTollBooth
  12, // 4 -> kTransitEgress
  14, // 5 -> kTransitStation
  13, // 6 -> kTransitPlatform
  0, // 7 -> kBikeShare
  7, // 8 -> kParking
  6, // 9 -> kMotorwayJunction
  2, // 10 -> kBorderControl
  11, // 11 -> kTollGantry
  9, // 12 -> kSumpBuster
  3, // 13 -> kBuildingEntrance
  4, // 14 -> kElevator
};

const std::string& TripLeg_Node_Type_Name(
    TripLeg_Node_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Node_Type_entries,
          TripLeg_Node_Type_entries_by_number,
          15, TripLeg_Node_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Node_Type_entries,
      TripLeg_Node_Type_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Node_Type_strings[idx].get();
}
bool TripLeg_Node_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Node_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Node_Type_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Node_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node::kGate;
constexpr TripLeg_Node_Type TripLeg_Node::kBollard;
constexpr TripLeg_Node_Type TripLeg_Node::kTollBooth;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitEgress;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitStation;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
constexpr TripLeg_Node_Type TripLeg_Node::kBikeShare;
constexpr TripLeg_Node_Type TripLeg_Node::kParking;
constexpr TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
constexpr TripLeg_Node_Type TripLeg_Node::kBorderControl;
constexpr TripLeg_Node_Type TripLeg_Node::kTollGantry;
constexpr TripLeg_Node_Type TripLeg_Node::kSumpBuster;
constexpr TripLeg_Node_Type TripLeg_Node::kBuildingEntrance;
constexpr TripLeg_Node_Type TripLeg_Node::kElevator;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MIN;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MAX;
constexpr int TripLeg_Node::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Traversability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Traversability_strings[4] = {};

static const char TripLeg_Traversability_names[] =
  "kBackward"
  "kBoth"
  "kForward"
  "kNone";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Traversability_entries[] = {
  { {TripLeg_Traversability_names + 0, 9}, 2 },
  { {TripLeg_Traversability_names + 9, 5}, 3 },
  { {TripLeg_Traversability_names + 14, 8}, 1 },
  { {TripLeg_Traversability_names + 22, 5}, 0 },
};

static const int TripLeg_Traversability_entries_by_number[] = {
  3, // 0 -> kNone
  2, // 1 -> kForward
  0, // 2 -> kBackward
  1, // 3 -> kBoth
};

const std::string& TripLeg_Traversability_Name(
    TripLeg_Traversability value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Traversability_entries,
          TripLeg_Traversability_entries_by_number,
          4, TripLeg_Traversability_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Traversability_entries,
      TripLeg_Traversability_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Traversability_strings[idx].get();
}
bool TripLeg_Traversability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Traversability* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Traversability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Traversability>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Traversability TripLeg::kNone;
constexpr TripLeg_Traversability TripLeg::kForward;
constexpr TripLeg_Traversability TripLeg::kBackward;
constexpr TripLeg_Traversability TripLeg::kBoth;
constexpr TripLeg_Traversability TripLeg::Traversability_MIN;
constexpr TripLeg_Traversability TripLeg::Traversability_MAX;
constexpr int TripLeg::Traversability_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Use_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 20:
    case 21:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 40:
    case 41:
    case 42:
    case 43:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Use_strings[34] = {};

static const char TripLeg_Use_names[] =
  "kAlleyUse"
  "kBridlewayUse"
  "kBusUse"
  "kConstructionUse"
  "kCuldesacUse"
  "kCyclewayUse"
  "kDriveThruUse"
  "kDrivewayUse"
  "kEgressConnectionUse"
  "kElevatorUse"
  "kEmergencyAccessUse"
  "kEscalatorUse"
  "kFerryUse"
  "kFootwayUse"
  "kLivingStreetUse"
  "kMountainBikeUse"
  "kOtherUse"
  "kParkingAisleUse"
  "kPathUse"
  "kPedestrianCrossingUse"
  "kPedestrianUse"
  "kPlatformConnectionUse"
  "kRailFerryUse"
  "kRailUse"
  "kRampUse"
  "kRestAreaUse"
  "kRoadUse"
  "kServiceAreaUse"
  "kServiceRoadUse"
  "kSidewalkUse"
  "kStepsUse"
  "kTrackUse"
  "kTransitConnectionUse"
  "kTurnChannelUse";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Use_entries[] = {
  { {TripLeg_Use_names + 0, 9}, 5 },
  { {TripLeg_Use_names + 9, 13}, 29 },
  { {TripLeg_Use_names + 22, 7}, 51 },
  { {TripLeg_Use_names + 29, 16}, 43 },
  { {TripLeg_Use_names + 45, 12}, 9 },
  { {TripLeg_Use_names + 57, 12}, 20 },
  { {TripLeg_Use_names + 69, 13}, 8 },
  { {TripLeg_Use_names + 82, 12}, 4 },
  { {TripLeg_Use_names + 94, 20}, 52 },
  { {TripLeg_Use_names + 114, 12}, 33 },
  { {TripLeg_Use_names + 126, 19}, 7 },
  { {TripLeg_Use_names + 145, 13}, 34 },
  { {TripLeg_Use_names + 158, 9}, 41 },
  { {TripLeg_Use_names + 167, 11}, 25 },
  { {TripLeg_Use_names + 178, 16}, 10 },
  { {TripLeg_Use_names + 194, 16}, 21 },
  { {TripLeg_Use_names + 210, 9}, 40 },
  { {TripLeg_Use_names + 219, 16}, 6 },
  { {TripLeg_Use_names + 235, 8}, 27 },
  { {TripLeg_Use_names + 243, 22}, 32 },
  { {TripLeg_Use_names + 265, 14}, 28 },
  { {TripLeg_Use_names + 279, 22}, 53 },
  { {TripLeg_Use_names + 301, 13}, 42 },
  { {TripLeg_Use_names + 314, 8}, 50 },
  { {TripLeg_Use_names + 322, 8}, 1 },
  { {TripLeg_Use_names + 330, 12}, 30 },
  { {TripLeg_Use_names + 342, 8}, 0 },
  { {TripLeg_Use_names + 350, 15}, 31 },
  { {TripLeg_Use_names + 365, 15}, 11 },
  { {TripLeg_Use_names + 380, 12}, 24 },
  { {TripLeg_Use_names + 392, 9}, 26 },
  { {TripLeg_Use_names + 401, 9}, 3 },
  { {TripLeg_Use_names + 410, 21}, 54 },
  { {TripLeg_Use_names + 431, 15}, 2 },
};

static const int TripLeg_Use_entries_by_number[] = {
  26, // 0 -> kRoadUse
  24, // 1 -> kRampUse
  33, // 2 -> kTurnChannelUse
  31, // 3 -> kTrackUse
  7, // 4 -> kDrivewayUse
  0, // 5 -> kAlleyUse
  17, // 6 -> kParkingAisleUse
  10, // 7 -> kEmergencyAccessUse
  6, // 8 -> kDriveThruUse
  4, // 9 -> kCuldesacUse
  14, // 10 -> kLivingStreetUse
  28, // 11 -> kServiceRoadUse
  5, // 20 -> kCyclewayUse
  15, // 21 -> kMountainBikeUse
  29, // 24 -> kSidewalkUse
  13, // 25 -> kFootwayUse
  30, // 26 -> kStepsUse
  18, // 27 -> kPathUse
  20, // 28 -> kPedestrianUse
  1, // 29 -> kBridlewayUse
  25, // 30 -> kRestAreaUse
  27, // 31 -> kServiceAreaUse
  19, // 32 -> kPedestrianCrossingUse
  9, // 33 -> kElevatorUse
  11, // 34 -> kEscalatorUse
  16, // 40 -> kOtherUse
  12, // 41 -> kFerryUse
  22, // 42 -> kRailFerryUse
  3, // 43 -> kConstructionUse
  23, // 50 -> kRailUse
  2, // 51 -> kBusUse
  8, // 52 -> kEgressConnectionUse
  21, // 53 -> kPlatformConnectionUse
  32, // 54 -> kTransitConnectionUse
};

const std::string& TripLeg_Use_Name(
    TripLeg_Use value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Use_entries,
          TripLeg_Use_entries_by_number,
          34, TripLeg_Use_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Use_entries,
      TripLeg_Use_entries_by_number,
      34, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Use_strings[idx].get();
}
bool TripLeg_Use_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Use* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Use_entries, 34, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Use>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Use TripLeg::kRoadUse;
constexpr TripLeg_Use TripLeg::kRampUse;
constexpr TripLeg_Use TripLeg::kTurnChannelUse;
constexpr TripLeg_Use TripLeg::kTrackUse;
constexpr TripLeg_Use TripLeg::kDrivewayUse;
constexpr TripLeg_Use TripLeg::kAlleyUse;
constexpr TripLeg_Use TripLeg::kParkingAisleUse;
constexpr TripLeg_Use TripLeg::kEmergencyAccessUse;
constexpr TripLeg_Use TripLeg::kDriveThruUse;
constexpr TripLeg_Use TripLeg::kCuldesacUse;
constexpr TripLeg_Use TripLeg::kLivingStreetUse;
constexpr TripLeg_Use TripLeg::kServiceRoadUse;
constexpr TripLeg_Use TripLeg::kCyclewayUse;
constexpr TripLeg_Use TripLeg::kMountainBikeUse;
constexpr TripLeg_Use TripLeg::kSidewalkUse;
constexpr TripLeg_Use TripLeg::kFootwayUse;
constexpr TripLeg_Use TripLeg::kStepsUse;
constexpr TripLeg_Use TripLeg::kPathUse;
constexpr TripLeg_Use TripLeg::kPedestrianUse;
constexpr TripLeg_Use TripLeg::kBridlewayUse;
constexpr TripLeg_Use TripLeg::kPedestrianCrossingUse;
constexpr TripLeg_Use TripLeg::kElevatorUse;
constexpr TripLeg_Use TripLeg::kEscalatorUse;
constexpr TripLeg_Use TripLeg::kRestAreaUse;
constexpr TripLeg_Use TripLeg::kServiceAreaUse;
constexpr TripLeg_Use TripLeg::kOtherUse;
constexpr TripLeg_Use TripLeg::kFerryUse;
constexpr TripLeg_Use TripLeg::kRailFerryUse;
constexpr TripLeg_Use TripLeg::kConstructionUse;
constexpr TripLeg_Use TripLeg::kRailUse;
constexpr TripLeg_Use TripLeg::kBusUse;
constexpr TripLeg_Use TripLeg::kEgressConnectionUse;
constexpr TripLeg_Use TripLeg::kPlatformConnectionUse;
constexpr TripLeg_Use TripLeg::kTransitConnectionUse;
constexpr TripLeg_Use TripLeg::Use_MIN;
constexpr TripLeg_Use TripLeg::Use_MAX;
constexpr int TripLeg::Use_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Surface_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Surface_strings[8] = {};

static const char TripLeg_Surface_names[] =
  "kCompacted"
  "kDirt"
  "kGravel"
  "kImpassable"
  "kPath"
  "kPaved"
  "kPavedRough"
  "kPavedSmooth";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Surface_entries[] = {
  { {TripLeg_Surface_names + 0, 10}, 3 },
  { {TripLeg_Surface_names + 10, 5}, 4 },
  { {TripLeg_Surface_names + 15, 7}, 5 },
  { {TripLeg_Surface_names + 22, 11}, 7 },
  { {TripLeg_Surface_names + 33, 5}, 6 },
  { {TripLeg_Surface_names + 38, 6}, 1 },
  { {TripLeg_Surface_names + 44, 11}, 2 },
  { {TripLeg_Surface_names + 55, 12}, 0 },
};

static const int TripLeg_Surface_entries_by_number[] = {
  7, // 0 -> kPavedSmooth
  5, // 1 -> kPaved
  6, // 2 -> kPavedRough
  0, // 3 -> kCompacted
  1, // 4 -> kDirt
  2, // 5 -> kGravel
  4, // 6 -> kPath
  3, // 7 -> kImpassable
};

const std::string& TripLeg_Surface_Name(
    TripLeg_Surface value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Surface_entries,
          TripLeg_Surface_entries_by_number,
          8, TripLeg_Surface_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Surface_entries,
      TripLeg_Surface_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Surface_strings[idx].get();
}
bool TripLeg_Surface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Surface* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Surface_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Surface>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Surface TripLeg::kPavedSmooth;
constexpr TripLeg_Surface TripLeg::kPaved;
constexpr TripLeg_Surface TripLeg::kPavedRough;
constexpr TripLeg_Surface TripLeg::kCompacted;
constexpr TripLeg_Surface TripLeg::kDirt;
constexpr TripLeg_Surface TripLeg::kGravel;
constexpr TripLeg_Surface TripLeg::kPath;
constexpr TripLeg_Surface TripLeg::kImpassable;
constexpr TripLeg_Surface TripLeg::Surface_MIN;
constexpr TripLeg_Surface TripLeg::Surface_MAX;
constexpr int TripLeg::Surface_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_CycleLane_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_CycleLane_strings[4] = {};

static const char TripLeg_CycleLane_names[] =
  "kDedicated"
  "kNoCycleLane"
  "kSeparated"
  "kShared";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_CycleLane_entries[] = {
  { {TripLeg_CycleLane_names + 0, 10}, 2 },
  { {TripLeg_CycleLane_names + 10, 12}, 0 },
  { {TripLeg_CycleLane_names + 22, 10}, 3 },
  { {TripLeg_CycleLane_names + 32, 7}, 1 },
};

static const int TripLeg_CycleLane_entries_by_number[] = {
  1, // 0 -> kNoCycleLane
  3, // 1 -> kShared
  0, // 2 -> kDedicated
  2, // 3 -> kSeparated
};

const std::string& TripLeg_CycleLane_Name(
    TripLeg_CycleLane value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_CycleLane_entries,
          TripLeg_CycleLane_entries_by_number,
          4, TripLeg_CycleLane_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_CycleLane_entries,
      TripLeg_CycleLane_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_CycleLane_strings[idx].get();
}
bool TripLeg_CycleLane_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_CycleLane* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_CycleLane_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_CycleLane>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_CycleLane TripLeg::kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg::kShared;
constexpr TripLeg_CycleLane TripLeg::kDedicated;
constexpr TripLeg_CycleLane TripLeg::kSeparated;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MIN;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MAX;
constexpr int TripLeg::CycleLane_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_SacScale_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_SacScale_strings[7] = {};

static const char TripLeg_SacScale_names[] =
  "kAlpineHiking"
  "kDemandingAlpineHiking"
  "kDemandingMountainHiking"
  "kDifficultAlpineHiking"
  "kHiking"
  "kMountainHiking"
  "kNoSacScale";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_SacScale_entries[] = {
  { {TripLeg_SacScale_names + 0, 13}, 4 },
  { {TripLeg_SacScale_names + 13, 22}, 5 },
  { {TripLeg_SacScale_names + 35, 24}, 3 },
  { {TripLeg_SacScale_names + 59, 22}, 6 },
  { {TripLeg_SacScale_names + 81, 7}, 1 },
  { {TripLeg_SacScale_names + 88, 15}, 2 },
  { {TripLeg_SacScale_names + 103, 11}, 0 },
};

static const int TripLeg_SacScale_entries_by_number[] = {
  6, // 0 -> kNoSacScale
  4, // 1 -> kHiking
  5, // 2 -> kMountainHiking
  2, // 3 -> kDemandingMountainHiking
  0, // 4 -> kAlpineHiking
  1, // 5 -> kDemandingAlpineHiking
  3, // 6 -> kDifficultAlpineHiking
};

const std::string& TripLeg_SacScale_Name(
    TripLeg_SacScale value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_SacScale_entries,
          TripLeg_SacScale_entries_by_number,
          7, TripLeg_SacScale_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_SacScale_entries,
      TripLeg_SacScale_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_SacScale_strings[idx].get();
}
bool TripLeg_SacScale_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_SacScale* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_SacScale_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_SacScale>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_SacScale TripLeg::kNoSacScale;
constexpr TripLeg_SacScale TripLeg::kHiking;
constexpr TripLeg_SacScale TripLeg::kMountainHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingMountainHiking;
constexpr TripLeg_SacScale TripLeg::kAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDifficultAlpineHiking;
constexpr TripLeg_SacScale TripLeg::SacScale_MIN;
constexpr TripLeg_SacScale TripLeg::SacScale_MAX;
constexpr int TripLeg::SacScale_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TripLeg_Sidewalk_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Sidewalk_strings[4] = {};

static const char TripLeg_Sidewalk_names[] =
  "kBothSides"
  "kLeft"
  "kNoSidewalk"
  "kRight";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Sidewalk_entries[] = {
  { {TripLeg_Sidewalk_names + 0, 10}, 3 },
  { {TripLeg_Sidewalk_names + 10, 5}, 1 },
  { {TripLeg_Sidewalk_names + 15, 11}, 0 },
  { {TripLeg_Sidewalk_names + 26, 6}, 2 },
};

static const int TripLeg_Sidewalk_entries_by_number[] = {
  2, // 0 -> kNoSidewalk
  1, // 1 -> kLeft
  3, // 2 -> kRight
  0, // 3 -> kBothSides
};

const std::string& TripLeg_Sidewalk_Name(
    TripLeg_Sidewalk value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Sidewalk_entries,
          TripLeg_Sidewalk_entries_by_number,
          4, TripLeg_Sidewalk_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Sidewalk_entries,
      TripLeg_Sidewalk_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Sidewalk_strings[idx].get();
}
bool TripLeg_Sidewalk_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Sidewalk* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Sidewalk_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Sidewalk>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TripLeg_Sidewalk TripLeg::kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg::kLeft;
constexpr TripLeg_Sidewalk TripLeg::kRight;
constexpr TripLeg_Sidewalk TripLeg::kBothSides;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
constexpr int TripLeg::Sidewalk_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class TripLeg_LaneConnectivity::_Internal {
 public:
};

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.LaneConnectivity)
}
TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  from_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    from_lanes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_from_lanes().empty()) {
    from_lanes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_from_lanes(), 
      GetArenaForAllocation());
  }
  to_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    to_lanes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_to_lanes().empty()) {
    to_lanes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_to_lanes(), 
      GetArenaForAllocation());
  }
  from_way_id_ = from.from_way_id_;
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.LaneConnectivity)
}

inline void TripLeg_LaneConnectivity::SharedCtor() {
from_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  from_lanes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
to_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  to_lanes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
from_way_id_ = uint64_t{0u};
}

TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.LaneConnectivity)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_LaneConnectivity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  from_lanes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  to_lanes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TripLeg_LaneConnectivity::ArenaDtor(void* object) {
  TripLeg_LaneConnectivity* _this = reinterpret_cast< TripLeg_LaneConnectivity* >(object);
  (void)_this;
}
void TripLeg_LaneConnectivity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_LaneConnectivity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_LaneConnectivity::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.LaneConnectivity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  from_lanes_.ClearToEmpty();
  to_lanes_.ClearToEmpty();
  from_way_id_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_LaneConnectivity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 from_way_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          from_way_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string from_lanes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_from_lanes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string to_lanes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_to_lanes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_LaneConnectivity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.LaneConnectivity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 from_way_id = 1;
  if (this->_internal_from_way_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_from_way_id(), target);
  }

  // string from_lanes = 2;
  if (!this->_internal_from_lanes().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_from_lanes().data(), static_cast<int>(this->_internal_from_lanes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.from_lanes");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_from_lanes(), target);
  }

  // string to_lanes = 3;
  if (!this->_internal_to_lanes().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_to_lanes().data(), static_cast<int>(this->_internal_to_lanes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.LaneConnectivity.to_lanes");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_to_lanes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.LaneConnectivity)
  return target;
}

size_t TripLeg_LaneConnectivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.LaneConnectivity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string from_lanes = 2;
  if (!this->_internal_from_lanes().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_from_lanes());
  }

  // string to_lanes = 3;
  if (!this->_internal_to_lanes().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_to_lanes());
  }

  // uint64 from_way_id = 1;
  if (this->_internal_from_way_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_from_way_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_LaneConnectivity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_LaneConnectivity*>(
      &from));
}

void TripLeg_LaneConnectivity::MergeFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.LaneConnectivity)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_from_lanes().empty()) {
    _internal_set_from_lanes(from._internal_from_lanes());
  }
  if (!from._internal_to_lanes().empty()) {
    _internal_set_to_lanes(from._internal_to_lanes());
  }
  if (from._internal_from_way_id() != 0) {
    _internal_set_from_way_id(from._internal_from_way_id());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.LaneConnectivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_LaneConnectivity::IsInitialized() const {
  return true;
}

void TripLeg_LaneConnectivity::InternalSwap(TripLeg_LaneConnectivity* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &from_lanes_, lhs_arena,
      &other->from_lanes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &to_lanes_, lhs_arena,
      &other->to_lanes_, rhs_arena
  );
  swap(from_way_id_, other->from_way_id_);
}

std::string TripLeg_LaneConnectivity::GetTypeName() const {
  return "valhalla.TripLeg.LaneConnectivity";
}


// ===================================================================

class TripLeg_TrafficSegment::_Internal {
 public:
};

TripLeg_TrafficSegment::TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TrafficSegment)
}
TripLeg_TrafficSegment::TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&segment_id_, &from.segment_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&ends_segment_) -
    reinterpret_cast<char*>(&segment_id_)) + sizeof(ends_segment_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.TrafficSegment)
}

inline void TripLeg_TrafficSegment::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&segment_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ends_segment_) -
    reinterpret_cast<char*>(&segment_id_)) + sizeof(ends_segment_));
}

TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TrafficSegment)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_TrafficSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_TrafficSegment::ArenaDtor(void* object) {
  TripLeg_TrafficSegment* _this = reinterpret_cast< TripLeg_TrafficSegment* >(object);
  (void)_this;
}
void TripLeg_TrafficSegment::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_TrafficSegment::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_TrafficSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TrafficSegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&segment_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ends_segment_) -
      reinterpret_cast<char*>(&segment_id_)) + sizeof(ends_segment_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_TrafficSegment::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 segment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          segment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float begin_percent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          begin_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_percent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          end_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool starts_segment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          starts_segment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ends_segment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ends_segment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_TrafficSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TrafficSegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 segment_id = 1;
  if (this->_internal_segment_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_segment_id(), target);
  }

  // float begin_percent = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_begin_percent = this->_internal_begin_percent();
  uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_begin_percent(), target);
  }

  // float end_percent = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_percent = this->_internal_end_percent();
  uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_end_percent(), target);
  }

  // bool starts_segment = 4;
  if (this->_internal_starts_segment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_starts_segment(), target);
  }

  // bool ends_segment = 5;
  if (this->_internal_ends_segment() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_ends_segment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TrafficSegment)
  return target;
}

size_t TripLeg_TrafficSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TrafficSegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 segment_id = 1;
  if (this->_internal_segment_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_segment_id());
  }

  // float begin_percent = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_begin_percent = this->_internal_begin_percent();
  uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    total_size += 1 + 4;
  }

  // float end_percent = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_percent = this->_internal_end_percent();
  uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    total_size += 1 + 4;
  }

  // bool starts_segment = 4;
  if (this->_internal_starts_segment() != 0) {
    total_size += 1 + 1;
  }

  // bool ends_segment = 5;
  if (this->_internal_ends_segment() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_TrafficSegment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_TrafficSegment*>(
      &from));
}

void TripLeg_TrafficSegment::MergeFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TrafficSegment)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_segment_id() != 0) {
    _internal_set_segment_id(from._internal_segment_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_begin_percent = from._internal_begin_percent();
  uint32_t raw_begin_percent;
  memcpy(&raw_begin_percent, &tmp_begin_percent, sizeof(tmp_begin_percent));
  if (raw_begin_percent != 0) {
    _internal_set_begin_percent(from._internal_begin_percent());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_percent = from._internal_end_percent();
  uint32_t raw_end_percent;
  memcpy(&raw_end_percent, &tmp_end_percent, sizeof(tmp_end_percent));
  if (raw_end_percent != 0) {
    _internal_set_end_percent(from._internal_end_percent());
  }
  if (from._internal_starts_segment() != 0) {
    _internal_set_starts_segment(from._internal_starts_segment());
  }
  if (from._internal_ends_segment() != 0) {
    _internal_set_ends_segment(from._internal_ends_segment());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TrafficSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TrafficSegment::IsInitialized() const {
  return true;
}

void TripLeg_TrafficSegment::InternalSwap(TripLeg_TrafficSegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, ends_segment_)
      + sizeof(TripLeg_TrafficSegment::ends_segment_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, segment_id_)>(
          reinterpret_cast<char*>(&segment_id_),
          reinterpret_cast<char*>(&other->segment_id_));
}

std::string TripLeg_TrafficSegment::GetTypeName() const {
  return "valhalla.TripLeg.TrafficSegment";
}


// ===================================================================

class TripLeg_Restriction::_Internal {
 public:
};

TripLeg_Restriction::TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Restriction)
}
TripLeg_Restriction::TripLeg_Restriction(const TripLeg_Restriction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Restriction)
}

inline void TripLeg_Restriction::SharedCtor() {
type_ = 0u;
}

TripLeg_Restriction::~TripLeg_Restriction() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Restriction)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Restriction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Restriction::ArenaDtor(void* object) {
  TripLeg_Restriction* _this = reinterpret_cast< TripLeg_Restriction* >(object);
  (void)_this;
}
void TripLeg_Restriction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Restriction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Restriction::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Restriction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Restriction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Restriction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Restriction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Restriction)
  return target;
}

size_t TripLeg_Restriction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Restriction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Restriction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Restriction*>(
      &from));
}

void TripLeg_Restriction::MergeFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Restriction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Restriction::CopyFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Restriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Restriction::IsInitialized() const {
  return true;
}

void TripLeg_Restriction::InternalSwap(TripLeg_Restriction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(type_, other->type_);
}

std::string TripLeg_Restriction::GetTypeName() const {
  return "valhalla.TripLeg.Restriction";
}


// ===================================================================

class TripLeg_Edge::_Internal {
 public:
  static const ::valhalla::TripSign& sign(const TripLeg_Edge* msg);
  static const ::valhalla::TransitRouteInfo& transit_route_info(const TripLeg_Edge* msg);
  static const ::valhalla::TripLeg_Restriction& restriction(const TripLeg_Edge* msg);
};

const ::valhalla::TripSign&
TripLeg_Edge::_Internal::sign(const TripLeg_Edge* msg) {
  return *msg->sign_;
}
const ::valhalla::TransitRouteInfo&
TripLeg_Edge::_Internal::transit_route_info(const TripLeg_Edge* msg) {
  return *msg->transit_route_info_;
}
const ::valhalla::TripLeg_Restriction&
TripLeg_Edge::_Internal::restriction(const TripLeg_Edge* msg) {
  return *msg->restriction_;
}
void TripLeg_Edge::clear_name() {
  name_.Clear();
}
void TripLeg_Edge::clear_sign() {
  if (GetArenaForAllocation() == nullptr && sign_ != nullptr) {
    delete sign_;
  }
  sign_ = nullptr;
}
void TripLeg_Edge::clear_transit_route_info() {
  if (GetArenaForAllocation() == nullptr && transit_route_info_ != nullptr) {
    delete transit_route_info_;
  }
  transit_route_info_ = nullptr;
}
void TripLeg_Edge::clear_turn_lanes() {
  turn_lanes_.Clear();
}
void TripLeg_Edge::clear_tagged_value() {
  tagged_value_.Clear();
}
TripLeg_Edge::TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  name_(arena),
  lane_connectivity_(arena),
  traffic_segment_(arena),
  turn_lanes_(arena),
  tagged_value_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Edge)
}
TripLeg_Edge::TripLeg_Edge(const TripLeg_Edge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      name_(from.name_),
      lane_connectivity_(from.lane_connectivity_),
      traffic_segment_(from.traffic_segment_),
      turn_lanes_(from.turn_lanes_),
      tagged_value_(from.tagged_value_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sign()) {
    sign_ = new ::valhalla::TripSign(*from.sign_);
  } else {
    sign_ = nullptr;
  }
  if (from._internal_has_transit_route_info()) {
    transit_route_info_ = new ::valhalla::TransitRouteInfo(*from.transit_route_info_);
  } else {
    transit_route_info_ = nullptr;
  }
  if (from._internal_has_restriction()) {
    restriction_ = new ::valhalla::TripLeg_Restriction(*from.restriction_);
  } else {
    restriction_ = nullptr;
  }
  ::memcpy(&length_km_, &from.length_km_,
    static_cast<size_t>(reinterpret_cast<char*>(&indoor_) -
    reinterpret_cast<char*>(&length_km_)) + sizeof(indoor_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Edge)
}

inline void TripLeg_Edge::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sign_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&indoor_) -
    reinterpret_cast<char*>(&sign_)) + sizeof(indoor_));
}

TripLeg_Edge::~TripLeg_Edge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Edge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sign_;
  if (this != internal_default_instance()) delete transit_route_info_;
  if (this != internal_default_instance()) delete restriction_;
}

void TripLeg_Edge::ArenaDtor(void* object) {
  TripLeg_Edge* _this = reinterpret_cast< TripLeg_Edge* >(object);
  (void)_this;
}
void TripLeg_Edge::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Edge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.Clear();
  lane_connectivity_.Clear();
  traffic_segment_.Clear();
  turn_lanes_.Clear();
  tagged_value_.Clear();
  if (GetArenaForAllocation() == nullptr && sign_ != nullptr) {
    delete sign_;
  }
  sign_ = nullptr;
  if (GetArenaForAllocation() == nullptr && transit_route_info_ != nullptr) {
    delete transit_route_info_;
  }
  transit_route_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && restriction_ != nullptr) {
    delete restriction_;
  }
  restriction_ = nullptr;
  ::memset(&length_km_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&indoor_) -
      reinterpret_cast<char*>(&length_km_)) + sizeof(indoor_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Edge::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.StreetName name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_name(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float length_km = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          length_km_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.RoadClass road_class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_heading = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          begin_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_heading = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          end_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_shape_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          begin_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          end_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability traversability = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_traversability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Use use = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
        } else
          goto handle_unusual;
        continue;
      // bool toll = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          toll_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool unpaved = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          unpaved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool tunnel = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          tunnel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bridge = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          bridge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool roundabout = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          roundabout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool internal_intersection = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          internal_intersection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool drive_on_left = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          drive_on_left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Surface surface = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_surface(static_cast<::valhalla::TripLeg_Surface>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripSign sign = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TravelMode travel_mode = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_travel_mode(static_cast<::valhalla::TravelMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.VehicleType vehicle_type = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_vehicle_type(static_cast<::valhalla::VehicleType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.PedestrianType pedestrian_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pedestrian_type(static_cast<::valhalla::PedestrianType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BicycleType bicycle_type = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_bicycle_type(static_cast<::valhalla::BicycleType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitType transit_type = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_transit_type(static_cast<::valhalla::TransitType>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitRouteInfo transit_route_info = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_route_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 id = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 way_id = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          way_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float weighted_grade = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 229)) {
          weighted_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 max_upward_grade = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          max_upward_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_downward_grade = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          max_downward_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 lane_count = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          lane_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.CycleLane cycle_lane = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cycle_lane(static_cast<::valhalla::TripLeg_CycleLane>(val));
        } else
          goto handle_unusual;
        continue;
      // bool bicycle_network = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          bicycle_network_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Sidewalk sidewalk = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sidewalk(static_cast<::valhalla::TripLeg_Sidewalk>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 density = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          density_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 speed_limit = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          speed_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float truck_speed = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          truck_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool truck_route = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          truck_route_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_lane_connectivity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<314>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 mean_elevation = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          mean_elevation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_traffic_segment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<330>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TurnLane turn_lanes = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_turn_lanes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<338>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool has_time_restrictions = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          has_time_restrictions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float default_speed = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          default_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Restriction restriction = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_restriction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool destination_only = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          destination_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_urban = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          is_urban_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TaggedValue tagged_value = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tagged_value(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<386>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float source_along_edge = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          source_along_edge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float target_along_edge = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          target_along_edge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.SacScale sac_scale = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sac_scale(static_cast<::valhalla::TripLeg_SacScale>(val));
        } else
          goto handle_unusual;
        continue;
      // bool shoulder = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          shoulder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool indoor = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          indoor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Edge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Edge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_name_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_name(i), target, stream);
  }

  // float length_km = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_km = this->_internal_length_km();
  uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_length_km(), target);
  }

  // float speed = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_speed(), target);
  }

  // .valhalla.RoadClass road_class = 4;
  if (this->_internal_road_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_road_class(), target);
  }

  // uint32 begin_heading = 5;
  if (this->_internal_begin_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_begin_heading(), target);
  }

  // uint32 end_heading = 6;
  if (this->_internal_end_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_end_heading(), target);
  }

  // uint32 begin_shape_index = 7;
  if (this->_internal_begin_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 8;
  if (this->_internal_end_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_end_shape_index(), target);
  }

  // .valhalla.TripLeg.Traversability traversability = 9;
  if (this->_internal_traversability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_traversability(), target);
  }

  // .valhalla.TripLeg.Use use = 10;
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_use(), target);
  }

  // bool toll = 11;
  if (this->_internal_toll() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_toll(), target);
  }

  // bool unpaved = 12;
  if (this->_internal_unpaved() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_unpaved(), target);
  }

  // bool tunnel = 13;
  if (this->_internal_tunnel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_tunnel(), target);
  }

  // bool bridge = 14;
  if (this->_internal_bridge() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_bridge(), target);
  }

  // bool roundabout = 15;
  if (this->_internal_roundabout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_roundabout(), target);
  }

  // bool internal_intersection = 16;
  if (this->_internal_internal_intersection() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_internal_intersection(), target);
  }

  // bool drive_on_left = 17;
  if (this->_internal_drive_on_left() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_drive_on_left(), target);
  }

  // .valhalla.TripLeg.Surface surface = 18;
  if (this->_internal_surface() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      18, this->_internal_surface(), target);
  }

  // .valhalla.TripSign sign = 19;
  if (this->_internal_has_sign()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::sign(this), target, stream);
  }

  // .valhalla.TravelMode travel_mode = 20;
  if (this->_internal_travel_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      20, this->_internal_travel_mode(), target);
  }

  // .valhalla.VehicleType vehicle_type = 21;
  if (this->_internal_vehicle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      21, this->_internal_vehicle_type(), target);
  }

  // .valhalla.PedestrianType pedestrian_type = 22;
  if (this->_internal_pedestrian_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      22, this->_internal_pedestrian_type(), target);
  }

  // .valhalla.BicycleType bicycle_type = 23;
  if (this->_internal_bicycle_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      23, this->_internal_bicycle_type(), target);
  }

  // .valhalla.TransitType transit_type = 24;
  if (this->_internal_transit_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      24, this->_internal_transit_type(), target);
  }

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->_internal_has_transit_route_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::transit_route_info(this), target, stream);
  }

  // uint64 id = 26;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(26, this->_internal_id(), target);
  }

  // uint64 way_id = 27;
  if (this->_internal_way_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(27, this->_internal_way_id(), target);
  }

  // float weighted_grade = 28;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_weighted_grade = this->_internal_weighted_grade();
  uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(28, this->_internal_weighted_grade(), target);
  }

  // int32 max_upward_grade = 29;
  if (this->_internal_max_upward_grade() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_max_upward_grade(), target);
  }

  // int32 max_downward_grade = 30;
  if (this->_internal_max_downward_grade() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(30, this->_internal_max_downward_grade(), target);
  }

  // uint32 lane_count = 31;
  if (this->_internal_lane_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(31, this->_internal_lane_count(), target);
  }

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (this->_internal_cycle_lane() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      32, this->_internal_cycle_lane(), target);
  }

  // bool bicycle_network = 33;
  if (this->_internal_bicycle_network() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(33, this->_internal_bicycle_network(), target);
  }

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (this->_internal_sidewalk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      34, this->_internal_sidewalk(), target);
  }

  // uint32 density = 35;
  if (this->_internal_density() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(35, this->_internal_density(), target);
  }

  // uint32 speed_limit = 36;
  if (this->_internal_speed_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(36, this->_internal_speed_limit(), target);
  }

  // float truck_speed = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_truck_speed = this->_internal_truck_speed();
  uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(37, this->_internal_truck_speed(), target);
  }

  // bool truck_route = 38;
  if (this->_internal_truck_route() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(38, this->_internal_truck_route(), target);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_lane_connectivity_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, this->_internal_lane_connectivity(i), target, stream);
  }

  // int32 mean_elevation = 40;
  if (this->_internal_mean_elevation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(40, this->_internal_mean_elevation(), target);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_traffic_segment_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, this->_internal_traffic_segment(i), target, stream);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_turn_lanes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, this->_internal_turn_lanes(i), target, stream);
  }

  // bool has_time_restrictions = 43;
  if (this->_internal_has_time_restrictions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(43, this->_internal_has_time_restrictions(), target);
  }

  // float default_speed = 44;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_speed = this->_internal_default_speed();
  uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(44, this->_internal_default_speed(), target);
  }

  // .valhalla.TripLeg.Restriction restriction = 45;
  if (this->_internal_has_restriction()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        45, _Internal::restriction(this), target, stream);
  }

  // bool destination_only = 46;
  if (this->_internal_destination_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(46, this->_internal_destination_only(), target);
  }

  // bool is_urban = 47;
  if (this->_internal_is_urban() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(47, this->_internal_is_urban(), target);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tagged_value_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(48, this->_internal_tagged_value(i), target, stream);
  }

  // float source_along_edge = 49;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_source_along_edge = this->_internal_source_along_edge();
  uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(49, this->_internal_source_along_edge(), target);
  }

  // float target_along_edge = 50;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_target_along_edge = this->_internal_target_along_edge();
  uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(50, this->_internal_target_along_edge(), target);
  }

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  if (this->_internal_sac_scale() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      51, this->_internal_sac_scale(), target);
  }

  // bool shoulder = 52;
  if (this->_internal_shoulder() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(52, this->_internal_shoulder(), target);
  }

  // bool indoor = 53;
  if (this->_internal_indoor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(53, this->_internal_indoor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Edge)
  return target;
}

size_t TripLeg_Edge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  total_size += 1UL * this->_internal_name_size();
  for (const auto& msg : this->name_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  total_size += 2UL * this->_internal_lane_connectivity_size();
  for (const auto& msg : this->lane_connectivity_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  total_size += 2UL * this->_internal_traffic_segment_size();
  for (const auto& msg : this->traffic_segment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  total_size += 2UL * this->_internal_turn_lanes_size();
  for (const auto& msg : this->turn_lanes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TaggedValue tagged_value = 48;
  total_size += 2UL * this->_internal_tagged_value_size();
  for (const auto& msg : this->tagged_value_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .valhalla.TripSign sign = 19;
  if (this->_internal_has_sign()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sign_);
  }

  // .valhalla.TransitRouteInfo transit_route_info = 25;
  if (this->_internal_has_transit_route_info()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *transit_route_info_);
  }

  // .valhalla.TripLeg.Restriction restriction = 45;
  if (this->_internal_has_restriction()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *restriction_);
  }

  // float length_km = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_km = this->_internal_length_km();
  uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    total_size += 1 + 4;
  }

  // float speed = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // .valhalla.RoadClass road_class = 4;
  if (this->_internal_road_class() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_road_class());
  }

  // uint32 begin_heading = 5;
  if (this->_internal_begin_heading() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_heading());
  }

  // uint32 end_heading = 6;
  if (this->_internal_end_heading() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_end_heading());
  }

  // uint32 begin_shape_index = 7;
  if (this->_internal_begin_shape_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
  }

  // uint32 end_shape_index = 8;
  if (this->_internal_end_shape_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
  }

  // .valhalla.TripLeg.Traversability traversability = 9;
  if (this->_internal_traversability() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_traversability());
  }

  // .valhalla.TripLeg.Use use = 10;
  if (this->_internal_use() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_use());
  }

  // bool toll = 11;
  if (this->_internal_toll() != 0) {
    total_size += 1 + 1;
  }

  // bool unpaved = 12;
  if (this->_internal_unpaved() != 0) {
    total_size += 1 + 1;
  }

  // bool tunnel = 13;
  if (this->_internal_tunnel() != 0) {
    total_size += 1 + 1;
  }

  // bool bridge = 14;
  if (this->_internal_bridge() != 0) {
    total_size += 1 + 1;
  }

  // .valhalla.TripLeg.Surface surface = 18;
  if (this->_internal_surface() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_surface());
  }

  // .valhalla.TravelMode travel_mode = 20;
  if (this->_internal_travel_mode() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_travel_mode());
  }

  // bool roundabout = 15;
  if (this->_internal_roundabout() != 0) {
    total_size += 1 + 1;
  }

  // bool internal_intersection = 16;
  if (this->_internal_internal_intersection() != 0) {
    total_size += 2 + 1;
  }

  // bool drive_on_left = 17;
  if (this->_internal_drive_on_left() != 0) {
    total_size += 2 + 1;
  }

  // bool bicycle_network = 33;
  if (this->_internal_bicycle_network() != 0) {
    total_size += 2 + 1;
  }

  // .valhalla.VehicleType vehicle_type = 21;
  if (this->_internal_vehicle_type() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_vehicle_type());
  }

  // .valhalla.PedestrianType pedestrian_type = 22;
  if (this->_internal_pedestrian_type() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pedestrian_type());
  }

  // .valhalla.BicycleType bicycle_type = 23;
  if (this->_internal_bicycle_type() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_bicycle_type());
  }

  // uint64 id = 26;
  if (this->_internal_id() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_id());
  }

  // .valhalla.TransitType transit_type = 24;
  if (this->_internal_transit_type() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_transit_type());
  }

  // float weighted_grade = 28;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_weighted_grade = this->_internal_weighted_grade();
  uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    total_size += 2 + 4;
  }

  // uint64 way_id = 27;
  if (this->_internal_way_id() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_way_id());
  }

  // int32 max_upward_grade = 29;
  if (this->_internal_max_upward_grade() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_max_upward_grade());
  }

  // int32 max_downward_grade = 30;
  if (this->_internal_max_downward_grade() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_max_downward_grade());
  }

  // uint32 lane_count = 31;
  if (this->_internal_lane_count() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_lane_count());
  }

  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (this->_internal_cycle_lane() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cycle_lane());
  }

  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (this->_internal_sidewalk() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_sidewalk());
  }

  // uint32 density = 35;
  if (this->_internal_density() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_density());
  }

  // uint32 speed_limit = 36;
  if (this->_internal_speed_limit() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_speed_limit());
  }

  // float truck_speed = 37;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_truck_speed = this->_internal_truck_speed();
  uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    total_size += 2 + 4;
  }

  // int32 mean_elevation = 40;
  if (this->_internal_mean_elevation() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_mean_elevation());
  }

  // bool truck_route = 38;
  if (this->_internal_truck_route() != 0) {
    total_size += 2 + 1;
  }

  // bool has_time_restrictions = 43;
  if (this->_internal_has_time_restrictions() != 0) {
    total_size += 2 + 1;
  }

  // bool destination_only = 46;
  if (this->_internal_destination_only() != 0) {
    total_size += 2 + 1;
  }

  // bool is_urban = 47;
  if (this->_internal_is_urban() != 0) {
    total_size += 2 + 1;
  }

  // float default_speed = 44;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_speed = this->_internal_default_speed();
  uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    total_size += 2 + 4;
  }

  // float source_along_edge = 49;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_source_along_edge = this->_internal_source_along_edge();
  uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    total_size += 2 + 4;
  }

  // float target_along_edge = 50;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_target_along_edge = this->_internal_target_along_edge();
  uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    total_size += 2 + 4;
  }

  // .valhalla.TripLeg.SacScale sac_scale = 51;
  if (this->_internal_sac_scale() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_sac_scale());
  }

  // bool shoulder = 52;
  if (this->_internal_shoulder() != 0) {
    total_size += 2 + 1;
  }

  // bool indoor = 53;
  if (this->_internal_indoor() != 0) {
    total_size += 2 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Edge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Edge*>(
      &from));
}

void TripLeg_Edge::MergeFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  name_.MergeFrom(from.name_);
  lane_connectivity_.MergeFrom(from.lane_connectivity_);
  traffic_segment_.MergeFrom(from.traffic_segment_);
  turn_lanes_.MergeFrom(from.turn_lanes_);
  tagged_value_.MergeFrom(from.tagged_value_);
  if (from._internal_has_sign()) {
    _internal_mutable_sign()->::valhalla::TripSign::MergeFrom(from._internal_sign());
  }
  if (from._internal_has_transit_route_info()) {
    _internal_mutable_transit_route_info()->::valhalla::TransitRouteInfo::MergeFrom(from._internal_transit_route_info());
  }
  if (from._internal_has_restriction()) {
    _internal_mutable_restriction()->::valhalla::TripLeg_Restriction::MergeFrom(from._internal_restriction());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length_km = from._internal_length_km();
  uint32_t raw_length_km;
  memcpy(&raw_length_km, &tmp_length_km, sizeof(tmp_length_km));
  if (raw_length_km != 0) {
    _internal_set_length_km(from._internal_length_km());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _internal_set_speed(from._internal_speed());
  }
  if (from._internal_road_class() != 0) {
    _internal_set_road_class(from._internal_road_class());
  }
  if (from._internal_begin_heading() != 0) {
    _internal_set_begin_heading(from._internal_begin_heading());
  }
  if (from._internal_end_heading() != 0) {
    _internal_set_end_heading(from._internal_end_heading());
  }
  if (from._internal_begin_shape_index() != 0) {
    _internal_set_begin_shape_index(from._internal_begin_shape_index());
  }
  if (from._internal_end_shape_index() != 0) {
    _internal_set_end_shape_index(from._internal_end_shape_index());
  }
  if (from._internal_traversability() != 0) {
    _internal_set_traversability(from._internal_traversability());
  }
  if (from._internal_use() != 0) {
    _internal_set_use(from._internal_use());
  }
  if (from._internal_toll() != 0) {
    _internal_set_toll(from._internal_toll());
  }
  if (from._internal_unpaved() != 0) {
    _internal_set_unpaved(from._internal_unpaved());
  }
  if (from._internal_tunnel() != 0) {
    _internal_set_tunnel(from._internal_tunnel());
  }
  if (from._internal_bridge() != 0) {
    _internal_set_bridge(from._internal_bridge());
  }
  if (from._internal_surface() != 0) {
    _internal_set_surface(from._internal_surface());
  }
  if (from._internal_travel_mode() != 0) {
    _internal_set_travel_mode(from._internal_travel_mode());
  }
  if (from._internal_roundabout() != 0) {
    _internal_set_roundabout(from._internal_roundabout());
  }
  if (from._internal_internal_intersection() != 0) {
    _internal_set_internal_intersection(from._internal_internal_intersection());
  }
  if (from._internal_drive_on_left() != 0) {
    _internal_set_drive_on_left(from._internal_drive_on_left());
  }
  if (from._internal_bicycle_network() != 0) {
    _internal_set_bicycle_network(from._internal_bicycle_network());
  }
  if (from._internal_vehicle_type() != 0) {
    _internal_set_vehicle_type(from._internal_vehicle_type());
  }
  if (from._internal_pedestrian_type() != 0) {
    _internal_set_pedestrian_type(from._internal_pedestrian_type());
  }
  if (from._internal_bicycle_type() != 0) {
    _internal_set_bicycle_type(from._internal_bicycle_type());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  if (from._internal_transit_type() != 0) {
    _internal_set_transit_type(from._internal_transit_type());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_weighted_grade = from._internal_weighted_grade();
  uint32_t raw_weighted_grade;
  memcpy(&raw_weighted_grade, &tmp_weighted_grade, sizeof(tmp_weighted_grade));
  if (raw_weighted_grade != 0) {
    _internal_set_weighted_grade(from._internal_weighted_grade());
  }
  if (from._internal_way_id() != 0) {
    _internal_set_way_id(from._internal_way_id());
  }
  if (from._internal_max_upward_grade() != 0) {
    _internal_set_max_upward_grade(from._internal_max_upward_grade());
  }
  if (from._internal_max_downward_grade() != 0) {
    _internal_set_max_downward_grade(from._internal_max_downward_grade());
  }
  if (from._internal_lane_count() != 0) {
    _internal_set_lane_count(from._internal_lane_count());
  }
  if (from._internal_cycle_lane() != 0) {
    _internal_set_cycle_lane(from._internal_cycle_lane());
  }
  if (from._internal_sidewalk() != 0) {
    _internal_set_sidewalk(from._internal_sidewalk());
  }
  if (from._internal_density() != 0) {
    _internal_set_density(from._internal_density());
  }
  if (from._internal_speed_limit() != 0) {
    _internal_set_speed_limit(from._internal_speed_limit());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_truck_speed = from._internal_truck_speed();
  uint32_t raw_truck_speed;
  memcpy(&raw_truck_speed, &tmp_truck_speed, sizeof(tmp_truck_speed));
  if (raw_truck_speed != 0) {
    _internal_set_truck_speed(from._internal_truck_speed());
  }
  if (from._internal_mean_elevation() != 0) {
    _internal_set_mean_elevation(from._internal_mean_elevation());
  }
  if (from._internal_truck_route() != 0) {
    _internal_set_truck_route(from._internal_truck_route());
  }
  if (from._internal_has_time_restrictions() != 0) {
    _internal_set_has_time_restrictions(from._internal_has_time_restrictions());
  }
  if (from._internal_destination_only() != 0) {
    _internal_set_destination_only(from._internal_destination_only());
  }
  if (from._internal_is_urban() != 0) {
    _internal_set_is_urban(from._internal_is_urban());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_default_speed = from._internal_default_speed();
  uint32_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    _internal_set_default_speed(from._internal_default_speed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_source_along_edge = from._internal_source_along_edge();
  uint32_t raw_source_along_edge;
  memcpy(&raw_source_along_edge, &tmp_source_along_edge, sizeof(tmp_source_along_edge));
  if (raw_source_along_edge != 0) {
    _internal_set_source_along_edge(from._internal_source_along_edge());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_target_along_edge = from._internal_target_along_edge();
  uint32_t raw_target_along_edge;
  memcpy(&raw_target_along_edge, &tmp_target_along_edge, sizeof(tmp_target_along_edge));
  if (raw_target_along_edge != 0) {
    _internal_set_target_along_edge(from._internal_target_along_edge());
  }
  if (from._internal_sac_scale() != 0) {
    _internal_set_sac_scale(from._internal_sac_scale());
  }
  if (from._internal_shoulder() != 0) {
    _internal_set_shoulder(from._internal_shoulder());
  }
  if (from._internal_indoor() != 0) {
    _internal_set_indoor(from._internal_indoor());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Edge::IsInitialized() const {
  return true;
}

void TripLeg_Edge::InternalSwap(TripLeg_Edge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  name_.InternalSwap(&other->name_);
  lane_connectivity_.InternalSwap(&other->lane_connectivity_);
  traffic_segment_.InternalSwap(&other->traffic_segment_);
  turn_lanes_.InternalSwap(&other->turn_lanes_);
  tagged_value_.InternalSwap(&other->tagged_value_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, indoor_)
      + sizeof(TripLeg_Edge::indoor_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Edge, sign_)>(
          reinterpret_cast<char*>(&sign_),
          reinterpret_cast<char*>(&other->sign_));
}

std::string TripLeg_Edge::GetTypeName() const {
  return "valhalla.TripLeg.Edge";
}


// ===================================================================

class TripLeg_IntersectingEdge::_Internal {
 public:
  static const ::valhalla::TripSign& sign(const TripLeg_IntersectingEdge* msg);
};

const ::valhalla::TripSign&
TripLeg_IntersectingEdge::_Internal::sign(const TripLeg_IntersectingEdge* msg) {
  return *msg->sign_;
}
void TripLeg_IntersectingEdge::clear_sign() {
  if (GetArenaForAllocation() == nullptr && sign_ != nullptr) {
    delete sign_;
  }
  sign_ = nullptr;
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.IntersectingEdge)
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sign()) {
    sign_ = new ::valhalla::TripSign(*from.sign_);
  } else {
    sign_ = nullptr;
  }
  ::memcpy(&begin_heading_, &from.begin_heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_count_) -
    reinterpret_cast<char*>(&begin_heading_)) + sizeof(lane_count_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.IntersectingEdge)
}

inline void TripLeg_IntersectingEdge::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sign_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lane_count_) -
    reinterpret_cast<char*>(&sign_)) + sizeof(lane_count_));
}

TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.IntersectingEdge)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_IntersectingEdge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sign_;
}

void TripLeg_IntersectingEdge::ArenaDtor(void* object) {
  TripLeg_IntersectingEdge* _this = reinterpret_cast< TripLeg_IntersectingEdge* >(object);
  (void)_this;
}
void TripLeg_IntersectingEdge::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_IntersectingEdge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_IntersectingEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.IntersectingEdge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && sign_ != nullptr) {
    delete sign_;
  }
  sign_ = nullptr;
  ::memset(&begin_heading_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_count_) -
      reinterpret_cast<char*>(&begin_heading_)) + sizeof(lane_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_IntersectingEdge::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 begin_heading = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          begin_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool prev_name_consistency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          prev_name_consistency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool curr_name_consistency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          curr_name_consistency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability driveability = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_driveability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability cyclability = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cyclability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Traversability walkability = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_walkability(static_cast<::valhalla::TripLeg_Traversability>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Use use = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.RoadClass road_class = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 lane_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          lane_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripSign sign = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_IntersectingEdge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.IntersectingEdge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 begin_heading = 1;
  if (this->_internal_begin_heading() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_heading(), target);
  }

  // bool prev_name_consistency = 2;
  if (this->_internal_prev_name_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_prev_name_consistency(), target);
  }

  // bool curr_name_consistency = 3;
  if (this->_internal_curr_name_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_curr_name_consistency(), target);
  }

  // .valhalla.TripLeg.Traversability driveability = 4;
  if (this->_internal_driveability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_driveability(), target);
  }

  // .valhalla.TripLeg.Traversability cyclability = 5;
  if (this->_internal_cyclability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_cyclability(), target);
  }

  // .valhalla.TripLeg.Traversability walkability = 6;
  if (this->_internal_walkability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_walkability(), target);
  }

  // .valhalla.TripLeg.Use use = 7;
  if (this->_internal_use() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_use(), target);
  }

  // .valhalla.RoadClass road_class = 8;
  if (this->_internal_road_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_road_class(), target);
  }

  // uint32 lane_count = 9;
  if (this->_internal_lane_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_lane_count(), target);
  }

  // .valhalla.TripSign sign = 10;
  if (this->_internal_has_sign()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::sign(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.IntersectingEdge)
  return target;
}

size_t TripLeg_IntersectingEdge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.IntersectingEdge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.TripSign sign = 10;
  if (this->_internal_has_sign()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sign_);
  }

  // uint32 begin_heading = 1;
  if (this->_internal_begin_heading() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_heading());
  }

  // bool prev_name_consistency = 2;
  if (this->_internal_prev_name_consistency() != 0) {
    total_size += 1 + 1;
  }

  // bool curr_name_consistency = 3;
  if (this->_internal_curr_name_consistency() != 0) {
    total_size += 1 + 1;
  }

  // .valhalla.TripLeg.Traversability driveability = 4;
  if (this->_internal_driveability() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_driveability());
  }

  // .valhalla.TripLeg.Traversability cyclability = 5;
  if (this->_internal_cyclability() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cyclability());
  }

  // .valhalla.TripLeg.Traversability walkability = 6;
  if (this->_internal_walkability() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_walkability());
  }

  // .valhalla.TripLeg.Use use = 7;
  if (this->_internal_use() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_use());
  }

  // .valhalla.RoadClass road_class = 8;
  if (this->_internal_road_class() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_road_class());
  }

  // uint32 lane_count = 9;
  if (this->_internal_lane_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_lane_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_IntersectingEdge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_IntersectingEdge*>(
      &from));
}

void TripLeg_IntersectingEdge::MergeFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.IntersectingEdge)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sign()) {
    _internal_mutable_sign()->::valhalla::TripSign::MergeFrom(from._internal_sign());
  }
  if (from._internal_begin_heading() != 0) {
    _internal_set_begin_heading(from._internal_begin_heading());
  }
  if (from._internal_prev_name_consistency() != 0) {
    _internal_set_prev_name_consistency(from._internal_prev_name_consistency());
  }
  if (from._internal_curr_name_consistency() != 0) {
    _internal_set_curr_name_consistency(from._internal_curr_name_consistency());
  }
  if (from._internal_driveability() != 0) {
    _internal_set_driveability(from._internal_driveability());
  }
  if (from._internal_cyclability() != 0) {
    _internal_set_cyclability(from._internal_cyclability());
  }
  if (from._internal_walkability() != 0) {
    _internal_set_walkability(from._internal_walkability());
  }
  if (from._internal_use() != 0) {
    _internal_set_use(from._internal_use());
  }
  if (from._internal_road_class() != 0) {
    _internal_set_road_class(from._internal_road_class());
  }
  if (from._internal_lane_count() != 0) {
    _internal_set_lane_count(from._internal_lane_count());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.IntersectingEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_IntersectingEdge::IsInitialized() const {
  return true;
}

void TripLeg_IntersectingEdge::InternalSwap(TripLeg_IntersectingEdge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, lane_count_)
      + sizeof(TripLeg_IntersectingEdge::lane_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, sign_)>(
          reinterpret_cast<char*>(&sign_),
          reinterpret_cast<char*>(&other->sign_));
}

std::string TripLeg_IntersectingEdge::GetTypeName() const {
  return "valhalla.TripLeg.IntersectingEdge";
}


// ===================================================================

class TripLeg_Cost::_Internal {
 public:
};

TripLeg_Cost::TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Cost)
}
TripLeg_Cost::TripLeg_Cost(const TripLeg_Cost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&cost_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(cost_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Cost)
}

inline void TripLeg_Cost::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cost_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(cost_));
}

TripLeg_Cost::~TripLeg_Cost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Cost)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Cost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Cost::ArenaDtor(void* object) {
  TripLeg_Cost* _this = reinterpret_cast< TripLeg_Cost* >(object);
  (void)_this;
}
void TripLeg_Cost::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Cost::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Cost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Cost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cost_) -
      reinterpret_cast<char*>(&seconds_)) + sizeof(cost_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Cost::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Cost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Cost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double seconds = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_seconds = this->_internal_seconds();
  uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_seconds(), target);
  }

  // double cost = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cost = this->_internal_cost();
  uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Cost)
  return target;
}

size_t TripLeg_Cost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Cost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double seconds = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_seconds = this->_internal_seconds();
  uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    total_size += 1 + 8;
  }

  // double cost = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cost = this->_internal_cost();
  uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Cost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Cost*>(
      &from));
}

void TripLeg_Cost::MergeFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Cost)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_seconds = from._internal_seconds();
  uint64_t raw_seconds;
  memcpy(&raw_seconds, &tmp_seconds, sizeof(tmp_seconds));
  if (raw_seconds != 0) {
    _internal_set_seconds(from._internal_seconds());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cost = from._internal_cost();
  uint64_t raw_cost;
  memcpy(&raw_cost, &tmp_cost, sizeof(tmp_cost));
  if (raw_cost != 0) {
    _internal_set_cost(from._internal_cost());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Cost::CopyFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Cost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Cost::IsInitialized() const {
  return true;
}

void TripLeg_Cost::InternalSwap(TripLeg_Cost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Cost, cost_)
      + sizeof(TripLeg_Cost::cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Cost, seconds_)>(
          reinterpret_cast<char*>(&seconds_),
          reinterpret_cast<char*>(&other->seconds_));
}

std::string TripLeg_Cost::GetTypeName() const {
  return "valhalla.TripLeg.Cost";
}


// ===================================================================

class TripLeg_PathCost::_Internal {
 public:
  static const ::valhalla::TripLeg_Cost& elapsed_cost(const TripLeg_PathCost* msg);
  static const ::valhalla::TripLeg_Cost& transition_cost(const TripLeg_PathCost* msg);
};

const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::elapsed_cost(const TripLeg_PathCost* msg) {
  return *msg->elapsed_cost_;
}
const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::transition_cost(const TripLeg_PathCost* msg) {
  return *msg->transition_cost_;
}
TripLeg_PathCost::TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.PathCost)
}
TripLeg_PathCost::TripLeg_PathCost(const TripLeg_PathCost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_elapsed_cost()) {
    elapsed_cost_ = new ::valhalla::TripLeg_Cost(*from.elapsed_cost_);
  } else {
    elapsed_cost_ = nullptr;
  }
  if (from._internal_has_transition_cost()) {
    transition_cost_ = new ::valhalla::TripLeg_Cost(*from.transition_cost_);
  } else {
    transition_cost_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.PathCost)
}

inline void TripLeg_PathCost::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&elapsed_cost_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transition_cost_) -
    reinterpret_cast<char*>(&elapsed_cost_)) + sizeof(transition_cost_));
}

TripLeg_PathCost::~TripLeg_PathCost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.PathCost)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_PathCost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete elapsed_cost_;
  if (this != internal_default_instance()) delete transition_cost_;
}

void TripLeg_PathCost::ArenaDtor(void* object) {
  TripLeg_PathCost* _this = reinterpret_cast< TripLeg_PathCost* >(object);
  (void)_this;
}
void TripLeg_PathCost::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_PathCost::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_PathCost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.PathCost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && elapsed_cost_ != nullptr) {
    delete elapsed_cost_;
  }
  elapsed_cost_ = nullptr;
  if (GetArenaForAllocation() == nullptr && transition_cost_ != nullptr) {
    delete transition_cost_;
  }
  transition_cost_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_PathCost::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.TripLeg.Cost elapsed_cost = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_elapsed_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Cost transition_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transition_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_PathCost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.PathCost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->_internal_has_elapsed_cost()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::elapsed_cost(this), target, stream);
  }

  // .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->_internal_has_transition_cost()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::transition_cost(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.PathCost)
  return target;
}

size_t TripLeg_PathCost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.PathCost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (this->_internal_has_elapsed_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *elapsed_cost_);
  }

  // .valhalla.TripLeg.Cost transition_cost = 2;
  if (this->_internal_has_transition_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *transition_cost_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_PathCost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_PathCost*>(
      &from));
}

void TripLeg_PathCost::MergeFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.PathCost)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_elapsed_cost()) {
    _internal_mutable_elapsed_cost()->::valhalla::TripLeg_Cost::MergeFrom(from._internal_elapsed_cost());
  }
  if (from._internal_has_transition_cost()) {
    _internal_mutable_transition_cost()->::valhalla::TripLeg_Cost::MergeFrom(from._internal_transition_cost());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_PathCost::CopyFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.PathCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_PathCost::IsInitialized() const {
  return true;
}

void TripLeg_PathCost::InternalSwap(TripLeg_PathCost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, transition_cost_)
      + sizeof(TripLeg_PathCost::transition_cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, elapsed_cost_)>(
          reinterpret_cast<char*>(&elapsed_cost_),
          reinterpret_cast<char*>(&other->elapsed_cost_));
}

std::string TripLeg_PathCost::GetTypeName() const {
  return "valhalla.TripLeg.PathCost";
}


// ===================================================================

class TripLeg_Node::_Internal {
 public:
  static const ::valhalla::TripLeg_Edge& edge(const TripLeg_Node* msg);
  static const ::valhalla::TransitPlatformInfo& transit_platform_info(const TripLeg_Node* msg);
  static const ::valhalla::TransitStationInfo& transit_station_info(const TripLeg_Node* msg);
  static const ::valhalla::TransitEgressInfo& transit_egress_info(const TripLeg_Node* msg);
  static const ::valhalla::TripLeg_PathCost& cost(const TripLeg_Node* msg);
  static const ::valhalla::BikeShareStationInfo& bss_info(const TripLeg_Node* msg);
};

const ::valhalla::TripLeg_Edge&
TripLeg_Node::_Internal::edge(const TripLeg_Node* msg) {
  return *msg->edge_;
}
const ::valhalla::TransitPlatformInfo&
TripLeg_Node::_Internal::transit_platform_info(const TripLeg_Node* msg) {
  return *msg->transit_platform_info_;
}
const ::valhalla::TransitStationInfo&
TripLeg_Node::_Internal::transit_station_info(const TripLeg_Node* msg) {
  return *msg->transit_station_info_;
}
const ::valhalla::TransitEgressInfo&
TripLeg_Node::_Internal::transit_egress_info(const TripLeg_Node* msg) {
  return *msg->transit_egress_info_;
}
const ::valhalla::TripLeg_PathCost&
TripLeg_Node::_Internal::cost(const TripLeg_Node* msg) {
  return *msg->cost_;
}
const ::valhalla::BikeShareStationInfo&
TripLeg_Node::_Internal::bss_info(const TripLeg_Node* msg) {
  return *msg->bss_info_;
}
void TripLeg_Node::clear_transit_platform_info() {
  if (GetArenaForAllocation() == nullptr && transit_platform_info_ != nullptr) {
    delete transit_platform_info_;
  }
  transit_platform_info_ = nullptr;
}
void TripLeg_Node::clear_transit_station_info() {
  if (GetArenaForAllocation() == nullptr && transit_station_info_ != nullptr) {
    delete transit_station_info_;
  }
  transit_station_info_ = nullptr;
}
void TripLeg_Node::clear_transit_egress_info() {
  if (GetArenaForAllocation() == nullptr && transit_egress_info_ != nullptr) {
    delete transit_egress_info_;
  }
  transit_egress_info_ = nullptr;
}
void TripLeg_Node::clear_bss_info() {
  if (GetArenaForAllocation() == nullptr && bss_info_ != nullptr) {
    delete bss_info_;
  }
  bss_info_ = nullptr;
}
TripLeg_Node::TripLeg_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  intersecting_edge_(arena),
  recosts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Node)
}
TripLeg_Node::TripLeg_Node(const TripLeg_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      intersecting_edge_(from.intersecting_edge_),
      recosts_(from.recosts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  time_zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    time_zone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_time_zone().empty()) {
    time_zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_time_zone(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_edge()) {
    edge_ = new ::valhalla::TripLeg_Edge(*from.edge_);
  } else {
    edge_ = nullptr;
  }
  if (from._internal_has_transit_platform_info()) {
    transit_platform_info_ = new ::valhalla::TransitPlatformInfo(*from.transit_platform_info_);
  } else {
    transit_platform_info_ = nullptr;
  }
  if (from._internal_has_transit_station_info()) {
    transit_station_info_ = new ::valhalla::TransitStationInfo(*from.transit_station_info_);
  } else {
    transit_station_info_ = nullptr;
  }
  if (from._internal_has_transit_egress_info()) {
    transit_egress_info_ = new ::valhalla::TransitEgressInfo(*from.transit_egress_info_);
  } else {
    transit_egress_info_ = nullptr;
  }
  if (from._internal_has_cost()) {
    cost_ = new ::valhalla::TripLeg_PathCost(*from.cost_);
  } else {
    cost_ = nullptr;
  }
  if (from._internal_has_bss_info()) {
    bss_info_ = new ::valhalla::BikeShareStationInfo(*from.bss_info_);
  } else {
    bss_info_ = nullptr;
  }
  ::memcpy(&admin_index_, &from.admin_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&fork_) -
    reinterpret_cast<char*>(&admin_index_)) + sizeof(fork_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Node)
}

inline void TripLeg_Node::SharedCtor() {
time_zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  time_zone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&edge_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fork_) -
    reinterpret_cast<char*>(&edge_)) + sizeof(fork_));
}

TripLeg_Node::~TripLeg_Node() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Node)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  time_zone_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete edge_;
  if (this != internal_default_instance()) delete transit_platform_info_;
  if (this != internal_default_instance()) delete transit_station_info_;
  if (this != internal_default_instance()) delete transit_egress_info_;
  if (this != internal_default_instance()) delete cost_;
  if (this != internal_default_instance()) delete bss_info_;
}

void TripLeg_Node::ArenaDtor(void* object) {
  TripLeg_Node* _this = reinterpret_cast< TripLeg_Node* >(object);
  (void)_this;
}
void TripLeg_Node::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Node::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  intersecting_edge_.Clear();
  recosts_.Clear();
  time_zone_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && edge_ != nullptr) {
    delete edge_;
  }
  edge_ = nullptr;
  if (GetArenaForAllocation() == nullptr && transit_platform_info_ != nullptr) {
    delete transit_platform_info_;
  }
  transit_platform_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && transit_station_info_ != nullptr) {
    delete transit_station_info_;
  }
  transit_station_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && transit_egress_info_ != nullptr) {
    delete transit_egress_info_;
  }
  transit_egress_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && cost_ != nullptr) {
    delete cost_;
  }
  cost_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bss_info_ != nullptr) {
    delete bss_info_;
  }
  bss_info_ = nullptr;
  ::memset(&admin_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fork_) -
      reinterpret_cast<char*>(&admin_index_)) + sizeof(fork_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Node::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.TripLeg.Edge edge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_intersecting_edge(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 admin_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          admin_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.Node.Type type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::valhalla::TripLeg_Node_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // bool fork = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          fork_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitPlatformInfo transit_platform_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_platform_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitStationInfo transit_station_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_station_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TransitEgressInfo transit_egress_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_egress_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string time_zone = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_time_zone();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.PathCost cost = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.PathCost recosts = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_recosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BikeShareStationInfo bss_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_bss_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.TripLeg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::edge(this), target, stream);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_intersecting_edge_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_intersecting_edge(i), target, stream);
  }

  // uint32 admin_index = 3;
  if (this->_internal_admin_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_admin_index(), target);
  }

  // .valhalla.TripLeg.Node.Type type = 4;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // bool fork = 5;
  if (this->_internal_fork() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_fork(), target);
  }

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->_internal_has_transit_platform_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::transit_platform_info(this), target, stream);
  }

  // .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->_internal_has_transit_station_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::transit_station_info(this), target, stream);
  }

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->_internal_has_transit_egress_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::transit_egress_info(this), target, stream);
  }

  // string time_zone = 11;
  if (!this->_internal_time_zone().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_time_zone().data(), static_cast<int>(this->_internal_time_zone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Node.time_zone");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_time_zone(), target);
  }

  // .valhalla.TripLeg.PathCost cost = 12;
  if (this->_internal_has_cost()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::cost(this), target, stream);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_recosts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_recosts(i), target, stream);
  }

  // .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->_internal_has_bss_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::bss_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Node)
  return target;
}

size_t TripLeg_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  total_size += 1UL * this->_internal_intersecting_edge_size();
  for (const auto& msg : this->intersecting_edge_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  total_size += 1UL * this->_internal_recosts_size();
  for (const auto& msg : this->recosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string time_zone = 11;
  if (!this->_internal_time_zone().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_time_zone());
  }

  // .valhalla.TripLeg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *edge_);
  }

  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (this->_internal_has_transit_platform_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *transit_platform_info_);
  }

  // .valhalla.TransitStationInfo transit_station_info = 7;
  if (this->_internal_has_transit_station_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *transit_station_info_);
  }

  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (this->_internal_has_transit_egress_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *transit_egress_info_);
  }

  // .valhalla.TripLeg.PathCost cost = 12;
  if (this->_internal_has_cost()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cost_);
  }

  // .valhalla.BikeShareStationInfo bss_info = 14;
  if (this->_internal_has_bss_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bss_info_);
  }

  // uint32 admin_index = 3;
  if (this->_internal_admin_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_admin_index());
  }

  // .valhalla.TripLeg.Node.Type type = 4;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // bool fork = 5;
  if (this->_internal_fork() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Node::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Node*>(
      &from));
}

void TripLeg_Node::MergeFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Node)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  intersecting_edge_.MergeFrom(from.intersecting_edge_);
  recosts_.MergeFrom(from.recosts_);
  if (!from._internal_time_zone().empty()) {
    _internal_set_time_zone(from._internal_time_zone());
  }
  if (from._internal_has_edge()) {
    _internal_mutable_edge()->::valhalla::TripLeg_Edge::MergeFrom(from._internal_edge());
  }
  if (from._internal_has_transit_platform_info()) {
    _internal_mutable_transit_platform_info()->::valhalla::TransitPlatformInfo::MergeFrom(from._internal_transit_platform_info());
  }
  if (from._internal_has_transit_station_info()) {
    _internal_mutable_transit_station_info()->::valhalla::TransitStationInfo::MergeFrom(from._internal_transit_station_info());
  }
  if (from._internal_has_transit_egress_info()) {
    _internal_mutable_transit_egress_info()->::valhalla::TransitEgressInfo::MergeFrom(from._internal_transit_egress_info());
  }
  if (from._internal_has_cost()) {
    _internal_mutable_cost()->::valhalla::TripLeg_PathCost::MergeFrom(from._internal_cost());
  }
  if (from._internal_has_bss_info()) {
    _internal_mutable_bss_info()->::valhalla::BikeShareStationInfo::MergeFrom(from._internal_bss_info());
  }
  if (from._internal_admin_index() != 0) {
    _internal_set_admin_index(from._internal_admin_index());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_fork() != 0) {
    _internal_set_fork(from._internal_fork());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Node::IsInitialized() const {
  return true;
}

void TripLeg_Node::InternalSwap(TripLeg_Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  intersecting_edge_.InternalSwap(&other->intersecting_edge_);
  recosts_.InternalSwap(&other->recosts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &time_zone_, lhs_arena,
      &other->time_zone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, fork_)
      + sizeof(TripLeg_Node::fork_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Node, edge_)>(
          reinterpret_cast<char*>(&edge_),
          reinterpret_cast<char*>(&other->edge_));
}

std::string TripLeg_Node::GetTypeName() const {
  return "valhalla.TripLeg.Node";
}


// ===================================================================

class TripLeg_Admin::_Internal {
 public:
};

TripLeg_Admin::TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Admin)
}
TripLeg_Admin::TripLeg_Admin(const TripLeg_Admin& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  country_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_country_code().empty()) {
    country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country_code(), 
      GetArenaForAllocation());
  }
  country_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_country_text().empty()) {
    country_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country_text(), 
      GetArenaForAllocation());
  }
  state_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    state_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state_code().empty()) {
    state_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state_code(), 
      GetArenaForAllocation());
  }
  state_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    state_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state_text().empty()) {
    state_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state_text(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Admin)
}

inline void TripLeg_Admin::SharedCtor() {
country_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
country_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
state_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  state_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
state_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  state_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripLeg_Admin::~TripLeg_Admin() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Admin)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Admin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  country_code_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  country_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  state_code_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  state_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TripLeg_Admin::ArenaDtor(void* object) {
  TripLeg_Admin* _this = reinterpret_cast< TripLeg_Admin* >(object);
  (void)_this;
}
void TripLeg_Admin::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Admin::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Admin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  country_code_.ClearToEmpty();
  country_text_.ClearToEmpty();
  state_code_.ClearToEmpty();
  state_text_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Admin::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string country_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_country_code();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string country_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_country_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string state_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_state_code();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string state_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_state_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Admin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Admin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string country_code = 1;
  if (!this->_internal_country_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_country_code().data(), static_cast<int>(this->_internal_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_code");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_country_code(), target);
  }

  // string country_text = 2;
  if (!this->_internal_country_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_country_text().data(), static_cast<int>(this->_internal_country_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.country_text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_country_text(), target);
  }

  // string state_code = 3;
  if (!this->_internal_state_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_state_code().data(), static_cast<int>(this->_internal_state_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_state_code(), target);
  }

  // string state_text = 4;
  if (!this->_internal_state_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_state_text().data(), static_cast<int>(this->_internal_state_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.Admin.state_text");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_state_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Admin)
  return target;
}

size_t TripLeg_Admin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Admin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string country_code = 1;
  if (!this->_internal_country_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_country_code());
  }

  // string country_text = 2;
  if (!this->_internal_country_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_country_text());
  }

  // string state_code = 3;
  if (!this->_internal_state_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_state_code());
  }

  // string state_text = 4;
  if (!this->_internal_state_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_state_text());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Admin::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Admin*>(
      &from));
}

void TripLeg_Admin::MergeFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Admin)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_country_code().empty()) {
    _internal_set_country_code(from._internal_country_code());
  }
  if (!from._internal_country_text().empty()) {
    _internal_set_country_text(from._internal_country_text());
  }
  if (!from._internal_state_code().empty()) {
    _internal_set_state_code(from._internal_state_code());
  }
  if (!from._internal_state_text().empty()) {
    _internal_set_state_text(from._internal_state_text());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Admin::IsInitialized() const {
  return true;
}

void TripLeg_Admin::InternalSwap(TripLeg_Admin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_code_, lhs_arena,
      &other->country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_text_, lhs_arena,
      &other->country_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_code_, lhs_arena,
      &other->state_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_text_, lhs_arena,
      &other->state_text_, rhs_arena
  );
}

std::string TripLeg_Admin::GetTypeName() const {
  return "valhalla.TripLeg.Admin";
}


// ===================================================================

class TripLeg_ShapeAttributes::_Internal {
 public:
};

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  time_(arena),
  length_(arena),
  speed_(arena),
  speed_limit_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.ShapeAttributes)
}
TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      time_(from.time_),
      length_(from.length_),
      speed_(from.speed_),
      speed_limit_(from.speed_limit_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ShapeAttributes)
}

inline void TripLeg_ShapeAttributes::SharedCtor() {
}

TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ShapeAttributes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_ShapeAttributes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_ShapeAttributes::ArenaDtor(void* object) {
  TripLeg_ShapeAttributes* _this = reinterpret_cast< TripLeg_ShapeAttributes* >(object);
  (void)_this;
}
void TripLeg_ShapeAttributes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_ShapeAttributes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_ShapeAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ShapeAttributes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  time_.Clear();
  length_.Clear();
  speed_.Clear();
  speed_limit_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_ShapeAttributes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 time = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_time(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_time(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 length = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_length(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_length(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 speed = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_speed(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 speed_limit = 5 [packed = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed_limit(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_speed_limit(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_ShapeAttributes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.ShapeAttributes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    int byte_size = _time_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_time(), byte_size, target);
    }
  }

  // repeated uint32 length = 2 [packed = true];
  {
    int byte_size = _length_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_length(), byte_size, target);
    }
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    int byte_size = _speed_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_speed(), byte_size, target);
    }
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    int byte_size = _speed_limit_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          5, _internal_speed_limit(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.ShapeAttributes)
  return target;
}

size_t TripLeg_ShapeAttributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ShapeAttributes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->time_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _time_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 length = 2 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->length_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _length_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->speed_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _speed_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->speed_limit_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _speed_limit_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_ShapeAttributes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_ShapeAttributes*>(
      &from));
}

void TripLeg_ShapeAttributes::MergeFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ShapeAttributes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  time_.MergeFrom(from.time_);
  length_.MergeFrom(from.length_);
  speed_.MergeFrom(from.speed_);
  speed_limit_.MergeFrom(from.speed_limit_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ShapeAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_ShapeAttributes::IsInitialized() const {
  return true;
}

void TripLeg_ShapeAttributes::InternalSwap(TripLeg_ShapeAttributes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  time_.InternalSwap(&other->time_);
  length_.InternalSwap(&other->length_);
  speed_.InternalSwap(&other->speed_);
  speed_limit_.InternalSwap(&other->speed_limit_);
}

std::string TripLeg_ShapeAttributes::GetTypeName() const {
  return "valhalla.TripLeg.ShapeAttributes";
}


// ===================================================================

class TripLeg_Incident::_Internal {
 public:
  static const ::valhalla::IncidentsTile_Metadata& metadata(const TripLeg_Incident* msg);
};

const ::valhalla::IncidentsTile_Metadata&
TripLeg_Incident::_Internal::metadata(const TripLeg_Incident* msg) {
  return *msg->metadata_;
}
void TripLeg_Incident::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
TripLeg_Incident::TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Incident)
}
TripLeg_Incident::TripLeg_Incident(const TripLeg_Incident& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    metadata_ = new ::valhalla::IncidentsTile_Metadata(*from.metadata_);
  } else {
    metadata_ = nullptr;
  }
  ::memcpy(&begin_shape_index_, &from.begin_shape_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_shape_index_) -
    reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(end_shape_index_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Incident)
}

inline void TripLeg_Incident::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&metadata_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_shape_index_) -
    reinterpret_cast<char*>(&metadata_)) + sizeof(end_shape_index_));
}

TripLeg_Incident::~TripLeg_Incident() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Incident)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Incident::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete metadata_;
}

void TripLeg_Incident::ArenaDtor(void* object) {
  TripLeg_Incident* _this = reinterpret_cast< TripLeg_Incident* >(object);
  (void)_this;
}
void TripLeg_Incident::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Incident::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Incident::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Incident)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
  ::memset(&begin_shape_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_shape_index_) -
      reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(end_shape_index_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Incident::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .valhalla.IncidentsTile.Metadata metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 begin_shape_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          begin_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          end_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Incident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Incident)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->_internal_has_metadata()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::metadata(this), target, stream);
  }

  // uint32 begin_shape_index = 3;
  if (this->_internal_begin_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 4;
  if (this->_internal_end_shape_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Incident)
  return target;
}

size_t TripLeg_Incident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Incident)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .valhalla.IncidentsTile.Metadata metadata = 1;
  if (this->_internal_has_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *metadata_);
  }

  // uint32 begin_shape_index = 3;
  if (this->_internal_begin_shape_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
  }

  // uint32 end_shape_index = 4;
  if (this->_internal_end_shape_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Incident::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Incident*>(
      &from));
}

void TripLeg_Incident::MergeFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Incident)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_metadata()) {
    _internal_mutable_metadata()->::valhalla::IncidentsTile_Metadata::MergeFrom(from._internal_metadata());
  }
  if (from._internal_begin_shape_index() != 0) {
    _internal_set_begin_shape_index(from._internal_begin_shape_index());
  }
  if (from._internal_end_shape_index() != 0) {
    _internal_set_end_shape_index(from._internal_end_shape_index());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Incident::CopyFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Incident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Incident::IsInitialized() const {
  return true;
}

void TripLeg_Incident::InternalSwap(TripLeg_Incident* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Incident, end_shape_index_)
      + sizeof(TripLeg_Incident::end_shape_index_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Incident, metadata_)>(
          reinterpret_cast<char*>(&metadata_),
          reinterpret_cast<char*>(&other->metadata_));
}

std::string TripLeg_Incident::GetTypeName() const {
  return "valhalla.TripLeg.Incident";
}


// ===================================================================

class TripLeg_Closure::_Internal {
 public:
};

TripLeg_Closure::TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Closure)
}
TripLeg_Closure::TripLeg_Closure(const TripLeg_Closure& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_has_begin_shape_index();
  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  clear_has_has_end_shape_index();
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Closure)
}

inline void TripLeg_Closure::SharedCtor() {
clear_has_has_begin_shape_index();
clear_has_has_end_shape_index();
}

TripLeg_Closure::~TripLeg_Closure() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Closure)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Closure::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_has_begin_shape_index()) {
    clear_has_begin_shape_index();
  }
  if (has_has_end_shape_index()) {
    clear_has_end_shape_index();
  }
}

void TripLeg_Closure::ArenaDtor(void* object) {
  TripLeg_Closure* _this = reinterpret_cast< TripLeg_Closure* >(object);
  (void)_this;
}
void TripLeg_Closure::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Closure::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Closure::clear_has_begin_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}

void TripLeg_Closure::clear_has_end_shape_index() {
// @@protoc_insertion_point(one_of_clear_start:valhalla.TripLeg.Closure)
  switch (has_end_shape_index_case()) {
    case kEndShapeIndex: {
      // No need to clear
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}


void TripLeg_Closure::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Closure)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_has_begin_shape_index();
  clear_has_end_shape_index();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Closure::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 begin_shape_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_shape_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg_Closure::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Closure)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 begin_shape_index = 1;
  if (_internal_has_begin_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_shape_index(), target);
  }

  // uint32 end_shape_index = 2;
  if (_internal_has_end_shape_index()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Closure)
  return target;
}

size_t TripLeg_Closure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Closure)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (has_begin_shape_index_case()) {
    // uint32 begin_shape_index = 1;
    case kBeginShapeIndex: {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (has_end_shape_index_case()) {
    // uint32 end_shape_index = 2;
    case kEndShapeIndex: {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Closure::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Closure*>(
      &from));
}

void TripLeg_Closure::MergeFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Closure)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.has_begin_shape_index_case()) {
    case kBeginShapeIndex: {
      _internal_set_begin_shape_index(from._internal_begin_shape_index());
      break;
    }
    case HAS_BEGIN_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  switch (from.has_end_shape_index_case()) {
    case kEndShapeIndex: {
      _internal_set_end_shape_index(from._internal_end_shape_index());
      break;
    }
    case HAS_END_SHAPE_INDEX_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Closure::CopyFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Closure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Closure::IsInitialized() const {
  return true;
}

void TripLeg_Closure::InternalSwap(TripLeg_Closure* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(has_begin_shape_index_, other->has_begin_shape_index_);
  swap(has_end_shape_index_, other->has_end_shape_index_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

std::string TripLeg_Closure::GetTypeName() const {
  return "valhalla.TripLeg.Closure";
}


// ===================================================================

class TripLeg::_Internal {
 public:
  static const ::valhalla::BoundingBox& bbox(const TripLeg* msg);
  static const ::valhalla::TripLeg_ShapeAttributes& shape_attributes(const TripLeg* msg);
};

const ::valhalla::BoundingBox&
TripLeg::_Internal::bbox(const TripLeg* msg) {
  return *msg->bbox_;
}
const ::valhalla::TripLeg_ShapeAttributes&
TripLeg::_Internal::shape_attributes(const TripLeg* msg) {
  return *msg->shape_attributes_;
}
void TripLeg::clear_location() {
  location_.Clear();
}
void TripLeg::clear_bbox() {
  if (GetArenaForAllocation() == nullptr && bbox_ != nullptr) {
    delete bbox_;
  }
  bbox_ = nullptr;
}
TripLeg::TripLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  location_(arena),
  node_(arena),
  admin_(arena),
  incidents_(arena),
  algorithms_(arena),
  closures_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg)
}
TripLeg::TripLeg(const TripLeg& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      location_(from.location_),
      node_(from.node_),
      admin_(from.admin_),
      incidents_(from.incidents_),
      algorithms_(from.algorithms_),
      closures_(from.closures_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  shape_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    shape_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_shape().empty()) {
    shape_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_shape(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_bbox()) {
    bbox_ = new ::valhalla::BoundingBox(*from.bbox_);
  } else {
    bbox_ = nullptr;
  }
  if (from._internal_has_shape_attributes()) {
    shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes(*from.shape_attributes_);
  } else {
    shape_attributes_ = nullptr;
  }
  ::memcpy(&osm_changeset_, &from.osm_changeset_,
    static_cast<size_t>(reinterpret_cast<char*>(&leg_count_) -
    reinterpret_cast<char*>(&osm_changeset_)) + sizeof(leg_count_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg)
}

inline void TripLeg::SharedCtor() {
shape_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  shape_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bbox_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&leg_count_) -
    reinterpret_cast<char*>(&bbox_)) + sizeof(leg_count_));
}

TripLeg::~TripLeg() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  shape_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete bbox_;
  if (this != internal_default_instance()) delete shape_attributes_;
}

void TripLeg::ArenaDtor(void* object) {
  TripLeg* _this = reinterpret_cast< TripLeg* >(object);
  (void)_this;
}
void TripLeg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  location_.Clear();
  node_.Clear();
  admin_.Clear();
  incidents_.Clear();
  algorithms_.Clear();
  closures_.Clear();
  shape_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && bbox_ != nullptr) {
    delete bbox_;
  }
  bbox_ = nullptr;
  if (GetArenaForAllocation() == nullptr && shape_attributes_ != nullptr) {
    delete shape_attributes_;
  }
  shape_attributes_ = nullptr;
  ::memset(&osm_changeset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&leg_count_) -
      reinterpret_cast<char*>(&osm_changeset_)) + sizeof(leg_count_));
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 osm_changeset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          osm_changeset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 trip_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          trip_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 leg_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          leg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 leg_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          leg_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.Location location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_location(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Node node = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Admin admin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_admin(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string shape = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_shape();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.BoundingBox bbox = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_bbox(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_attributes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Incident incidents = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incidents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string algorithms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_algorithms();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Closure closures = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_closures(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripLeg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 osm_changeset = 1;
  if (this->_internal_osm_changeset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_osm_changeset(), target);
  }

  // uint64 trip_id = 2;
  if (this->_internal_trip_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_trip_id(), target);
  }

  // uint32 leg_id = 3;
  if (this->_internal_leg_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_leg_id(), target);
  }

  // uint32 leg_count = 4;
  if (this->_internal_leg_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_leg_count(), target);
  }

  // repeated .valhalla.Location location = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_location_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_location(i), target, stream);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_node_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_node(i), target, stream);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_admin_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_admin(i), target, stream);
  }

  // string shape = 8;
  if (!this->_internal_shape().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_shape().data(), static_cast<int>(this->_internal_shape().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.shape");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_shape(), target);
  }

  // .valhalla.BoundingBox bbox = 9;
  if (this->_internal_has_bbox()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::bbox(this), target, stream);
  }

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->_internal_has_shape_attributes()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::shape_attributes(this), target, stream);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_incidents_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_incidents(i), target, stream);
  }

  // repeated string algorithms = 12;
  for (int i = 0, n = this->_internal_algorithms_size(); i < n; i++) {
    const auto& s = this->_internal_algorithms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "valhalla.TripLeg.algorithms");
    target = stream->WriteString(12, s, target);
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_closures_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_closures(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg)
  return target;
}

size_t TripLeg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.Location location = 5;
  total_size += 1UL * this->_internal_location_size();
  for (const auto& msg : this->location_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  total_size += 1UL * this->_internal_node_size();
  for (const auto& msg : this->node_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  total_size += 1UL * this->_internal_admin_size();
  for (const auto& msg : this->admin_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  total_size += 1UL * this->_internal_incidents_size();
  for (const auto& msg : this->incidents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string algorithms = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(algorithms_.size());
  for (int i = 0, n = algorithms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      algorithms_.Get(i));
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  total_size += 1UL * this->_internal_closures_size();
  for (const auto& msg : this->closures_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string shape = 8;
  if (!this->_internal_shape().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shape());
  }

  // .valhalla.BoundingBox bbox = 9;
  if (this->_internal_has_bbox()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bbox_);
  }

  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (this->_internal_has_shape_attributes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *shape_attributes_);
  }

  // uint64 osm_changeset = 1;
  if (this->_internal_osm_changeset() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_osm_changeset());
  }

  // uint64 trip_id = 2;
  if (this->_internal_trip_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_trip_id());
  }

  // uint32 leg_id = 3;
  if (this->_internal_leg_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_leg_id());
  }

  // uint32 leg_count = 4;
  if (this->_internal_leg_count() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_leg_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg*>(
      &from));
}

void TripLeg::MergeFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  location_.MergeFrom(from.location_);
  node_.MergeFrom(from.node_);
  admin_.MergeFrom(from.admin_);
  incidents_.MergeFrom(from.incidents_);
  algorithms_.MergeFrom(from.algorithms_);
  closures_.MergeFrom(from.closures_);
  if (!from._internal_shape().empty()) {
    _internal_set_shape(from._internal_shape());
  }
  if (from._internal_has_bbox()) {
    _internal_mutable_bbox()->::valhalla::BoundingBox::MergeFrom(from._internal_bbox());
  }
  if (from._internal_has_shape_attributes()) {
    _internal_mutable_shape_attributes()->::valhalla::TripLeg_ShapeAttributes::MergeFrom(from._internal_shape_attributes());
  }
  if (from._internal_osm_changeset() != 0) {
    _internal_set_osm_changeset(from._internal_osm_changeset());
  }
  if (from._internal_trip_id() != 0) {
    _internal_set_trip_id(from._internal_trip_id());
  }
  if (from._internal_leg_id() != 0) {
    _internal_set_leg_id(from._internal_leg_id());
  }
  if (from._internal_leg_count() != 0) {
    _internal_set_leg_count(from._internal_leg_count());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg::CopyFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg::IsInitialized() const {
  return true;
}

void TripLeg::InternalSwap(TripLeg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  location_.InternalSwap(&other->location_);
  node_.InternalSwap(&other->node_);
  admin_.InternalSwap(&other->admin_);
  incidents_.InternalSwap(&other->incidents_);
  algorithms_.InternalSwap(&other->algorithms_);
  closures_.InternalSwap(&other->closures_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &shape_, lhs_arena,
      &other->shape_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg, leg_count_)
      + sizeof(TripLeg::leg_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg, bbox_)>(
          reinterpret_cast<char*>(&bbox_),
          reinterpret_cast<char*>(&other->bbox_));
}

std::string TripLeg::GetTypeName() const {
  return "valhalla.TripLeg";
}


// ===================================================================

class TripRoute::_Internal {
 public:
};

TripRoute::TripRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  legs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripRoute)
}
TripRoute::TripRoute(const TripRoute& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      legs_(from.legs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripRoute)
}

inline void TripRoute::SharedCtor() {
}

TripRoute::~TripRoute() {
  // @@protoc_insertion_point(destructor:valhalla.TripRoute)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripRoute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripRoute::ArenaDtor(void* object) {
  TripRoute* _this = reinterpret_cast< TripRoute* >(object);
  (void)_this;
}
void TripRoute::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripRoute::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripRoute::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripRoute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  legs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripRoute::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripLeg legs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_legs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TripRoute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripRoute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_legs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_legs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripRoute)
  return target;
}

size_t TripRoute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripRoute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  total_size += 1UL * this->_internal_legs_size();
  for (const auto& msg : this->legs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripRoute::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripRoute*>(
      &from));
}

void TripRoute::MergeFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripRoute)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  legs_.MergeFrom(from.legs_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripRoute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripRoute::IsInitialized() const {
  return true;
}

void TripRoute::InternalSwap(TripRoute* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  legs_.InternalSwap(&other->legs_);
}

std::string TripRoute::GetTypeName() const {
  return "valhalla.TripRoute";
}


// ===================================================================

class Trip::_Internal {
 public:
};

Trip::Trip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  routes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.Trip)
}
Trip::Trip(const Trip& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      routes_(from.routes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.Trip)
}

inline void Trip::SharedCtor() {
}

Trip::~Trip() {
  // @@protoc_insertion_point(destructor:valhalla.Trip)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Trip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Trip::ArenaDtor(void* object) {
  Trip* _this = reinterpret_cast< Trip* >(object);
  (void)_this;
}
void Trip::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Trip::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Trip::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Trip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  routes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Trip::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripRoute routes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_routes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Trip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_routes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_routes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Trip)
  return target;
}

size_t Trip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Trip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  total_size += 1UL * this->_internal_routes_size();
  for (const auto& msg : this->routes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Trip::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Trip*>(
      &from));
}

void Trip::MergeFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Trip)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  routes_.MergeFrom(from.routes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Trip::CopyFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Trip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trip::IsInitialized() const {
  return true;
}

void Trip::InternalSwap(Trip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  routes_.InternalSwap(&other->routes_);
}

std::string Trip::GetTypeName() const {
  return "valhalla.Trip";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_LaneConnectivity* Arena::CreateMaybeMessage< ::valhalla::TripLeg_LaneConnectivity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_LaneConnectivity >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_TrafficSegment* Arena::CreateMaybeMessage< ::valhalla::TripLeg_TrafficSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_TrafficSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Restriction* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Restriction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Restriction >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Edge* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Edge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Edge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_IntersectingEdge* Arena::CreateMaybeMessage< ::valhalla::TripLeg_IntersectingEdge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_IntersectingEdge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Cost* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Cost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Cost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_PathCost* Arena::CreateMaybeMessage< ::valhalla::TripLeg_PathCost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_PathCost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Node* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Admin* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Admin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Admin >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_ShapeAttributes* Arena::CreateMaybeMessage< ::valhalla::TripLeg_ShapeAttributes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_ShapeAttributes >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Incident* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Incident >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Incident >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Closure* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Closure >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Closure >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg* Arena::CreateMaybeMessage< ::valhalla::TripLeg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripRoute* Arena::CreateMaybeMessage< ::valhalla::TripRoute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripRoute >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Trip* Arena::CreateMaybeMessage< ::valhalla::Trip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Trip >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
