// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_options_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_options_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_options_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_options_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace valhalla {
class AvoidEdge;
struct AvoidEdgeDefaultTypeInternal;
extern AvoidEdgeDefaultTypeInternal _AvoidEdge_default_instance_;
class Contour;
struct ContourDefaultTypeInternal;
extern ContourDefaultTypeInternal _Contour_default_instance_;
class Costing;
struct CostingDefaultTypeInternal;
extern CostingDefaultTypeInternal _Costing_default_instance_;
class Costing_Options;
struct Costing_OptionsDefaultTypeInternal;
extern Costing_OptionsDefaultTypeInternal _Costing_Options_default_instance_;
class Options;
struct OptionsDefaultTypeInternal;
extern OptionsDefaultTypeInternal _Options_default_instance_;
class Options_CostingsEntry_DoNotUse;
struct Options_CostingsEntry_DoNotUseDefaultTypeInternal;
extern Options_CostingsEntry_DoNotUseDefaultTypeInternal _Options_CostingsEntry_DoNotUse_default_instance_;
class PbfFieldSelector;
struct PbfFieldSelectorDefaultTypeInternal;
extern PbfFieldSelectorDefaultTypeInternal _PbfFieldSelector_default_instance_;
class Ring;
struct RingDefaultTypeInternal;
extern RingDefaultTypeInternal _Ring_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::AvoidEdge* Arena::CreateMaybeMessage<::valhalla::AvoidEdge>(Arena*);
template<> ::valhalla::Contour* Arena::CreateMaybeMessage<::valhalla::Contour>(Arena*);
template<> ::valhalla::Costing* Arena::CreateMaybeMessage<::valhalla::Costing>(Arena*);
template<> ::valhalla::Costing_Options* Arena::CreateMaybeMessage<::valhalla::Costing_Options>(Arena*);
template<> ::valhalla::Options* Arena::CreateMaybeMessage<::valhalla::Options>(Arena*);
template<> ::valhalla::Options_CostingsEntry_DoNotUse* Arena::CreateMaybeMessage<::valhalla::Options_CostingsEntry_DoNotUse>(Arena*);
template<> ::valhalla::PbfFieldSelector* Arena::CreateMaybeMessage<::valhalla::PbfFieldSelector>(Arena*);
template<> ::valhalla::Ring* Arena::CreateMaybeMessage<::valhalla::Ring>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum Costing_Type : int {
  Costing_Type_none_ = 0,
  Costing_Type_bicycle = 1,
  Costing_Type_bus = 2,
  Costing_Type_motor_scooter = 3,
  Costing_Type_multimodal = 4,
  Costing_Type_pedestrian = 5,
  Costing_Type_transit = 6,
  Costing_Type_truck = 7,
  Costing_Type_motorcycle = 8,
  Costing_Type_taxi = 9,
  Costing_Type_auto_ = 10,
  Costing_Type_bikeshare = 11,
  Costing_Type_Costing_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Costing_Type_Costing_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Costing_Type_IsValid(int value);
constexpr Costing_Type Costing_Type_Type_MIN = Costing_Type_none_;
constexpr Costing_Type Costing_Type_Type_MAX = Costing_Type_bikeshare;
constexpr int Costing_Type_Type_ARRAYSIZE = Costing_Type_Type_MAX + 1;

const std::string& Costing_Type_Name(Costing_Type value);
template<typename T>
inline const std::string& Costing_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Costing_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Costing_Type_Name.");
  return Costing_Type_Name(static_cast<Costing_Type>(enum_t_value));
}
bool Costing_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Costing_Type* value);
enum Options_Units : int {
  Options_Units_kilometers = 0,
  Options_Units_miles = 1,
  Options_Units_Options_Units_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Options_Units_Options_Units_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Options_Units_IsValid(int value);
constexpr Options_Units Options_Units_Units_MIN = Options_Units_kilometers;
constexpr Options_Units Options_Units_Units_MAX = Options_Units_miles;
constexpr int Options_Units_Units_ARRAYSIZE = Options_Units_Units_MAX + 1;

const std::string& Options_Units_Name(Options_Units value);
template<typename T>
inline const std::string& Options_Units_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_Units>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_Units_Name.");
  return Options_Units_Name(static_cast<Options_Units>(enum_t_value));
}
bool Options_Units_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Units* value);
enum Options_Format : int {
  Options_Format_json = 0,
  Options_Format_gpx = 1,
  Options_Format_osrm = 2,
  Options_Format_pbf = 3,
  Options_Format_Options_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Options_Format_Options_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Options_Format_IsValid(int value);
constexpr Options_Format Options_Format_Format_MIN = Options_Format_json;
constexpr Options_Format Options_Format_Format_MAX = Options_Format_pbf;
constexpr int Options_Format_Format_ARRAYSIZE = Options_Format_Format_MAX + 1;

const std::string& Options_Format_Name(Options_Format value);
template<typename T>
inline const std::string& Options_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_Format_Name.");
  return Options_Format_Name(static_cast<Options_Format>(enum_t_value));
}
bool Options_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Format* value);
enum Options_Action : int {
  Options_Action_no_action = 0,
  Options_Action_route = 1,
  Options_Action_locate = 2,
  Options_Action_sources_to_targets = 3,
  Options_Action_optimized_route = 4,
  Options_Action_isochrone = 5,
  Options_Action_trace_route = 6,
  Options_Action_trace_attributes = 7,
  Options_Action_height = 8,
  Options_Action_transit_available = 9,
  Options_Action_expansion = 10,
  Options_Action_centroid = 11,
  Options_Action_status = 12,
  Options_Action_Options_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Options_Action_Options_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Options_Action_IsValid(int value);
constexpr Options_Action Options_Action_Action_MIN = Options_Action_no_action;
constexpr Options_Action Options_Action_Action_MAX = Options_Action_status;
constexpr int Options_Action_Action_ARRAYSIZE = Options_Action_Action_MAX + 1;

const std::string& Options_Action_Name(Options_Action value);
template<typename T>
inline const std::string& Options_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_Action_Name.");
  return Options_Action_Name(static_cast<Options_Action>(enum_t_value));
}
bool Options_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Action* value);
enum Options_DateTimeType : int {
  Options_DateTimeType_no_time = 0,
  Options_DateTimeType_current = 1,
  Options_DateTimeType_depart_at = 2,
  Options_DateTimeType_arrive_by = 3,
  Options_DateTimeType_invariant = 4,
  Options_DateTimeType_Options_DateTimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Options_DateTimeType_Options_DateTimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Options_DateTimeType_IsValid(int value);
constexpr Options_DateTimeType Options_DateTimeType_DateTimeType_MIN = Options_DateTimeType_no_time;
constexpr Options_DateTimeType Options_DateTimeType_DateTimeType_MAX = Options_DateTimeType_invariant;
constexpr int Options_DateTimeType_DateTimeType_ARRAYSIZE = Options_DateTimeType_DateTimeType_MAX + 1;

const std::string& Options_DateTimeType_Name(Options_DateTimeType value);
template<typename T>
inline const std::string& Options_DateTimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_DateTimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_DateTimeType_Name.");
  return Options_DateTimeType_Name(static_cast<Options_DateTimeType>(enum_t_value));
}
bool Options_DateTimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_DateTimeType* value);
enum Options_ExpansionProperties : int {
  Options_ExpansionProperties_costs = 0,
  Options_ExpansionProperties_durations = 1,
  Options_ExpansionProperties_distances = 2,
  Options_ExpansionProperties_statuses = 3,
  Options_ExpansionProperties_edge_ids = 4,
  Options_ExpansionProperties_Options_ExpansionProperties_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Options_ExpansionProperties_Options_ExpansionProperties_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Options_ExpansionProperties_IsValid(int value);
constexpr Options_ExpansionProperties Options_ExpansionProperties_ExpansionProperties_MIN = Options_ExpansionProperties_costs;
constexpr Options_ExpansionProperties Options_ExpansionProperties_ExpansionProperties_MAX = Options_ExpansionProperties_edge_ids;
constexpr int Options_ExpansionProperties_ExpansionProperties_ARRAYSIZE = Options_ExpansionProperties_ExpansionProperties_MAX + 1;

const std::string& Options_ExpansionProperties_Name(Options_ExpansionProperties value);
template<typename T>
inline const std::string& Options_ExpansionProperties_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_ExpansionProperties>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_ExpansionProperties_Name.");
  return Options_ExpansionProperties_Name(static_cast<Options_ExpansionProperties>(enum_t_value));
}
bool Options_ExpansionProperties_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_ExpansionProperties* value);
enum ShapeMatch : int {
  walk_or_snap = 0,
  edge_walk = 1,
  map_snap = 2,
  ShapeMatch_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ShapeMatch_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ShapeMatch_IsValid(int value);
constexpr ShapeMatch ShapeMatch_MIN = walk_or_snap;
constexpr ShapeMatch ShapeMatch_MAX = map_snap;
constexpr int ShapeMatch_ARRAYSIZE = ShapeMatch_MAX + 1;

const std::string& ShapeMatch_Name(ShapeMatch value);
template<typename T>
inline const std::string& ShapeMatch_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeMatch>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeMatch_Name.");
  return ShapeMatch_Name(static_cast<ShapeMatch>(enum_t_value));
}
bool ShapeMatch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeMatch* value);
enum FilterAction : int {
  no_action = 0,
  exclude = 1,
  include = 2,
  FilterAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FilterAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FilterAction_IsValid(int value);
constexpr FilterAction FilterAction_MIN = no_action;
constexpr FilterAction FilterAction_MAX = include;
constexpr int FilterAction_ARRAYSIZE = FilterAction_MAX + 1;

const std::string& FilterAction_Name(FilterAction value);
template<typename T>
inline const std::string& FilterAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterAction_Name.");
  return FilterAction_Name(static_cast<FilterAction>(enum_t_value));
}
bool FilterAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterAction* value);
enum DirectionsType : int {
  instructions = 0,
  none = 1,
  maneuvers = 2,
  DirectionsType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DirectionsType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DirectionsType_IsValid(int value);
constexpr DirectionsType DirectionsType_MIN = instructions;
constexpr DirectionsType DirectionsType_MAX = maneuvers;
constexpr int DirectionsType_ARRAYSIZE = DirectionsType_MAX + 1;

const std::string& DirectionsType_Name(DirectionsType value);
template<typename T>
inline const std::string& DirectionsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsType_Name.");
  return DirectionsType_Name(static_cast<DirectionsType>(enum_t_value));
}
bool DirectionsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsType* value);
enum ShapeFormat : int {
  polyline6 = 0,
  polyline5 = 1,
  geojson = 2,
  ShapeFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ShapeFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ShapeFormat_IsValid(int value);
constexpr ShapeFormat ShapeFormat_MIN = polyline6;
constexpr ShapeFormat ShapeFormat_MAX = geojson;
constexpr int ShapeFormat_ARRAYSIZE = ShapeFormat_MAX + 1;

const std::string& ShapeFormat_Name(ShapeFormat value);
template<typename T>
inline const std::string& ShapeFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeFormat_Name.");
  return ShapeFormat_Name(static_cast<ShapeFormat>(enum_t_value));
}
bool ShapeFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeFormat* value);
// ===================================================================

class Contour final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Contour) */ {
 public:
  inline Contour() : Contour(nullptr) {}
  ~Contour() override;
  explicit constexpr Contour(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contour(const Contour& from);
  Contour(Contour&& from) noexcept
    : Contour() {
    *this = ::std::move(from);
  }

  inline Contour& operator=(const Contour& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contour& operator=(Contour&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Contour& default_instance() {
    return *internal_default_instance();
  }
  enum HasTimeCase {
    kTime = 1,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasColorCase {
    kColor = 2,
    HAS_COLOR_NOT_SET = 0,
  };

  enum HasDistanceCase {
    kDistance = 3,
    HAS_DISTANCE_NOT_SET = 0,
  };

  static inline const Contour* internal_default_instance() {
    return reinterpret_cast<const Contour*>(
               &_Contour_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Contour& a, Contour& b) {
    a.Swap(&b);
  }
  inline void Swap(Contour* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contour* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contour* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contour>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Contour& from);
  void MergeFrom(const Contour& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Contour* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Contour";
  }
  protected:
  explicit Contour(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kColorFieldNumber = 2,
    kDistanceFieldNumber = 3,
  };
  // float time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // string color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float distance = 3;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  void clear_has_time();
  HasTimeCase has_time_case() const;
  void clear_has_color();
  HasColorCase has_color_case() const;
  void clear_has_distance();
  HasDistanceCase has_distance_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Contour)
 private:
  class _Internal;
  void set_has_time();
  void set_has_color();
  void set_has_distance();

  inline bool has_has_time() const;
  inline void clear_has_has_time();

  inline bool has_has_color() const;
  inline void clear_has_has_color();

  inline bool has_has_distance() const;
  inline void clear_has_has_distance();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union HasTimeUnion {
    constexpr HasTimeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float time_;
  } has_time_;
  union HasColorUnion {
    constexpr HasColorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
  } has_color_;
  union HasDistanceUnion {
    constexpr HasDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float distance_;
  } has_distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[3];

  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class Ring final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Ring) */ {
 public:
  inline Ring() : Ring(nullptr) {}
  ~Ring() override;
  explicit constexpr Ring(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ring(const Ring& from);
  Ring(Ring&& from) noexcept
    : Ring() {
    *this = ::std::move(from);
  }

  inline Ring& operator=(const Ring& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ring& operator=(Ring&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Ring& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ring* internal_default_instance() {
    return reinterpret_cast<const Ring*>(
               &_Ring_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ring& a, Ring& b) {
    a.Swap(&b);
  }
  inline void Swap(Ring* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ring* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ring* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ring>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Ring& from);
  void MergeFrom(const Ring& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ring* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Ring";
  }
  protected:
  explicit Ring(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordsFieldNumber = 1,
  };
  // repeated .valhalla.LatLng coords = 1;
  int coords_size() const;
  private:
  int _internal_coords_size() const;
  public:
  void clear_coords();
  ::valhalla::LatLng* mutable_coords(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >*
      mutable_coords();
  private:
  const ::valhalla::LatLng& _internal_coords(int index) const;
  ::valhalla::LatLng* _internal_add_coords();
  public:
  const ::valhalla::LatLng& coords(int index) const;
  ::valhalla::LatLng* add_coords();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >&
      coords() const;

  // @@protoc_insertion_point(class_scope:valhalla.Ring)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng > coords_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class PbfFieldSelector final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.PbfFieldSelector) */ {
 public:
  inline PbfFieldSelector() : PbfFieldSelector(nullptr) {}
  ~PbfFieldSelector() override;
  explicit constexpr PbfFieldSelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PbfFieldSelector(const PbfFieldSelector& from);
  PbfFieldSelector(PbfFieldSelector&& from) noexcept
    : PbfFieldSelector() {
    *this = ::std::move(from);
  }

  inline PbfFieldSelector& operator=(const PbfFieldSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PbfFieldSelector& operator=(PbfFieldSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PbfFieldSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const PbfFieldSelector* internal_default_instance() {
    return reinterpret_cast<const PbfFieldSelector*>(
               &_PbfFieldSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PbfFieldSelector& a, PbfFieldSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(PbfFieldSelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PbfFieldSelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PbfFieldSelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PbfFieldSelector>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PbfFieldSelector& from);
  void MergeFrom(const PbfFieldSelector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PbfFieldSelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.PbfFieldSelector";
  }
  protected:
  explicit PbfFieldSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kTripFieldNumber = 2,
    kDirectionsFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // bool options = 1;
  void clear_options();
  bool options() const;
  void set_options(bool value);
  private:
  bool _internal_options() const;
  void _internal_set_options(bool value);
  public:

  // bool trip = 2;
  void clear_trip();
  bool trip() const;
  void set_trip(bool value);
  private:
  bool _internal_trip() const;
  void _internal_set_trip(bool value);
  public:

  // bool directions = 3;
  void clear_directions();
  bool directions() const;
  void set_directions(bool value);
  private:
  bool _internal_directions() const;
  void _internal_set_directions(bool value);
  public:

  // bool status = 4;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.PbfFieldSelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool options_;
  bool trip_;
  bool directions_;
  bool status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class AvoidEdge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.AvoidEdge) */ {
 public:
  inline AvoidEdge() : AvoidEdge(nullptr) {}
  ~AvoidEdge() override;
  explicit constexpr AvoidEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvoidEdge(const AvoidEdge& from);
  AvoidEdge(AvoidEdge&& from) noexcept
    : AvoidEdge() {
    *this = ::std::move(from);
  }

  inline AvoidEdge& operator=(const AvoidEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvoidEdge& operator=(AvoidEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AvoidEdge& default_instance() {
    return *internal_default_instance();
  }
  enum HasIdCase {
    kId = 1,
    HAS_ID_NOT_SET = 0,
  };

  enum HasPercentAlongCase {
    kPercentAlong = 2,
    HAS_PERCENT_ALONG_NOT_SET = 0,
  };

  static inline const AvoidEdge* internal_default_instance() {
    return reinterpret_cast<const AvoidEdge*>(
               &_AvoidEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AvoidEdge& a, AvoidEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(AvoidEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvoidEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvoidEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvoidEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvoidEdge& from);
  void MergeFrom(const AvoidEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvoidEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.AvoidEdge";
  }
  protected:
  explicit AvoidEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPercentAlongFieldNumber = 2,
  };
  // uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // float percent_along = 2;
  bool has_percent_along() const;
  private:
  bool _internal_has_percent_along() const;
  public:
  void clear_percent_along();
  float percent_along() const;
  void set_percent_along(float value);
  private:
  float _internal_percent_along() const;
  void _internal_set_percent_along(float value);
  public:

  void clear_has_id();
  HasIdCase has_id_case() const;
  void clear_has_percent_along();
  HasPercentAlongCase has_percent_along_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.AvoidEdge)
 private:
  class _Internal;
  void set_has_id();
  void set_has_percent_along();

  inline bool has_has_id() const;
  inline void clear_has_has_id();

  inline bool has_has_percent_along() const;
  inline void clear_has_has_percent_along();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union HasIdUnion {
    constexpr HasIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint64_t id_;
  } has_id_;
  union HasPercentAlongUnion {
    constexpr HasPercentAlongUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float percent_along_;
  } has_percent_along_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class Costing_Options final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Costing.Options) */ {
 public:
  inline Costing_Options() : Costing_Options(nullptr) {}
  ~Costing_Options() override;
  explicit constexpr Costing_Options(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Costing_Options(const Costing_Options& from);
  Costing_Options(Costing_Options&& from) noexcept
    : Costing_Options() {
    *this = ::std::move(from);
  }

  inline Costing_Options& operator=(const Costing_Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Costing_Options& operator=(Costing_Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Costing_Options& default_instance() {
    return *internal_default_instance();
  }
  enum HasManeuverPenaltyCase {
    kManeuverPenalty = 1,
    HAS_MANEUVER_PENALTY_NOT_SET = 0,
  };

  enum HasDestinationOnlyPenaltyCase {
    kDestinationOnlyPenalty = 2,
    HAS_DESTINATION_ONLY_PENALTY_NOT_SET = 0,
  };

  enum HasGateCostCase {
    kGateCost = 3,
    HAS_GATE_COST_NOT_SET = 0,
  };

  enum HasGatePenaltyCase {
    kGatePenalty = 4,
    HAS_GATE_PENALTY_NOT_SET = 0,
  };

  enum HasTollBoothCostCase {
    kTollBoothCost = 5,
    HAS_TOLL_BOOTH_COST_NOT_SET = 0,
  };

  enum HasTollBoothPenaltyCase {
    kTollBoothPenalty = 6,
    HAS_TOLL_BOOTH_PENALTY_NOT_SET = 0,
  };

  enum HasAlleyPenaltyCase {
    kAlleyPenalty = 7,
    HAS_ALLEY_PENALTY_NOT_SET = 0,
  };

  enum HasCountryCrossingCostCase {
    kCountryCrossingCost = 8,
    HAS_COUNTRY_CROSSING_COST_NOT_SET = 0,
  };

  enum HasCountryCrossingPenaltyCase {
    kCountryCrossingPenalty = 9,
    HAS_COUNTRY_CROSSING_PENALTY_NOT_SET = 0,
  };

  enum HasFerryCostCase {
    kFerryCost = 10,
    HAS_FERRY_COST_NOT_SET = 0,
  };

  enum HasAvoidBadSurfacesCase {
    kAvoidBadSurfaces = 11,
    HAS_AVOID_BAD_SURFACES_NOT_SET = 0,
  };

  enum HasUseFerryCase {
    kUseFerry = 12,
    HAS_USE_FERRY_NOT_SET = 0,
  };

  enum HasUseHighwaysCase {
    kUseHighways = 13,
    HAS_USE_HIGHWAYS_NOT_SET = 0,
  };

  enum HasUseTollsCase {
    kUseTolls = 14,
    HAS_USE_TOLLS_NOT_SET = 0,
  };

  enum HasUseRoadsCase {
    kUseRoads = 15,
    HAS_USE_ROADS_NOT_SET = 0,
  };

  enum HasMaxDistanceCase {
    kMaxDistance = 16,
    HAS_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasWalkingSpeedCase {
    kWalkingSpeed = 17,
    HAS_WALKING_SPEED_NOT_SET = 0,
  };

  enum HasStepPenaltyCase {
    kStepPenalty = 18,
    HAS_STEP_PENALTY_NOT_SET = 0,
  };

  enum HasMaxGradeCase {
    kMaxGrade = 19,
    HAS_MAX_GRADE_NOT_SET = 0,
  };

  enum HasMaxHikingDifficultyCase {
    kMaxHikingDifficulty = 20,
    HAS_MAX_HIKING_DIFFICULTY_NOT_SET = 0,
  };

  enum HasModeFactorCase {
    kModeFactor = 21,
    HAS_MODE_FACTOR_NOT_SET = 0,
  };

  enum HasWalkwayFactorCase {
    kWalkwayFactor = 22,
    HAS_WALKWAY_FACTOR_NOT_SET = 0,
  };

  enum HasSidewalkFactorCase {
    kSidewalkFactor = 23,
    HAS_SIDEWALK_FACTOR_NOT_SET = 0,
  };

  enum HasAlleyFactorCase {
    kAlleyFactor = 24,
    HAS_ALLEY_FACTOR_NOT_SET = 0,
  };

  enum HasDrivewayFactorCase {
    kDrivewayFactor = 25,
    HAS_DRIVEWAY_FACTOR_NOT_SET = 0,
  };

  enum HasDrivewayPenaltyCase {
    kDrivewayPenalty = 26,
    HAS_DRIVEWAY_PENALTY_NOT_SET = 0,
  };

  enum HasTransitStartEndMaxDistanceCase {
    kTransitStartEndMaxDistance = 27,
    HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasTransitTransferMaxDistanceCase {
    kTransitTransferMaxDistance = 28,
    HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasTransportTypeCase {
    kTransportType = 29,
    HAS_TRANSPORT_TYPE_NOT_SET = 0,
  };

  enum HasTopSpeedCase {
    kTopSpeed = 30,
    HAS_TOP_SPEED_NOT_SET = 0,
  };

  enum HasUseHillsCase {
    kUseHills = 31,
    HAS_USE_HILLS_NOT_SET = 0,
  };

  enum HasUsePrimaryCase {
    kUsePrimary = 32,
    HAS_USE_PRIMARY_NOT_SET = 0,
  };

  enum HasUseTrailsCase {
    kUseTrails = 33,
    HAS_USE_TRAILS_NOT_SET = 0,
  };

  enum HasLowClassPenaltyCase {
    kLowClassPenalty = 34,
    HAS_LOW_CLASS_PENALTY_NOT_SET = 0,
  };

  enum HasHazmatCase {
    kHazmat = 35,
    HAS_HAZMAT_NOT_SET = 0,
  };

  enum HasWeightCase {
    kWeight = 36,
    HAS_WEIGHT_NOT_SET = 0,
  };

  enum HasAxleLoadCase {
    kAxleLoad = 37,
    HAS_AXLE_LOAD_NOT_SET = 0,
  };

  enum HasHeightCase {
    kHeight = 38,
    HAS_HEIGHT_NOT_SET = 0,
  };

  enum HasWidthCase {
    kWidth = 39,
    HAS_WIDTH_NOT_SET = 0,
  };

  enum HasLengthCase {
    kLength = 40,
    HAS_LENGTH_NOT_SET = 0,
  };

  enum HasCyclingSpeedCase {
    kCyclingSpeed = 41,
    HAS_CYCLING_SPEED_NOT_SET = 0,
  };

  enum HasWheelchairCase {
    kWheelchair = 42,
    HAS_WHEELCHAIR_NOT_SET = 0,
  };

  enum HasBicycleCase {
    kBicycle = 43,
    HAS_BICYCLE_NOT_SET = 0,
  };

  enum HasUseBusCase {
    kUseBus = 44,
    HAS_USE_BUS_NOT_SET = 0,
  };

  enum HasUseRailCase {
    kUseRail = 45,
    HAS_USE_RAIL_NOT_SET = 0,
  };

  enum HasUseTransfersCase {
    kUseTransfers = 46,
    HAS_USE_TRANSFERS_NOT_SET = 0,
  };

  enum HasTransferCostCase {
    kTransferCost = 47,
    HAS_TRANSFER_COST_NOT_SET = 0,
  };

  enum HasTransferPenaltyCase {
    kTransferPenalty = 48,
    HAS_TRANSFER_PENALTY_NOT_SET = 0,
  };

  enum HasFlowMaskCase {
    kFlowMask = 55,
    HAS_FLOW_MASK_NOT_SET = 0,
  };

  enum HasBikeShareCostCase {
    kBikeShareCost = 56,
    HAS_BIKE_SHARE_COST_NOT_SET = 0,
  };

  enum HasBikeSharePenaltyCase {
    kBikeSharePenalty = 57,
    HAS_BIKE_SHARE_PENALTY_NOT_SET = 0,
  };

  enum HasRailFerryCostCase {
    kRailFerryCost = 58,
    HAS_RAIL_FERRY_COST_NOT_SET = 0,
  };

  enum HasUseRailFerryCase {
    kUseRailFerry = 59,
    HAS_USE_RAIL_FERRY_NOT_SET = 0,
  };

  enum HasIgnoreRestrictionsCase {
    kIgnoreRestrictions = 60,
    HAS_IGNORE_RESTRICTIONS_NOT_SET = 0,
  };

  enum HasIgnoreOnewaysCase {
    kIgnoreOneways = 61,
    HAS_IGNORE_ONEWAYS_NOT_SET = 0,
  };

  enum HasIgnoreAccessCase {
    kIgnoreAccess = 62,
    HAS_IGNORE_ACCESS_NOT_SET = 0,
  };

  enum HasIgnoreClosuresCase {
    kIgnoreClosures = 63,
    HAS_IGNORE_CLOSURES_NOT_SET = 0,
  };

  enum HasShortestCase {
    kShortest = 64,
    HAS_SHORTEST_NOT_SET = 0,
  };

  enum HasServicePenaltyCase {
    kServicePenalty = 65,
    HAS_SERVICE_PENALTY_NOT_SET = 0,
  };

  enum HasUseTracksCase {
    kUseTracks = 66,
    HAS_USE_TRACKS_NOT_SET = 0,
  };

  enum HasUseDistanceCase {
    kUseDistance = 67,
    HAS_USE_DISTANCE_NOT_SET = 0,
  };

  enum HasUseLivingStreetsCase {
    kUseLivingStreets = 68,
    HAS_USE_LIVING_STREETS_NOT_SET = 0,
  };

  enum HasServiceFactorCase {
    kServiceFactor = 69,
    HAS_SERVICE_FACTOR_NOT_SET = 0,
  };

  enum HasClosureFactorCase {
    kClosureFactor = 70,
    HAS_CLOSURE_FACTOR_NOT_SET = 0,
  };

  enum HasPrivateAccessPenaltyCase {
    kPrivateAccessPenalty = 71,
    HAS_PRIVATE_ACCESS_PENALTY_NOT_SET = 0,
  };

  enum HasExcludeUnpavedCase {
    kExcludeUnpaved = 72,
    HAS_EXCLUDE_UNPAVED_NOT_SET = 0,
  };

  enum HasIncludeHotCase {
    kIncludeHot = 73,
    HAS_INCLUDE_HOT_NOT_SET = 0,
  };

  enum HasIncludeHov2Case {
    kIncludeHov2 = 74,
    HAS_INCLUDE_HOV2_NOT_SET = 0,
  };

  enum HasIncludeHov3Case {
    kIncludeHov3 = 75,
    HAS_INCLUDE_HOV3_NOT_SET = 0,
  };

  enum HasExcludeCashOnlyTollsCase {
    kExcludeCashOnlyTolls = 76,
    HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET = 0,
  };

  enum HasRestrictionProbabilityCase {
    kRestrictionProbability = 77,
    HAS_RESTRICTION_PROBABILITY_NOT_SET = 0,
  };

  enum HasElevatorPenaltyCase {
    kElevatorPenalty = 79,
    HAS_ELEVATOR_PENALTY_NOT_SET = 0,
  };

  static inline const Costing_Options* internal_default_instance() {
    return reinterpret_cast<const Costing_Options*>(
               &_Costing_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Costing_Options& a, Costing_Options& b) {
    a.Swap(&b);
  }
  inline void Swap(Costing_Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Costing_Options* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Costing_Options* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Costing_Options>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Costing_Options& from);
  void MergeFrom(const Costing_Options& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Costing_Options* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Costing.Options";
  }
  protected:
  explicit Costing_Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterStopIdsFieldNumber = 50,
    kFilterOperatorIdsFieldNumber = 52,
    kFilterRouteIdsFieldNumber = 54,
    kExcludeEdgesFieldNumber = 78,
    kFilterRouteActionFieldNumber = 53,
    kFilterStopActionFieldNumber = 49,
    kFilterOperatorActionFieldNumber = 51,
    kManeuverPenaltyFieldNumber = 1,
    kDestinationOnlyPenaltyFieldNumber = 2,
    kGateCostFieldNumber = 3,
    kGatePenaltyFieldNumber = 4,
    kTollBoothCostFieldNumber = 5,
    kTollBoothPenaltyFieldNumber = 6,
    kAlleyPenaltyFieldNumber = 7,
    kCountryCrossingCostFieldNumber = 8,
    kCountryCrossingPenaltyFieldNumber = 9,
    kFerryCostFieldNumber = 10,
    kAvoidBadSurfacesFieldNumber = 11,
    kUseFerryFieldNumber = 12,
    kUseHighwaysFieldNumber = 13,
    kUseTollsFieldNumber = 14,
    kUseRoadsFieldNumber = 15,
    kMaxDistanceFieldNumber = 16,
    kWalkingSpeedFieldNumber = 17,
    kStepPenaltyFieldNumber = 18,
    kMaxGradeFieldNumber = 19,
    kMaxHikingDifficultyFieldNumber = 20,
    kModeFactorFieldNumber = 21,
    kWalkwayFactorFieldNumber = 22,
    kSidewalkFactorFieldNumber = 23,
    kAlleyFactorFieldNumber = 24,
    kDrivewayFactorFieldNumber = 25,
    kDrivewayPenaltyFieldNumber = 26,
    kTransitStartEndMaxDistanceFieldNumber = 27,
    kTransitTransferMaxDistanceFieldNumber = 28,
    kTransportTypeFieldNumber = 29,
    kTopSpeedFieldNumber = 30,
    kUseHillsFieldNumber = 31,
    kUsePrimaryFieldNumber = 32,
    kUseTrailsFieldNumber = 33,
    kLowClassPenaltyFieldNumber = 34,
    kHazmatFieldNumber = 35,
    kWeightFieldNumber = 36,
    kAxleLoadFieldNumber = 37,
    kHeightFieldNumber = 38,
    kWidthFieldNumber = 39,
    kLengthFieldNumber = 40,
    kCyclingSpeedFieldNumber = 41,
    kWheelchairFieldNumber = 42,
    kBicycleFieldNumber = 43,
    kUseBusFieldNumber = 44,
    kUseRailFieldNumber = 45,
    kUseTransfersFieldNumber = 46,
    kTransferCostFieldNumber = 47,
    kTransferPenaltyFieldNumber = 48,
    kFlowMaskFieldNumber = 55,
    kBikeShareCostFieldNumber = 56,
    kBikeSharePenaltyFieldNumber = 57,
    kRailFerryCostFieldNumber = 58,
    kUseRailFerryFieldNumber = 59,
    kIgnoreRestrictionsFieldNumber = 60,
    kIgnoreOnewaysFieldNumber = 61,
    kIgnoreAccessFieldNumber = 62,
    kIgnoreClosuresFieldNumber = 63,
    kShortestFieldNumber = 64,
    kServicePenaltyFieldNumber = 65,
    kUseTracksFieldNumber = 66,
    kUseDistanceFieldNumber = 67,
    kUseLivingStreetsFieldNumber = 68,
    kServiceFactorFieldNumber = 69,
    kClosureFactorFieldNumber = 70,
    kPrivateAccessPenaltyFieldNumber = 71,
    kExcludeUnpavedFieldNumber = 72,
    kIncludeHotFieldNumber = 73,
    kIncludeHov2FieldNumber = 74,
    kIncludeHov3FieldNumber = 75,
    kExcludeCashOnlyTollsFieldNumber = 76,
    kRestrictionProbabilityFieldNumber = 77,
    kElevatorPenaltyFieldNumber = 79,
  };
  // repeated string filter_stop_ids = 50;
  int filter_stop_ids_size() const;
  private:
  int _internal_filter_stop_ids_size() const;
  public:
  void clear_filter_stop_ids();
  const std::string& filter_stop_ids(int index) const;
  std::string* mutable_filter_stop_ids(int index);
  void set_filter_stop_ids(int index, const std::string& value);
  void set_filter_stop_ids(int index, std::string&& value);
  void set_filter_stop_ids(int index, const char* value);
  void set_filter_stop_ids(int index, const char* value, size_t size);
  std::string* add_filter_stop_ids();
  void add_filter_stop_ids(const std::string& value);
  void add_filter_stop_ids(std::string&& value);
  void add_filter_stop_ids(const char* value);
  void add_filter_stop_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_stop_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_stop_ids();
  private:
  const std::string& _internal_filter_stop_ids(int index) const;
  std::string* _internal_add_filter_stop_ids();
  public:

  // repeated string filter_operator_ids = 52;
  int filter_operator_ids_size() const;
  private:
  int _internal_filter_operator_ids_size() const;
  public:
  void clear_filter_operator_ids();
  const std::string& filter_operator_ids(int index) const;
  std::string* mutable_filter_operator_ids(int index);
  void set_filter_operator_ids(int index, const std::string& value);
  void set_filter_operator_ids(int index, std::string&& value);
  void set_filter_operator_ids(int index, const char* value);
  void set_filter_operator_ids(int index, const char* value, size_t size);
  std::string* add_filter_operator_ids();
  void add_filter_operator_ids(const std::string& value);
  void add_filter_operator_ids(std::string&& value);
  void add_filter_operator_ids(const char* value);
  void add_filter_operator_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_operator_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_operator_ids();
  private:
  const std::string& _internal_filter_operator_ids(int index) const;
  std::string* _internal_add_filter_operator_ids();
  public:

  // repeated string filter_route_ids = 54;
  int filter_route_ids_size() const;
  private:
  int _internal_filter_route_ids_size() const;
  public:
  void clear_filter_route_ids();
  const std::string& filter_route_ids(int index) const;
  std::string* mutable_filter_route_ids(int index);
  void set_filter_route_ids(int index, const std::string& value);
  void set_filter_route_ids(int index, std::string&& value);
  void set_filter_route_ids(int index, const char* value);
  void set_filter_route_ids(int index, const char* value, size_t size);
  std::string* add_filter_route_ids();
  void add_filter_route_ids(const std::string& value);
  void add_filter_route_ids(std::string&& value);
  void add_filter_route_ids(const char* value);
  void add_filter_route_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_route_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_route_ids();
  private:
  const std::string& _internal_filter_route_ids(int index) const;
  std::string* _internal_add_filter_route_ids();
  public:

  // repeated .valhalla.AvoidEdge exclude_edges = 78;
  int exclude_edges_size() const;
  private:
  int _internal_exclude_edges_size() const;
  public:
  void clear_exclude_edges();
  ::valhalla::AvoidEdge* mutable_exclude_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >*
      mutable_exclude_edges();
  private:
  const ::valhalla::AvoidEdge& _internal_exclude_edges(int index) const;
  ::valhalla::AvoidEdge* _internal_add_exclude_edges();
  public:
  const ::valhalla::AvoidEdge& exclude_edges(int index) const;
  ::valhalla::AvoidEdge* add_exclude_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >&
      exclude_edges() const;

  // .valhalla.FilterAction filter_route_action = 53;
  void clear_filter_route_action();
  ::valhalla::FilterAction filter_route_action() const;
  void set_filter_route_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_route_action() const;
  void _internal_set_filter_route_action(::valhalla::FilterAction value);
  public:

  // .valhalla.FilterAction filter_stop_action = 49;
  void clear_filter_stop_action();
  ::valhalla::FilterAction filter_stop_action() const;
  void set_filter_stop_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_stop_action() const;
  void _internal_set_filter_stop_action(::valhalla::FilterAction value);
  public:

  // .valhalla.FilterAction filter_operator_action = 51;
  void clear_filter_operator_action();
  ::valhalla::FilterAction filter_operator_action() const;
  void set_filter_operator_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_operator_action() const;
  void _internal_set_filter_operator_action(::valhalla::FilterAction value);
  public:

  // float maneuver_penalty = 1;
  bool has_maneuver_penalty() const;
  private:
  bool _internal_has_maneuver_penalty() const;
  public:
  void clear_maneuver_penalty();
  float maneuver_penalty() const;
  void set_maneuver_penalty(float value);
  private:
  float _internal_maneuver_penalty() const;
  void _internal_set_maneuver_penalty(float value);
  public:

  // float destination_only_penalty = 2;
  bool has_destination_only_penalty() const;
  private:
  bool _internal_has_destination_only_penalty() const;
  public:
  void clear_destination_only_penalty();
  float destination_only_penalty() const;
  void set_destination_only_penalty(float value);
  private:
  float _internal_destination_only_penalty() const;
  void _internal_set_destination_only_penalty(float value);
  public:

  // float gate_cost = 3;
  bool has_gate_cost() const;
  private:
  bool _internal_has_gate_cost() const;
  public:
  void clear_gate_cost();
  float gate_cost() const;
  void set_gate_cost(float value);
  private:
  float _internal_gate_cost() const;
  void _internal_set_gate_cost(float value);
  public:

  // float gate_penalty = 4;
  bool has_gate_penalty() const;
  private:
  bool _internal_has_gate_penalty() const;
  public:
  void clear_gate_penalty();
  float gate_penalty() const;
  void set_gate_penalty(float value);
  private:
  float _internal_gate_penalty() const;
  void _internal_set_gate_penalty(float value);
  public:

  // float toll_booth_cost = 5;
  bool has_toll_booth_cost() const;
  private:
  bool _internal_has_toll_booth_cost() const;
  public:
  void clear_toll_booth_cost();
  float toll_booth_cost() const;
  void set_toll_booth_cost(float value);
  private:
  float _internal_toll_booth_cost() const;
  void _internal_set_toll_booth_cost(float value);
  public:

  // float toll_booth_penalty = 6;
  bool has_toll_booth_penalty() const;
  private:
  bool _internal_has_toll_booth_penalty() const;
  public:
  void clear_toll_booth_penalty();
  float toll_booth_penalty() const;
  void set_toll_booth_penalty(float value);
  private:
  float _internal_toll_booth_penalty() const;
  void _internal_set_toll_booth_penalty(float value);
  public:

  // float alley_penalty = 7;
  bool has_alley_penalty() const;
  private:
  bool _internal_has_alley_penalty() const;
  public:
  void clear_alley_penalty();
  float alley_penalty() const;
  void set_alley_penalty(float value);
  private:
  float _internal_alley_penalty() const;
  void _internal_set_alley_penalty(float value);
  public:

  // float country_crossing_cost = 8;
  bool has_country_crossing_cost() const;
  private:
  bool _internal_has_country_crossing_cost() const;
  public:
  void clear_country_crossing_cost();
  float country_crossing_cost() const;
  void set_country_crossing_cost(float value);
  private:
  float _internal_country_crossing_cost() const;
  void _internal_set_country_crossing_cost(float value);
  public:

  // float country_crossing_penalty = 9;
  bool has_country_crossing_penalty() const;
  private:
  bool _internal_has_country_crossing_penalty() const;
  public:
  void clear_country_crossing_penalty();
  float country_crossing_penalty() const;
  void set_country_crossing_penalty(float value);
  private:
  float _internal_country_crossing_penalty() const;
  void _internal_set_country_crossing_penalty(float value);
  public:

  // float ferry_cost = 10;
  bool has_ferry_cost() const;
  private:
  bool _internal_has_ferry_cost() const;
  public:
  void clear_ferry_cost();
  float ferry_cost() const;
  void set_ferry_cost(float value);
  private:
  float _internal_ferry_cost() const;
  void _internal_set_ferry_cost(float value);
  public:

  // float avoid_bad_surfaces = 11;
  bool has_avoid_bad_surfaces() const;
  private:
  bool _internal_has_avoid_bad_surfaces() const;
  public:
  void clear_avoid_bad_surfaces();
  float avoid_bad_surfaces() const;
  void set_avoid_bad_surfaces(float value);
  private:
  float _internal_avoid_bad_surfaces() const;
  void _internal_set_avoid_bad_surfaces(float value);
  public:

  // float use_ferry = 12;
  bool has_use_ferry() const;
  private:
  bool _internal_has_use_ferry() const;
  public:
  void clear_use_ferry();
  float use_ferry() const;
  void set_use_ferry(float value);
  private:
  float _internal_use_ferry() const;
  void _internal_set_use_ferry(float value);
  public:

  // float use_highways = 13;
  bool has_use_highways() const;
  private:
  bool _internal_has_use_highways() const;
  public:
  void clear_use_highways();
  float use_highways() const;
  void set_use_highways(float value);
  private:
  float _internal_use_highways() const;
  void _internal_set_use_highways(float value);
  public:

  // float use_tolls = 14;
  bool has_use_tolls() const;
  private:
  bool _internal_has_use_tolls() const;
  public:
  void clear_use_tolls();
  float use_tolls() const;
  void set_use_tolls(float value);
  private:
  float _internal_use_tolls() const;
  void _internal_set_use_tolls(float value);
  public:

  // float use_roads = 15;
  bool has_use_roads() const;
  private:
  bool _internal_has_use_roads() const;
  public:
  void clear_use_roads();
  float use_roads() const;
  void set_use_roads(float value);
  private:
  float _internal_use_roads() const;
  void _internal_set_use_roads(float value);
  public:

  // uint32 max_distance = 16;
  bool has_max_distance() const;
  private:
  bool _internal_has_max_distance() const;
  public:
  void clear_max_distance();
  uint32_t max_distance() const;
  void set_max_distance(uint32_t value);
  private:
  uint32_t _internal_max_distance() const;
  void _internal_set_max_distance(uint32_t value);
  public:

  // float walking_speed = 17;
  bool has_walking_speed() const;
  private:
  bool _internal_has_walking_speed() const;
  public:
  void clear_walking_speed();
  float walking_speed() const;
  void set_walking_speed(float value);
  private:
  float _internal_walking_speed() const;
  void _internal_set_walking_speed(float value);
  public:

  // float step_penalty = 18;
  bool has_step_penalty() const;
  private:
  bool _internal_has_step_penalty() const;
  public:
  void clear_step_penalty();
  float step_penalty() const;
  void set_step_penalty(float value);
  private:
  float _internal_step_penalty() const;
  void _internal_set_step_penalty(float value);
  public:

  // uint32 max_grade = 19;
  bool has_max_grade() const;
  private:
  bool _internal_has_max_grade() const;
  public:
  void clear_max_grade();
  uint32_t max_grade() const;
  void set_max_grade(uint32_t value);
  private:
  uint32_t _internal_max_grade() const;
  void _internal_set_max_grade(uint32_t value);
  public:

  // uint32 max_hiking_difficulty = 20;
  bool has_max_hiking_difficulty() const;
  private:
  bool _internal_has_max_hiking_difficulty() const;
  public:
  void clear_max_hiking_difficulty();
  uint32_t max_hiking_difficulty() const;
  void set_max_hiking_difficulty(uint32_t value);
  private:
  uint32_t _internal_max_hiking_difficulty() const;
  void _internal_set_max_hiking_difficulty(uint32_t value);
  public:

  // float mode_factor = 21;
  bool has_mode_factor() const;
  private:
  bool _internal_has_mode_factor() const;
  public:
  void clear_mode_factor();
  float mode_factor() const;
  void set_mode_factor(float value);
  private:
  float _internal_mode_factor() const;
  void _internal_set_mode_factor(float value);
  public:

  // float walkway_factor = 22;
  bool has_walkway_factor() const;
  private:
  bool _internal_has_walkway_factor() const;
  public:
  void clear_walkway_factor();
  float walkway_factor() const;
  void set_walkway_factor(float value);
  private:
  float _internal_walkway_factor() const;
  void _internal_set_walkway_factor(float value);
  public:

  // float sidewalk_factor = 23;
  bool has_sidewalk_factor() const;
  private:
  bool _internal_has_sidewalk_factor() const;
  public:
  void clear_sidewalk_factor();
  float sidewalk_factor() const;
  void set_sidewalk_factor(float value);
  private:
  float _internal_sidewalk_factor() const;
  void _internal_set_sidewalk_factor(float value);
  public:

  // float alley_factor = 24;
  bool has_alley_factor() const;
  private:
  bool _internal_has_alley_factor() const;
  public:
  void clear_alley_factor();
  float alley_factor() const;
  void set_alley_factor(float value);
  private:
  float _internal_alley_factor() const;
  void _internal_set_alley_factor(float value);
  public:

  // float driveway_factor = 25;
  bool has_driveway_factor() const;
  private:
  bool _internal_has_driveway_factor() const;
  public:
  void clear_driveway_factor();
  float driveway_factor() const;
  void set_driveway_factor(float value);
  private:
  float _internal_driveway_factor() const;
  void _internal_set_driveway_factor(float value);
  public:

  // float driveway_penalty = 26;
  bool has_driveway_penalty() const;
  private:
  bool _internal_has_driveway_penalty() const;
  public:
  void clear_driveway_penalty();
  float driveway_penalty() const;
  void set_driveway_penalty(float value);
  private:
  float _internal_driveway_penalty() const;
  void _internal_set_driveway_penalty(float value);
  public:

  // uint32 transit_start_end_max_distance = 27;
  bool has_transit_start_end_max_distance() const;
  private:
  bool _internal_has_transit_start_end_max_distance() const;
  public:
  void clear_transit_start_end_max_distance();
  uint32_t transit_start_end_max_distance() const;
  void set_transit_start_end_max_distance(uint32_t value);
  private:
  uint32_t _internal_transit_start_end_max_distance() const;
  void _internal_set_transit_start_end_max_distance(uint32_t value);
  public:

  // uint32 transit_transfer_max_distance = 28;
  bool has_transit_transfer_max_distance() const;
  private:
  bool _internal_has_transit_transfer_max_distance() const;
  public:
  void clear_transit_transfer_max_distance();
  uint32_t transit_transfer_max_distance() const;
  void set_transit_transfer_max_distance(uint32_t value);
  private:
  uint32_t _internal_transit_transfer_max_distance() const;
  void _internal_set_transit_transfer_max_distance(uint32_t value);
  public:

  // string transport_type = 29;
  bool has_transport_type() const;
  private:
  bool _internal_has_transport_type() const;
  public:
  void clear_transport_type();
  const std::string& transport_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transport_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transport_type();
  PROTOBUF_NODISCARD std::string* release_transport_type();
  void set_allocated_transport_type(std::string* transport_type);
  private:
  const std::string& _internal_transport_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport_type(const std::string& value);
  std::string* _internal_mutable_transport_type();
  public:

  // float top_speed = 30;
  bool has_top_speed() const;
  private:
  bool _internal_has_top_speed() const;
  public:
  void clear_top_speed();
  float top_speed() const;
  void set_top_speed(float value);
  private:
  float _internal_top_speed() const;
  void _internal_set_top_speed(float value);
  public:

  // float use_hills = 31;
  bool has_use_hills() const;
  private:
  bool _internal_has_use_hills() const;
  public:
  void clear_use_hills();
  float use_hills() const;
  void set_use_hills(float value);
  private:
  float _internal_use_hills() const;
  void _internal_set_use_hills(float value);
  public:

  // float use_primary = 32;
  bool has_use_primary() const;
  private:
  bool _internal_has_use_primary() const;
  public:
  void clear_use_primary();
  float use_primary() const;
  void set_use_primary(float value);
  private:
  float _internal_use_primary() const;
  void _internal_set_use_primary(float value);
  public:

  // float use_trails = 33;
  bool has_use_trails() const;
  private:
  bool _internal_has_use_trails() const;
  public:
  void clear_use_trails();
  float use_trails() const;
  void set_use_trails(float value);
  private:
  float _internal_use_trails() const;
  void _internal_set_use_trails(float value);
  public:

  // float low_class_penalty = 34;
  bool has_low_class_penalty() const;
  private:
  bool _internal_has_low_class_penalty() const;
  public:
  void clear_low_class_penalty();
  float low_class_penalty() const;
  void set_low_class_penalty(float value);
  private:
  float _internal_low_class_penalty() const;
  void _internal_set_low_class_penalty(float value);
  public:

  // bool hazmat = 35;
  bool has_hazmat() const;
  private:
  bool _internal_has_hazmat() const;
  public:
  void clear_hazmat();
  bool hazmat() const;
  void set_hazmat(bool value);
  private:
  bool _internal_hazmat() const;
  void _internal_set_hazmat(bool value);
  public:

  // float weight = 36;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  float weight() const;
  void set_weight(float value);
  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);
  public:

  // float axle_load = 37;
  bool has_axle_load() const;
  private:
  bool _internal_has_axle_load() const;
  public:
  void clear_axle_load();
  float axle_load() const;
  void set_axle_load(float value);
  private:
  float _internal_axle_load() const;
  void _internal_set_axle_load(float value);
  public:

  // float height = 38;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float width = 39;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float length = 40;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // float cycling_speed = 41;
  bool has_cycling_speed() const;
  private:
  bool _internal_has_cycling_speed() const;
  public:
  void clear_cycling_speed();
  float cycling_speed() const;
  void set_cycling_speed(float value);
  private:
  float _internal_cycling_speed() const;
  void _internal_set_cycling_speed(float value);
  public:

  // bool wheelchair = 42;
  bool has_wheelchair() const;
  private:
  bool _internal_has_wheelchair() const;
  public:
  void clear_wheelchair();
  bool wheelchair() const;
  void set_wheelchair(bool value);
  private:
  bool _internal_wheelchair() const;
  void _internal_set_wheelchair(bool value);
  public:

  // bool bicycle = 43;
  bool has_bicycle() const;
  private:
  bool _internal_has_bicycle() const;
  public:
  void clear_bicycle();
  bool bicycle() const;
  void set_bicycle(bool value);
  private:
  bool _internal_bicycle() const;
  void _internal_set_bicycle(bool value);
  public:

  // float use_bus = 44;
  bool has_use_bus() const;
  private:
  bool _internal_has_use_bus() const;
  public:
  void clear_use_bus();
  float use_bus() const;
  void set_use_bus(float value);
  private:
  float _internal_use_bus() const;
  void _internal_set_use_bus(float value);
  public:

  // float use_rail = 45;
  bool has_use_rail() const;
  private:
  bool _internal_has_use_rail() const;
  public:
  void clear_use_rail();
  float use_rail() const;
  void set_use_rail(float value);
  private:
  float _internal_use_rail() const;
  void _internal_set_use_rail(float value);
  public:

  // float use_transfers = 46;
  bool has_use_transfers() const;
  private:
  bool _internal_has_use_transfers() const;
  public:
  void clear_use_transfers();
  float use_transfers() const;
  void set_use_transfers(float value);
  private:
  float _internal_use_transfers() const;
  void _internal_set_use_transfers(float value);
  public:

  // float transfer_cost = 47;
  bool has_transfer_cost() const;
  private:
  bool _internal_has_transfer_cost() const;
  public:
  void clear_transfer_cost();
  float transfer_cost() const;
  void set_transfer_cost(float value);
  private:
  float _internal_transfer_cost() const;
  void _internal_set_transfer_cost(float value);
  public:

  // float transfer_penalty = 48;
  bool has_transfer_penalty() const;
  private:
  bool _internal_has_transfer_penalty() const;
  public:
  void clear_transfer_penalty();
  float transfer_penalty() const;
  void set_transfer_penalty(float value);
  private:
  float _internal_transfer_penalty() const;
  void _internal_set_transfer_penalty(float value);
  public:

  // uint32 flow_mask = 55;
  bool has_flow_mask() const;
  private:
  bool _internal_has_flow_mask() const;
  public:
  void clear_flow_mask();
  uint32_t flow_mask() const;
  void set_flow_mask(uint32_t value);
  private:
  uint32_t _internal_flow_mask() const;
  void _internal_set_flow_mask(uint32_t value);
  public:

  // float bike_share_cost = 56;
  bool has_bike_share_cost() const;
  private:
  bool _internal_has_bike_share_cost() const;
  public:
  void clear_bike_share_cost();
  float bike_share_cost() const;
  void set_bike_share_cost(float value);
  private:
  float _internal_bike_share_cost() const;
  void _internal_set_bike_share_cost(float value);
  public:

  // float bike_share_penalty = 57;
  bool has_bike_share_penalty() const;
  private:
  bool _internal_has_bike_share_penalty() const;
  public:
  void clear_bike_share_penalty();
  float bike_share_penalty() const;
  void set_bike_share_penalty(float value);
  private:
  float _internal_bike_share_penalty() const;
  void _internal_set_bike_share_penalty(float value);
  public:

  // float rail_ferry_cost = 58;
  bool has_rail_ferry_cost() const;
  private:
  bool _internal_has_rail_ferry_cost() const;
  public:
  void clear_rail_ferry_cost();
  float rail_ferry_cost() const;
  void set_rail_ferry_cost(float value);
  private:
  float _internal_rail_ferry_cost() const;
  void _internal_set_rail_ferry_cost(float value);
  public:

  // float use_rail_ferry = 59;
  bool has_use_rail_ferry() const;
  private:
  bool _internal_has_use_rail_ferry() const;
  public:
  void clear_use_rail_ferry();
  float use_rail_ferry() const;
  void set_use_rail_ferry(float value);
  private:
  float _internal_use_rail_ferry() const;
  void _internal_set_use_rail_ferry(float value);
  public:

  // bool ignore_restrictions = 60;
  bool has_ignore_restrictions() const;
  private:
  bool _internal_has_ignore_restrictions() const;
  public:
  void clear_ignore_restrictions();
  bool ignore_restrictions() const;
  void set_ignore_restrictions(bool value);
  private:
  bool _internal_ignore_restrictions() const;
  void _internal_set_ignore_restrictions(bool value);
  public:

  // bool ignore_oneways = 61;
  bool has_ignore_oneways() const;
  private:
  bool _internal_has_ignore_oneways() const;
  public:
  void clear_ignore_oneways();
  bool ignore_oneways() const;
  void set_ignore_oneways(bool value);
  private:
  bool _internal_ignore_oneways() const;
  void _internal_set_ignore_oneways(bool value);
  public:

  // bool ignore_access = 62;
  bool has_ignore_access() const;
  private:
  bool _internal_has_ignore_access() const;
  public:
  void clear_ignore_access();
  bool ignore_access() const;
  void set_ignore_access(bool value);
  private:
  bool _internal_ignore_access() const;
  void _internal_set_ignore_access(bool value);
  public:

  // bool ignore_closures = 63;
  bool has_ignore_closures() const;
  private:
  bool _internal_has_ignore_closures() const;
  public:
  void clear_ignore_closures();
  bool ignore_closures() const;
  void set_ignore_closures(bool value);
  private:
  bool _internal_ignore_closures() const;
  void _internal_set_ignore_closures(bool value);
  public:

  // bool shortest = 64;
  bool has_shortest() const;
  private:
  bool _internal_has_shortest() const;
  public:
  void clear_shortest();
  bool shortest() const;
  void set_shortest(bool value);
  private:
  bool _internal_shortest() const;
  void _internal_set_shortest(bool value);
  public:

  // float service_penalty = 65;
  bool has_service_penalty() const;
  private:
  bool _internal_has_service_penalty() const;
  public:
  void clear_service_penalty();
  float service_penalty() const;
  void set_service_penalty(float value);
  private:
  float _internal_service_penalty() const;
  void _internal_set_service_penalty(float value);
  public:

  // float use_tracks = 66;
  bool has_use_tracks() const;
  private:
  bool _internal_has_use_tracks() const;
  public:
  void clear_use_tracks();
  float use_tracks() const;
  void set_use_tracks(float value);
  private:
  float _internal_use_tracks() const;
  void _internal_set_use_tracks(float value);
  public:

  // float use_distance = 67;
  bool has_use_distance() const;
  private:
  bool _internal_has_use_distance() const;
  public:
  void clear_use_distance();
  float use_distance() const;
  void set_use_distance(float value);
  private:
  float _internal_use_distance() const;
  void _internal_set_use_distance(float value);
  public:

  // float use_living_streets = 68;
  bool has_use_living_streets() const;
  private:
  bool _internal_has_use_living_streets() const;
  public:
  void clear_use_living_streets();
  float use_living_streets() const;
  void set_use_living_streets(float value);
  private:
  float _internal_use_living_streets() const;
  void _internal_set_use_living_streets(float value);
  public:

  // float service_factor = 69;
  bool has_service_factor() const;
  private:
  bool _internal_has_service_factor() const;
  public:
  void clear_service_factor();
  float service_factor() const;
  void set_service_factor(float value);
  private:
  float _internal_service_factor() const;
  void _internal_set_service_factor(float value);
  public:

  // float closure_factor = 70;
  bool has_closure_factor() const;
  private:
  bool _internal_has_closure_factor() const;
  public:
  void clear_closure_factor();
  float closure_factor() const;
  void set_closure_factor(float value);
  private:
  float _internal_closure_factor() const;
  void _internal_set_closure_factor(float value);
  public:

  // float private_access_penalty = 71;
  bool has_private_access_penalty() const;
  private:
  bool _internal_has_private_access_penalty() const;
  public:
  void clear_private_access_penalty();
  float private_access_penalty() const;
  void set_private_access_penalty(float value);
  private:
  float _internal_private_access_penalty() const;
  void _internal_set_private_access_penalty(float value);
  public:

  // bool exclude_unpaved = 72;
  bool has_exclude_unpaved() const;
  private:
  bool _internal_has_exclude_unpaved() const;
  public:
  void clear_exclude_unpaved();
  bool exclude_unpaved() const;
  void set_exclude_unpaved(bool value);
  private:
  bool _internal_exclude_unpaved() const;
  void _internal_set_exclude_unpaved(bool value);
  public:

  // bool include_hot = 73;
  bool has_include_hot() const;
  private:
  bool _internal_has_include_hot() const;
  public:
  void clear_include_hot();
  bool include_hot() const;
  void set_include_hot(bool value);
  private:
  bool _internal_include_hot() const;
  void _internal_set_include_hot(bool value);
  public:

  // bool include_hov2 = 74;
  bool has_include_hov2() const;
  private:
  bool _internal_has_include_hov2() const;
  public:
  void clear_include_hov2();
  bool include_hov2() const;
  void set_include_hov2(bool value);
  private:
  bool _internal_include_hov2() const;
  void _internal_set_include_hov2(bool value);
  public:

  // bool include_hov3 = 75;
  bool has_include_hov3() const;
  private:
  bool _internal_has_include_hov3() const;
  public:
  void clear_include_hov3();
  bool include_hov3() const;
  void set_include_hov3(bool value);
  private:
  bool _internal_include_hov3() const;
  void _internal_set_include_hov3(bool value);
  public:

  // bool exclude_cash_only_tolls = 76;
  bool has_exclude_cash_only_tolls() const;
  private:
  bool _internal_has_exclude_cash_only_tolls() const;
  public:
  void clear_exclude_cash_only_tolls();
  bool exclude_cash_only_tolls() const;
  void set_exclude_cash_only_tolls(bool value);
  private:
  bool _internal_exclude_cash_only_tolls() const;
  void _internal_set_exclude_cash_only_tolls(bool value);
  public:

  // uint32 restriction_probability = 77;
  bool has_restriction_probability() const;
  private:
  bool _internal_has_restriction_probability() const;
  public:
  void clear_restriction_probability();
  uint32_t restriction_probability() const;
  void set_restriction_probability(uint32_t value);
  private:
  uint32_t _internal_restriction_probability() const;
  void _internal_set_restriction_probability(uint32_t value);
  public:

  // float elevator_penalty = 79;
  bool has_elevator_penalty() const;
  private:
  bool _internal_has_elevator_penalty() const;
  public:
  void clear_elevator_penalty();
  float elevator_penalty() const;
  void set_elevator_penalty(float value);
  private:
  float _internal_elevator_penalty() const;
  void _internal_set_elevator_penalty(float value);
  public:

  void clear_has_maneuver_penalty();
  HasManeuverPenaltyCase has_maneuver_penalty_case() const;
  void clear_has_destination_only_penalty();
  HasDestinationOnlyPenaltyCase has_destination_only_penalty_case() const;
  void clear_has_gate_cost();
  HasGateCostCase has_gate_cost_case() const;
  void clear_has_gate_penalty();
  HasGatePenaltyCase has_gate_penalty_case() const;
  void clear_has_toll_booth_cost();
  HasTollBoothCostCase has_toll_booth_cost_case() const;
  void clear_has_toll_booth_penalty();
  HasTollBoothPenaltyCase has_toll_booth_penalty_case() const;
  void clear_has_alley_penalty();
  HasAlleyPenaltyCase has_alley_penalty_case() const;
  void clear_has_country_crossing_cost();
  HasCountryCrossingCostCase has_country_crossing_cost_case() const;
  void clear_has_country_crossing_penalty();
  HasCountryCrossingPenaltyCase has_country_crossing_penalty_case() const;
  void clear_has_ferry_cost();
  HasFerryCostCase has_ferry_cost_case() const;
  void clear_has_avoid_bad_surfaces();
  HasAvoidBadSurfacesCase has_avoid_bad_surfaces_case() const;
  void clear_has_use_ferry();
  HasUseFerryCase has_use_ferry_case() const;
  void clear_has_use_highways();
  HasUseHighwaysCase has_use_highways_case() const;
  void clear_has_use_tolls();
  HasUseTollsCase has_use_tolls_case() const;
  void clear_has_use_roads();
  HasUseRoadsCase has_use_roads_case() const;
  void clear_has_max_distance();
  HasMaxDistanceCase has_max_distance_case() const;
  void clear_has_walking_speed();
  HasWalkingSpeedCase has_walking_speed_case() const;
  void clear_has_step_penalty();
  HasStepPenaltyCase has_step_penalty_case() const;
  void clear_has_max_grade();
  HasMaxGradeCase has_max_grade_case() const;
  void clear_has_max_hiking_difficulty();
  HasMaxHikingDifficultyCase has_max_hiking_difficulty_case() const;
  void clear_has_mode_factor();
  HasModeFactorCase has_mode_factor_case() const;
  void clear_has_walkway_factor();
  HasWalkwayFactorCase has_walkway_factor_case() const;
  void clear_has_sidewalk_factor();
  HasSidewalkFactorCase has_sidewalk_factor_case() const;
  void clear_has_alley_factor();
  HasAlleyFactorCase has_alley_factor_case() const;
  void clear_has_driveway_factor();
  HasDrivewayFactorCase has_driveway_factor_case() const;
  void clear_has_driveway_penalty();
  HasDrivewayPenaltyCase has_driveway_penalty_case() const;
  void clear_has_transit_start_end_max_distance();
  HasTransitStartEndMaxDistanceCase has_transit_start_end_max_distance_case() const;
  void clear_has_transit_transfer_max_distance();
  HasTransitTransferMaxDistanceCase has_transit_transfer_max_distance_case() const;
  void clear_has_transport_type();
  HasTransportTypeCase has_transport_type_case() const;
  void clear_has_top_speed();
  HasTopSpeedCase has_top_speed_case() const;
  void clear_has_use_hills();
  HasUseHillsCase has_use_hills_case() const;
  void clear_has_use_primary();
  HasUsePrimaryCase has_use_primary_case() const;
  void clear_has_use_trails();
  HasUseTrailsCase has_use_trails_case() const;
  void clear_has_low_class_penalty();
  HasLowClassPenaltyCase has_low_class_penalty_case() const;
  void clear_has_hazmat();
  HasHazmatCase has_hazmat_case() const;
  void clear_has_weight();
  HasWeightCase has_weight_case() const;
  void clear_has_axle_load();
  HasAxleLoadCase has_axle_load_case() const;
  void clear_has_height();
  HasHeightCase has_height_case() const;
  void clear_has_width();
  HasWidthCase has_width_case() const;
  void clear_has_length();
  HasLengthCase has_length_case() const;
  void clear_has_cycling_speed();
  HasCyclingSpeedCase has_cycling_speed_case() const;
  void clear_has_wheelchair();
  HasWheelchairCase has_wheelchair_case() const;
  void clear_has_bicycle();
  HasBicycleCase has_bicycle_case() const;
  void clear_has_use_bus();
  HasUseBusCase has_use_bus_case() const;
  void clear_has_use_rail();
  HasUseRailCase has_use_rail_case() const;
  void clear_has_use_transfers();
  HasUseTransfersCase has_use_transfers_case() const;
  void clear_has_transfer_cost();
  HasTransferCostCase has_transfer_cost_case() const;
  void clear_has_transfer_penalty();
  HasTransferPenaltyCase has_transfer_penalty_case() const;
  void clear_has_flow_mask();
  HasFlowMaskCase has_flow_mask_case() const;
  void clear_has_bike_share_cost();
  HasBikeShareCostCase has_bike_share_cost_case() const;
  void clear_has_bike_share_penalty();
  HasBikeSharePenaltyCase has_bike_share_penalty_case() const;
  void clear_has_rail_ferry_cost();
  HasRailFerryCostCase has_rail_ferry_cost_case() const;
  void clear_has_use_rail_ferry();
  HasUseRailFerryCase has_use_rail_ferry_case() const;
  void clear_has_ignore_restrictions();
  HasIgnoreRestrictionsCase has_ignore_restrictions_case() const;
  void clear_has_ignore_oneways();
  HasIgnoreOnewaysCase has_ignore_oneways_case() const;
  void clear_has_ignore_access();
  HasIgnoreAccessCase has_ignore_access_case() const;
  void clear_has_ignore_closures();
  HasIgnoreClosuresCase has_ignore_closures_case() const;
  void clear_has_shortest();
  HasShortestCase has_shortest_case() const;
  void clear_has_service_penalty();
  HasServicePenaltyCase has_service_penalty_case() const;
  void clear_has_use_tracks();
  HasUseTracksCase has_use_tracks_case() const;
  void clear_has_use_distance();
  HasUseDistanceCase has_use_distance_case() const;
  void clear_has_use_living_streets();
  HasUseLivingStreetsCase has_use_living_streets_case() const;
  void clear_has_service_factor();
  HasServiceFactorCase has_service_factor_case() const;
  void clear_has_closure_factor();
  HasClosureFactorCase has_closure_factor_case() const;
  void clear_has_private_access_penalty();
  HasPrivateAccessPenaltyCase has_private_access_penalty_case() const;
  void clear_has_exclude_unpaved();
  HasExcludeUnpavedCase has_exclude_unpaved_case() const;
  void clear_has_include_hot();
  HasIncludeHotCase has_include_hot_case() const;
  void clear_has_include_hov2();
  HasIncludeHov2Case has_include_hov2_case() const;
  void clear_has_include_hov3();
  HasIncludeHov3Case has_include_hov3_case() const;
  void clear_has_exclude_cash_only_tolls();
  HasExcludeCashOnlyTollsCase has_exclude_cash_only_tolls_case() const;
  void clear_has_restriction_probability();
  HasRestrictionProbabilityCase has_restriction_probability_case() const;
  void clear_has_elevator_penalty();
  HasElevatorPenaltyCase has_elevator_penalty_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Costing.Options)
 private:
  class _Internal;
  void set_has_maneuver_penalty();
  void set_has_destination_only_penalty();
  void set_has_gate_cost();
  void set_has_gate_penalty();
  void set_has_toll_booth_cost();
  void set_has_toll_booth_penalty();
  void set_has_alley_penalty();
  void set_has_country_crossing_cost();
  void set_has_country_crossing_penalty();
  void set_has_ferry_cost();
  void set_has_avoid_bad_surfaces();
  void set_has_use_ferry();
  void set_has_use_highways();
  void set_has_use_tolls();
  void set_has_use_roads();
  void set_has_max_distance();
  void set_has_walking_speed();
  void set_has_step_penalty();
  void set_has_max_grade();
  void set_has_max_hiking_difficulty();
  void set_has_mode_factor();
  void set_has_walkway_factor();
  void set_has_sidewalk_factor();
  void set_has_alley_factor();
  void set_has_driveway_factor();
  void set_has_driveway_penalty();
  void set_has_transit_start_end_max_distance();
  void set_has_transit_transfer_max_distance();
  void set_has_transport_type();
  void set_has_top_speed();
  void set_has_use_hills();
  void set_has_use_primary();
  void set_has_use_trails();
  void set_has_low_class_penalty();
  void set_has_hazmat();
  void set_has_weight();
  void set_has_axle_load();
  void set_has_height();
  void set_has_width();
  void set_has_length();
  void set_has_cycling_speed();
  void set_has_wheelchair();
  void set_has_bicycle();
  void set_has_use_bus();
  void set_has_use_rail();
  void set_has_use_transfers();
  void set_has_transfer_cost();
  void set_has_transfer_penalty();
  void set_has_flow_mask();
  void set_has_bike_share_cost();
  void set_has_bike_share_penalty();
  void set_has_rail_ferry_cost();
  void set_has_use_rail_ferry();
  void set_has_ignore_restrictions();
  void set_has_ignore_oneways();
  void set_has_ignore_access();
  void set_has_ignore_closures();
  void set_has_shortest();
  void set_has_service_penalty();
  void set_has_use_tracks();
  void set_has_use_distance();
  void set_has_use_living_streets();
  void set_has_service_factor();
  void set_has_closure_factor();
  void set_has_private_access_penalty();
  void set_has_exclude_unpaved();
  void set_has_include_hot();
  void set_has_include_hov2();
  void set_has_include_hov3();
  void set_has_exclude_cash_only_tolls();
  void set_has_restriction_probability();
  void set_has_elevator_penalty();

  inline bool has_has_maneuver_penalty() const;
  inline void clear_has_has_maneuver_penalty();

  inline bool has_has_destination_only_penalty() const;
  inline void clear_has_has_destination_only_penalty();

  inline bool has_has_gate_cost() const;
  inline void clear_has_has_gate_cost();

  inline bool has_has_gate_penalty() const;
  inline void clear_has_has_gate_penalty();

  inline bool has_has_toll_booth_cost() const;
  inline void clear_has_has_toll_booth_cost();

  inline bool has_has_toll_booth_penalty() const;
  inline void clear_has_has_toll_booth_penalty();

  inline bool has_has_alley_penalty() const;
  inline void clear_has_has_alley_penalty();

  inline bool has_has_country_crossing_cost() const;
  inline void clear_has_has_country_crossing_cost();

  inline bool has_has_country_crossing_penalty() const;
  inline void clear_has_has_country_crossing_penalty();

  inline bool has_has_ferry_cost() const;
  inline void clear_has_has_ferry_cost();

  inline bool has_has_avoid_bad_surfaces() const;
  inline void clear_has_has_avoid_bad_surfaces();

  inline bool has_has_use_ferry() const;
  inline void clear_has_has_use_ferry();

  inline bool has_has_use_highways() const;
  inline void clear_has_has_use_highways();

  inline bool has_has_use_tolls() const;
  inline void clear_has_has_use_tolls();

  inline bool has_has_use_roads() const;
  inline void clear_has_has_use_roads();

  inline bool has_has_max_distance() const;
  inline void clear_has_has_max_distance();

  inline bool has_has_walking_speed() const;
  inline void clear_has_has_walking_speed();

  inline bool has_has_step_penalty() const;
  inline void clear_has_has_step_penalty();

  inline bool has_has_max_grade() const;
  inline void clear_has_has_max_grade();

  inline bool has_has_max_hiking_difficulty() const;
  inline void clear_has_has_max_hiking_difficulty();

  inline bool has_has_mode_factor() const;
  inline void clear_has_has_mode_factor();

  inline bool has_has_walkway_factor() const;
  inline void clear_has_has_walkway_factor();

  inline bool has_has_sidewalk_factor() const;
  inline void clear_has_has_sidewalk_factor();

  inline bool has_has_alley_factor() const;
  inline void clear_has_has_alley_factor();

  inline bool has_has_driveway_factor() const;
  inline void clear_has_has_driveway_factor();

  inline bool has_has_driveway_penalty() const;
  inline void clear_has_has_driveway_penalty();

  inline bool has_has_transit_start_end_max_distance() const;
  inline void clear_has_has_transit_start_end_max_distance();

  inline bool has_has_transit_transfer_max_distance() const;
  inline void clear_has_has_transit_transfer_max_distance();

  inline bool has_has_transport_type() const;
  inline void clear_has_has_transport_type();

  inline bool has_has_top_speed() const;
  inline void clear_has_has_top_speed();

  inline bool has_has_use_hills() const;
  inline void clear_has_has_use_hills();

  inline bool has_has_use_primary() const;
  inline void clear_has_has_use_primary();

  inline bool has_has_use_trails() const;
  inline void clear_has_has_use_trails();

  inline bool has_has_low_class_penalty() const;
  inline void clear_has_has_low_class_penalty();

  inline bool has_has_hazmat() const;
  inline void clear_has_has_hazmat();

  inline bool has_has_weight() const;
  inline void clear_has_has_weight();

  inline bool has_has_axle_load() const;
  inline void clear_has_has_axle_load();

  inline bool has_has_height() const;
  inline void clear_has_has_height();

  inline bool has_has_width() const;
  inline void clear_has_has_width();

  inline bool has_has_length() const;
  inline void clear_has_has_length();

  inline bool has_has_cycling_speed() const;
  inline void clear_has_has_cycling_speed();

  inline bool has_has_wheelchair() const;
  inline void clear_has_has_wheelchair();

  inline bool has_has_bicycle() const;
  inline void clear_has_has_bicycle();

  inline bool has_has_use_bus() const;
  inline void clear_has_has_use_bus();

  inline bool has_has_use_rail() const;
  inline void clear_has_has_use_rail();

  inline bool has_has_use_transfers() const;
  inline void clear_has_has_use_transfers();

  inline bool has_has_transfer_cost() const;
  inline void clear_has_has_transfer_cost();

  inline bool has_has_transfer_penalty() const;
  inline void clear_has_has_transfer_penalty();

  inline bool has_has_flow_mask() const;
  inline void clear_has_has_flow_mask();

  inline bool has_has_bike_share_cost() const;
  inline void clear_has_has_bike_share_cost();

  inline bool has_has_bike_share_penalty() const;
  inline void clear_has_has_bike_share_penalty();

  inline bool has_has_rail_ferry_cost() const;
  inline void clear_has_has_rail_ferry_cost();

  inline bool has_has_use_rail_ferry() const;
  inline void clear_has_has_use_rail_ferry();

  inline bool has_has_ignore_restrictions() const;
  inline void clear_has_has_ignore_restrictions();

  inline bool has_has_ignore_oneways() const;
  inline void clear_has_has_ignore_oneways();

  inline bool has_has_ignore_access() const;
  inline void clear_has_has_ignore_access();

  inline bool has_has_ignore_closures() const;
  inline void clear_has_has_ignore_closures();

  inline bool has_has_shortest() const;
  inline void clear_has_has_shortest();

  inline bool has_has_service_penalty() const;
  inline void clear_has_has_service_penalty();

  inline bool has_has_use_tracks() const;
  inline void clear_has_has_use_tracks();

  inline bool has_has_use_distance() const;
  inline void clear_has_has_use_distance();

  inline bool has_has_use_living_streets() const;
  inline void clear_has_has_use_living_streets();

  inline bool has_has_service_factor() const;
  inline void clear_has_has_service_factor();

  inline bool has_has_closure_factor() const;
  inline void clear_has_has_closure_factor();

  inline bool has_has_private_access_penalty() const;
  inline void clear_has_has_private_access_penalty();

  inline bool has_has_exclude_unpaved() const;
  inline void clear_has_has_exclude_unpaved();

  inline bool has_has_include_hot() const;
  inline void clear_has_has_include_hot();

  inline bool has_has_include_hov2() const;
  inline void clear_has_has_include_hov2();

  inline bool has_has_include_hov3() const;
  inline void clear_has_has_include_hov3();

  inline bool has_has_exclude_cash_only_tolls() const;
  inline void clear_has_has_exclude_cash_only_tolls();

  inline bool has_has_restriction_probability() const;
  inline void clear_has_has_restriction_probability();

  inline bool has_has_elevator_penalty() const;
  inline void clear_has_has_elevator_penalty();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_stop_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_operator_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_route_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge > exclude_edges_;
  int filter_route_action_;
  int filter_stop_action_;
  int filter_operator_action_;
  union HasManeuverPenaltyUnion {
    constexpr HasManeuverPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float maneuver_penalty_;
  } has_maneuver_penalty_;
  union HasDestinationOnlyPenaltyUnion {
    constexpr HasDestinationOnlyPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float destination_only_penalty_;
  } has_destination_only_penalty_;
  union HasGateCostUnion {
    constexpr HasGateCostUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float gate_cost_;
  } has_gate_cost_;
  union HasGatePenaltyUnion {
    constexpr HasGatePenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float gate_penalty_;
  } has_gate_penalty_;
  union HasTollBoothCostUnion {
    constexpr HasTollBoothCostUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float toll_booth_cost_;
  } has_toll_booth_cost_;
  union HasTollBoothPenaltyUnion {
    constexpr HasTollBoothPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float toll_booth_penalty_;
  } has_toll_booth_penalty_;
  union HasAlleyPenaltyUnion {
    constexpr HasAlleyPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float alley_penalty_;
  } has_alley_penalty_;
  union HasCountryCrossingCostUnion {
    constexpr HasCountryCrossingCostUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float country_crossing_cost_;
  } has_country_crossing_cost_;
  union HasCountryCrossingPenaltyUnion {
    constexpr HasCountryCrossingPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float country_crossing_penalty_;
  } has_country_crossing_penalty_;
  union HasFerryCostUnion {
    constexpr HasFerryCostUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float ferry_cost_;
  } has_ferry_cost_;
  union HasAvoidBadSurfacesUnion {
    constexpr HasAvoidBadSurfacesUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float avoid_bad_surfaces_;
  } has_avoid_bad_surfaces_;
  union HasUseFerryUnion {
    constexpr HasUseFerryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_ferry_;
  } has_use_ferry_;
  union HasUseHighwaysUnion {
    constexpr HasUseHighwaysUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_highways_;
  } has_use_highways_;
  union HasUseTollsUnion {
    constexpr HasUseTollsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_tolls_;
  } has_use_tolls_;
  union HasUseRoadsUnion {
    constexpr HasUseRoadsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_roads_;
  } has_use_roads_;
  union HasMaxDistanceUnion {
    constexpr HasMaxDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t max_distance_;
  } has_max_distance_;
  union HasWalkingSpeedUnion {
    constexpr HasWalkingSpeedUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float walking_speed_;
  } has_walking_speed_;
  union HasStepPenaltyUnion {
    constexpr HasStepPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float step_penalty_;
  } has_step_penalty_;
  union HasMaxGradeUnion {
    constexpr HasMaxGradeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t max_grade_;
  } has_max_grade_;
  union HasMaxHikingDifficultyUnion {
    constexpr HasMaxHikingDifficultyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t max_hiking_difficulty_;
  } has_max_hiking_difficulty_;
  union HasModeFactorUnion {
    constexpr HasModeFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float mode_factor_;
  } has_mode_factor_;
  union HasWalkwayFactorUnion {
    constexpr HasWalkwayFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float walkway_factor_;
  } has_walkway_factor_;
  union HasSidewalkFactorUnion {
    constexpr HasSidewalkFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float sidewalk_factor_;
  } has_sidewalk_factor_;
  union HasAlleyFactorUnion {
    constexpr HasAlleyFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float alley_factor_;
  } has_alley_factor_;
  union HasDrivewayFactorUnion {
    constexpr HasDrivewayFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float driveway_factor_;
  } has_driveway_factor_;
  union HasDrivewayPenaltyUnion {
    constexpr HasDrivewayPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float driveway_penalty_;
  } has_driveway_penalty_;
  union HasTransitStartEndMaxDistanceUnion {
    constexpr HasTransitStartEndMaxDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t transit_start_end_max_distance_;
  } has_transit_start_end_max_distance_;
  union HasTransitTransferMaxDistanceUnion {
    constexpr HasTransitTransferMaxDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t transit_transfer_max_distance_;
  } has_transit_transfer_max_distance_;
  union HasTransportTypeUnion {
    constexpr HasTransportTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transport_type_;
  } has_transport_type_;
  union HasTopSpeedUnion {
    constexpr HasTopSpeedUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float top_speed_;
  } has_top_speed_;
  union HasUseHillsUnion {
    constexpr HasUseHillsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_hills_;
  } has_use_hills_;
  union HasUsePrimaryUnion {
    constexpr HasUsePrimaryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_primary_;
  } has_use_primary_;
  union HasUseTrailsUnion {
    constexpr HasUseTrailsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_trails_;
  } has_use_trails_;
  union HasLowClassPenaltyUnion {
    constexpr HasLowClassPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float low_class_penalty_;
  } has_low_class_penalty_;
  union HasHazmatUnion {
    constexpr HasHazmatUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool hazmat_;
  } has_hazmat_;
  union HasWeightUnion {
    constexpr HasWeightUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float weight_;
  } has_weight_;
  union HasAxleLoadUnion {
    constexpr HasAxleLoadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float axle_load_;
  } has_axle_load_;
  union HasHeightUnion {
    constexpr HasHeightUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float height_;
  } has_height_;
  union HasWidthUnion {
    constexpr HasWidthUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float width_;
  } has_width_;
  union HasLengthUnion {
    constexpr HasLengthUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float length_;
  } has_length_;
  union HasCyclingSpeedUnion {
    constexpr HasCyclingSpeedUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float cycling_speed_;
  } has_cycling_speed_;
  union HasWheelchairUnion {
    constexpr HasWheelchairUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool wheelchair_;
  } has_wheelchair_;
  union HasBicycleUnion {
    constexpr HasBicycleUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool bicycle_;
  } has_bicycle_;
  union HasUseBusUnion {
    constexpr HasUseBusUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_bus_;
  } has_use_bus_;
  union HasUseRailUnion {
    constexpr HasUseRailUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_rail_;
  } has_use_rail_;
  union HasUseTransfersUnion {
    constexpr HasUseTransfersUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_transfers_;
  } has_use_transfers_;
  union HasTransferCostUnion {
    constexpr HasTransferCostUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float transfer_cost_;
  } has_transfer_cost_;
  union HasTransferPenaltyUnion {
    constexpr HasTransferPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float transfer_penalty_;
  } has_transfer_penalty_;
  union HasFlowMaskUnion {
    constexpr HasFlowMaskUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t flow_mask_;
  } has_flow_mask_;
  union HasBikeShareCostUnion {
    constexpr HasBikeShareCostUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float bike_share_cost_;
  } has_bike_share_cost_;
  union HasBikeSharePenaltyUnion {
    constexpr HasBikeSharePenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float bike_share_penalty_;
  } has_bike_share_penalty_;
  union HasRailFerryCostUnion {
    constexpr HasRailFerryCostUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float rail_ferry_cost_;
  } has_rail_ferry_cost_;
  union HasUseRailFerryUnion {
    constexpr HasUseRailFerryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_rail_ferry_;
  } has_use_rail_ferry_;
  union HasIgnoreRestrictionsUnion {
    constexpr HasIgnoreRestrictionsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool ignore_restrictions_;
  } has_ignore_restrictions_;
  union HasIgnoreOnewaysUnion {
    constexpr HasIgnoreOnewaysUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool ignore_oneways_;
  } has_ignore_oneways_;
  union HasIgnoreAccessUnion {
    constexpr HasIgnoreAccessUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool ignore_access_;
  } has_ignore_access_;
  union HasIgnoreClosuresUnion {
    constexpr HasIgnoreClosuresUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool ignore_closures_;
  } has_ignore_closures_;
  union HasShortestUnion {
    constexpr HasShortestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool shortest_;
  } has_shortest_;
  union HasServicePenaltyUnion {
    constexpr HasServicePenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float service_penalty_;
  } has_service_penalty_;
  union HasUseTracksUnion {
    constexpr HasUseTracksUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_tracks_;
  } has_use_tracks_;
  union HasUseDistanceUnion {
    constexpr HasUseDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_distance_;
  } has_use_distance_;
  union HasUseLivingStreetsUnion {
    constexpr HasUseLivingStreetsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float use_living_streets_;
  } has_use_living_streets_;
  union HasServiceFactorUnion {
    constexpr HasServiceFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float service_factor_;
  } has_service_factor_;
  union HasClosureFactorUnion {
    constexpr HasClosureFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float closure_factor_;
  } has_closure_factor_;
  union HasPrivateAccessPenaltyUnion {
    constexpr HasPrivateAccessPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float private_access_penalty_;
  } has_private_access_penalty_;
  union HasExcludeUnpavedUnion {
    constexpr HasExcludeUnpavedUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool exclude_unpaved_;
  } has_exclude_unpaved_;
  union HasIncludeHotUnion {
    constexpr HasIncludeHotUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool include_hot_;
  } has_include_hot_;
  union HasIncludeHov2Union {
    constexpr HasIncludeHov2Union() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool include_hov2_;
  } has_include_hov2_;
  union HasIncludeHov3Union {
    constexpr HasIncludeHov3Union() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool include_hov3_;
  } has_include_hov3_;
  union HasExcludeCashOnlyTollsUnion {
    constexpr HasExcludeCashOnlyTollsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool exclude_cash_only_tolls_;
  } has_exclude_cash_only_tolls_;
  union HasRestrictionProbabilityUnion {
    constexpr HasRestrictionProbabilityUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t restriction_probability_;
  } has_restriction_probability_;
  union HasElevatorPenaltyUnion {
    constexpr HasElevatorPenaltyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float elevator_penalty_;
  } has_elevator_penalty_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[72];

  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class Costing final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Costing) */ {
 public:
  inline Costing() : Costing(nullptr) {}
  ~Costing() override;
  explicit constexpr Costing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Costing(const Costing& from);
  Costing(Costing&& from) noexcept
    : Costing() {
    *this = ::std::move(from);
  }

  inline Costing& operator=(const Costing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Costing& operator=(Costing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Costing& default_instance() {
    return *internal_default_instance();
  }
  enum HasOptionsCase {
    kOptions = 1,
    HAS_OPTIONS_NOT_SET = 0,
  };

  enum HasNameCase {
    kName = 3,
    HAS_NAME_NOT_SET = 0,
  };

  enum HasFilterClosuresCase {
    kFilterClosures = 4,
    HAS_FILTER_CLOSURES_NOT_SET = 0,
  };

  static inline const Costing* internal_default_instance() {
    return reinterpret_cast<const Costing*>(
               &_Costing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Costing& a, Costing& b) {
    a.Swap(&b);
  }
  inline void Swap(Costing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Costing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Costing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Costing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Costing& from);
  void MergeFrom(const Costing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Costing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Costing";
  }
  protected:
  explicit Costing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Costing_Options Options;

  typedef Costing_Type Type;
  static constexpr Type none_ =
    Costing_Type_none_;
  static constexpr Type bicycle =
    Costing_Type_bicycle;
  static constexpr Type bus =
    Costing_Type_bus;
  static constexpr Type motor_scooter =
    Costing_Type_motor_scooter;
  static constexpr Type multimodal =
    Costing_Type_multimodal;
  static constexpr Type pedestrian =
    Costing_Type_pedestrian;
  static constexpr Type transit =
    Costing_Type_transit;
  static constexpr Type truck =
    Costing_Type_truck;
  static constexpr Type motorcycle =
    Costing_Type_motorcycle;
  static constexpr Type taxi =
    Costing_Type_taxi;
  static constexpr Type auto_ =
    Costing_Type_auto_;
  static constexpr Type bikeshare =
    Costing_Type_bikeshare;
  static inline bool Type_IsValid(int value) {
    return Costing_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Costing_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Costing_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Costing_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Costing_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Costing_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
    kOptionsFieldNumber = 1,
    kNameFieldNumber = 3,
    kFilterClosuresFieldNumber = 4,
  };
  // .valhalla.Costing.Type type = 2;
  void clear_type();
  ::valhalla::Costing_Type type() const;
  void set_type(::valhalla::Costing_Type value);
  private:
  ::valhalla::Costing_Type _internal_type() const;
  void _internal_set_type(::valhalla::Costing_Type value);
  public:

  // .valhalla.Costing.Options options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::valhalla::Costing_Options& options() const;
  PROTOBUF_NODISCARD ::valhalla::Costing_Options* release_options();
  ::valhalla::Costing_Options* mutable_options();
  void set_allocated_options(::valhalla::Costing_Options* options);
  private:
  const ::valhalla::Costing_Options& _internal_options() const;
  ::valhalla::Costing_Options* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::valhalla::Costing_Options* options);
  ::valhalla::Costing_Options* unsafe_arena_release_options();

  // string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool filter_closures = 4;
  bool has_filter_closures() const;
  private:
  bool _internal_has_filter_closures() const;
  public:
  void clear_filter_closures();
  bool filter_closures() const;
  void set_filter_closures(bool value);
  private:
  bool _internal_filter_closures() const;
  void _internal_set_filter_closures(bool value);
  public:

  void clear_has_options();
  HasOptionsCase has_options_case() const;
  void clear_has_name();
  HasNameCase has_name_case() const;
  void clear_has_filter_closures();
  HasFilterClosuresCase has_filter_closures_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Costing)
 private:
  class _Internal;
  void set_has_options();
  void set_has_name();
  void set_has_filter_closures();

  inline bool has_has_options() const;
  inline void clear_has_has_options();

  inline bool has_has_name() const;
  inline void clear_has_has_name();

  inline bool has_has_filter_closures() const;
  inline void clear_has_has_filter_closures();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  union HasOptionsUnion {
    constexpr HasOptionsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::valhalla::Costing_Options* options_;
  } has_options_;
  union HasNameUnion {
    constexpr HasNameUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  } has_name_;
  union HasFilterClosuresUnion {
    constexpr HasFilterClosuresUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool filter_closures_;
  } has_filter_closures_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[3];

  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class Options_CostingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Options_CostingsEntry_DoNotUse, 
    int32_t, ::valhalla::Costing,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Options_CostingsEntry_DoNotUse, 
    int32_t, ::valhalla::Costing,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Options_CostingsEntry_DoNotUse();
  explicit constexpr Options_CostingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Options_CostingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Options_CostingsEntry_DoNotUse& other);
  static const Options_CostingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Options_CostingsEntry_DoNotUse*>(&_Options_CostingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class Options final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Options) */ {
 public:
  inline Options() : Options(nullptr) {}
  ~Options() override;
  explicit constexpr Options(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Options(const Options& from);
  Options(Options&& from) noexcept
    : Options() {
    *this = ::std::move(from);
  }

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Options& operator=(Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Options& default_instance() {
    return *internal_default_instance();
  }
  enum HasLanguageCase {
    kLanguage = 2,
    HAS_LANGUAGE_NOT_SET = 0,
  };

  enum HasIdCase {
    kId = 5,
    HAS_ID_NOT_SET = 0,
  };

  enum HasJsonpCase {
    kJsonp = 6,
    HAS_JSONP_NOT_SET = 0,
  };

  enum HasEncodedPolylineCase {
    kEncodedPolyline = 7,
    HAS_ENCODED_POLYLINE_NOT_SET = 0,
  };

  enum HasRangeCase {
    kRange = 10,
    HAS_RANGE_NOT_SET = 0,
  };

  enum HasVerboseCase {
    kVerbose = 11,
    HAS_VERBOSE_NOT_SET = 0,
  };

  enum HasDateTimeCase {
    kDateTime = 19,
    HAS_DATE_TIME_NOT_SET = 0,
  };

  enum HasResampleDistanceCase {
    kResampleDistance = 21,
    HAS_RESAMPLE_DISTANCE_NOT_SET = 0,
  };

  enum HasPolygonsCase {
    kPolygons = 23,
    HAS_POLYGONS_NOT_SET = 0,
  };

  enum HasDenoiseCase {
    kDenoise = 24,
    HAS_DENOISE_NOT_SET = 0,
  };

  enum HasGeneralizeCase {
    kGeneralize = 25,
    HAS_GENERALIZE_NOT_SET = 0,
  };

  enum HasShowLocationsCase {
    kShowLocations = 26,
    HAS_SHOW_LOCATIONS_NOT_SET = 0,
  };

  enum HasGpsAccuracyCase {
    kGpsAccuracy = 30,
    HAS_GPS_ACCURACY_NOT_SET = 0,
  };

  enum HasSearchRadiusCase {
    kSearchRadius = 31,
    HAS_SEARCH_RADIUS_NOT_SET = 0,
  };

  enum HasTurnPenaltyFactorCase {
    kTurnPenaltyFactor = 32,
    HAS_TURN_PENALTY_FACTOR_NOT_SET = 0,
  };

  enum HasBreakageDistanceCase {
    kBreakageDistance = 36,
    HAS_BREAKAGE_DISTANCE_NOT_SET = 0,
  };

  enum HasUseTimestampsCase {
    kUseTimestamps = 37,
    HAS_USE_TIMESTAMPS_NOT_SET = 0,
  };

  enum HasAlternatesCase {
    kAlternates = 39,
    HAS_ALTERNATES_NOT_SET = 0,
  };

  enum HasInterpolationDistanceCase {
    kInterpolationDistance = 40,
    HAS_INTERPOLATION_DISTANCE_NOT_SET = 0,
  };

  enum HasGuidanceViewsCase {
    kGuidanceViews = 41,
    HAS_GUIDANCE_VIEWS_NOT_SET = 0,
  };

  enum HasHeightPrecisionCase {
    kHeightPrecision = 43,
    HAS_HEIGHT_PRECISION_NOT_SET = 0,
  };

  enum HasRoundaboutExitsCase {
    kRoundaboutExits = 44,
    HAS_ROUNDABOUT_EXITS_NOT_SET = 0,
  };

  enum HasLinearReferencesCase {
    kLinearReferences = 45,
    HAS_LINEAR_REFERENCES_NOT_SET = 0,
  };

  enum HasPrioritizeBidirectionalCase {
    kPrioritizeBidirectional = 48,
    HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET = 0,
  };

  enum HasExpansionActionCase {
    kExpansionAction = 49,
    HAS_EXPANSION_ACTION_NOT_SET = 0,
  };

  enum HasSkipOppositesCase {
    kSkipOpposites = 50,
    HAS_SKIP_OPPOSITES_NOT_SET = 0,
  };

  static inline const Options* internal_default_instance() {
    return reinterpret_cast<const Options*>(
               &_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Options& a, Options& b) {
    a.Swap(&b);
  }
  inline void Swap(Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Options* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Options* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Options>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Options& from);
  void MergeFrom(const Options& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Options* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Options";
  }
  protected:
  explicit Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  typedef Options_Units Units;
  static constexpr Units kilometers =
    Options_Units_kilometers;
  static constexpr Units miles =
    Options_Units_miles;
  static inline bool Units_IsValid(int value) {
    return Options_Units_IsValid(value);
  }
  static constexpr Units Units_MIN =
    Options_Units_Units_MIN;
  static constexpr Units Units_MAX =
    Options_Units_Units_MAX;
  static constexpr int Units_ARRAYSIZE =
    Options_Units_Units_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Units_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Units>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Units_Name.");
    return Options_Units_Name(enum_t_value);
  }
  static inline bool Units_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Units* value) {
    return Options_Units_Parse(name, value);
  }

  typedef Options_Format Format;
  static constexpr Format json =
    Options_Format_json;
  static constexpr Format gpx =
    Options_Format_gpx;
  static constexpr Format osrm =
    Options_Format_osrm;
  static constexpr Format pbf =
    Options_Format_pbf;
  static inline bool Format_IsValid(int value) {
    return Options_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    Options_Format_Format_MIN;
  static constexpr Format Format_MAX =
    Options_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    Options_Format_Format_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return Options_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return Options_Format_Parse(name, value);
  }

  typedef Options_Action Action;
  static constexpr Action no_action =
    Options_Action_no_action;
  static constexpr Action route =
    Options_Action_route;
  static constexpr Action locate =
    Options_Action_locate;
  static constexpr Action sources_to_targets =
    Options_Action_sources_to_targets;
  static constexpr Action optimized_route =
    Options_Action_optimized_route;
  static constexpr Action isochrone =
    Options_Action_isochrone;
  static constexpr Action trace_route =
    Options_Action_trace_route;
  static constexpr Action trace_attributes =
    Options_Action_trace_attributes;
  static constexpr Action height =
    Options_Action_height;
  static constexpr Action transit_available =
    Options_Action_transit_available;
  static constexpr Action expansion =
    Options_Action_expansion;
  static constexpr Action centroid =
    Options_Action_centroid;
  static constexpr Action status =
    Options_Action_status;
  static inline bool Action_IsValid(int value) {
    return Options_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    Options_Action_Action_MIN;
  static constexpr Action Action_MAX =
    Options_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    Options_Action_Action_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return Options_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return Options_Action_Parse(name, value);
  }

  typedef Options_DateTimeType DateTimeType;
  static constexpr DateTimeType no_time =
    Options_DateTimeType_no_time;
  static constexpr DateTimeType current =
    Options_DateTimeType_current;
  static constexpr DateTimeType depart_at =
    Options_DateTimeType_depart_at;
  static constexpr DateTimeType arrive_by =
    Options_DateTimeType_arrive_by;
  static constexpr DateTimeType invariant =
    Options_DateTimeType_invariant;
  static inline bool DateTimeType_IsValid(int value) {
    return Options_DateTimeType_IsValid(value);
  }
  static constexpr DateTimeType DateTimeType_MIN =
    Options_DateTimeType_DateTimeType_MIN;
  static constexpr DateTimeType DateTimeType_MAX =
    Options_DateTimeType_DateTimeType_MAX;
  static constexpr int DateTimeType_ARRAYSIZE =
    Options_DateTimeType_DateTimeType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DateTimeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DateTimeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DateTimeType_Name.");
    return Options_DateTimeType_Name(enum_t_value);
  }
  static inline bool DateTimeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DateTimeType* value) {
    return Options_DateTimeType_Parse(name, value);
  }

  typedef Options_ExpansionProperties ExpansionProperties;
  static constexpr ExpansionProperties costs =
    Options_ExpansionProperties_costs;
  static constexpr ExpansionProperties durations =
    Options_ExpansionProperties_durations;
  static constexpr ExpansionProperties distances =
    Options_ExpansionProperties_distances;
  static constexpr ExpansionProperties statuses =
    Options_ExpansionProperties_statuses;
  static constexpr ExpansionProperties edge_ids =
    Options_ExpansionProperties_edge_ids;
  static inline bool ExpansionProperties_IsValid(int value) {
    return Options_ExpansionProperties_IsValid(value);
  }
  static constexpr ExpansionProperties ExpansionProperties_MIN =
    Options_ExpansionProperties_ExpansionProperties_MIN;
  static constexpr ExpansionProperties ExpansionProperties_MAX =
    Options_ExpansionProperties_ExpansionProperties_MAX;
  static constexpr int ExpansionProperties_ARRAYSIZE =
    Options_ExpansionProperties_ExpansionProperties_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ExpansionProperties_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExpansionProperties>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExpansionProperties_Name.");
    return Options_ExpansionProperties_Name(enum_t_value);
  }
  static inline bool ExpansionProperties_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExpansionProperties* value) {
    return Options_ExpansionProperties_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCostingsFieldNumber = 13,
    kLocationsFieldNumber = 14,
    kExcludeLocationsFieldNumber = 15,
    kSourcesFieldNumber = 16,
    kTargetsFieldNumber = 17,
    kShapeFieldNumber = 20,
    kContoursFieldNumber = 22,
    kTraceFieldNumber = 27,
    kFilterAttributesFieldNumber = 34,
    kRecostingsFieldNumber = 46,
    kExcludePolygonsFieldNumber = 47,
    kExpansionPropertiesFieldNumber = 51,
    kPbfFieldSelectorFieldNumber = 52,
    kUnitsFieldNumber = 1,
    kDirectionsTypeFieldNumber = 3,
    kFormatFieldNumber = 4,
    kActionFieldNumber = 8,
    kCostingTypeFieldNumber = 12,
    kDateTimeTypeFieldNumber = 18,
    kMatrixLocationsFieldNumber = 54,
    kShapeMatchFieldNumber = 28,
    kFilterActionFieldNumber = 33,
    kShapeFormatFieldNumber = 38,
    kReverseFieldNumber = 53,
    kLanguageFieldNumber = 2,
    kIdFieldNumber = 5,
    kJsonpFieldNumber = 6,
    kEncodedPolylineFieldNumber = 7,
    kRangeFieldNumber = 10,
    kVerboseFieldNumber = 11,
    kDateTimeFieldNumber = 19,
    kResampleDistanceFieldNumber = 21,
    kPolygonsFieldNumber = 23,
    kDenoiseFieldNumber = 24,
    kGeneralizeFieldNumber = 25,
    kShowLocationsFieldNumber = 26,
    kGpsAccuracyFieldNumber = 30,
    kSearchRadiusFieldNumber = 31,
    kTurnPenaltyFactorFieldNumber = 32,
    kBreakageDistanceFieldNumber = 36,
    kUseTimestampsFieldNumber = 37,
    kAlternatesFieldNumber = 39,
    kInterpolationDistanceFieldNumber = 40,
    kGuidanceViewsFieldNumber = 41,
    kHeightPrecisionFieldNumber = 43,
    kRoundaboutExitsFieldNumber = 44,
    kLinearReferencesFieldNumber = 45,
    kPrioritizeBidirectionalFieldNumber = 48,
    kExpansionActionFieldNumber = 49,
    kSkipOppositesFieldNumber = 50,
  };
  // map<int32, .valhalla.Costing> costings = 13;
  int costings_size() const;
  private:
  int _internal_costings_size() const;
  public:
  void clear_costings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >&
      _internal_costings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >*
      _internal_mutable_costings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >&
      costings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >*
      mutable_costings();

  // repeated .valhalla.Location locations = 14;
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  ::valhalla::Location* mutable_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_locations();
  private:
  const ::valhalla::Location& _internal_locations(int index) const;
  ::valhalla::Location* _internal_add_locations();
  public:
  const ::valhalla::Location& locations(int index) const;
  ::valhalla::Location* add_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      locations() const;

  // repeated .valhalla.Location exclude_locations = 15;
  int exclude_locations_size() const;
  private:
  int _internal_exclude_locations_size() const;
  public:
  void clear_exclude_locations();
  ::valhalla::Location* mutable_exclude_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_exclude_locations();
  private:
  const ::valhalla::Location& _internal_exclude_locations(int index) const;
  ::valhalla::Location* _internal_add_exclude_locations();
  public:
  const ::valhalla::Location& exclude_locations(int index) const;
  ::valhalla::Location* add_exclude_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      exclude_locations() const;

  // repeated .valhalla.Location sources = 16;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::valhalla::Location* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_sources();
  private:
  const ::valhalla::Location& _internal_sources(int index) const;
  ::valhalla::Location* _internal_add_sources();
  public:
  const ::valhalla::Location& sources(int index) const;
  ::valhalla::Location* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      sources() const;

  // repeated .valhalla.Location targets = 17;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::valhalla::Location* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_targets();
  private:
  const ::valhalla::Location& _internal_targets(int index) const;
  ::valhalla::Location* _internal_add_targets();
  public:
  const ::valhalla::Location& targets(int index) const;
  ::valhalla::Location* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      targets() const;

  // repeated .valhalla.Location shape = 20;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  ::valhalla::Location* mutable_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_shape();
  private:
  const ::valhalla::Location& _internal_shape(int index) const;
  ::valhalla::Location* _internal_add_shape();
  public:
  const ::valhalla::Location& shape(int index) const;
  ::valhalla::Location* add_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      shape() const;

  // repeated .valhalla.Contour contours = 22;
  int contours_size() const;
  private:
  int _internal_contours_size() const;
  public:
  void clear_contours();
  ::valhalla::Contour* mutable_contours(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >*
      mutable_contours();
  private:
  const ::valhalla::Contour& _internal_contours(int index) const;
  ::valhalla::Contour* _internal_add_contours();
  public:
  const ::valhalla::Contour& contours(int index) const;
  ::valhalla::Contour* add_contours();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >&
      contours() const;

  // repeated .valhalla.Location trace = 27;
  int trace_size() const;
  private:
  int _internal_trace_size() const;
  public:
  void clear_trace();
  ::valhalla::Location* mutable_trace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_trace();
  private:
  const ::valhalla::Location& _internal_trace(int index) const;
  ::valhalla::Location* _internal_add_trace();
  public:
  const ::valhalla::Location& trace(int index) const;
  ::valhalla::Location* add_trace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      trace() const;

  // repeated string filter_attributes = 34;
  int filter_attributes_size() const;
  private:
  int _internal_filter_attributes_size() const;
  public:
  void clear_filter_attributes();
  const std::string& filter_attributes(int index) const;
  std::string* mutable_filter_attributes(int index);
  void set_filter_attributes(int index, const std::string& value);
  void set_filter_attributes(int index, std::string&& value);
  void set_filter_attributes(int index, const char* value);
  void set_filter_attributes(int index, const char* value, size_t size);
  std::string* add_filter_attributes();
  void add_filter_attributes(const std::string& value);
  void add_filter_attributes(std::string&& value);
  void add_filter_attributes(const char* value);
  void add_filter_attributes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_attributes();
  private:
  const std::string& _internal_filter_attributes(int index) const;
  std::string* _internal_add_filter_attributes();
  public:

  // repeated .valhalla.Costing recostings = 46;
  int recostings_size() const;
  private:
  int _internal_recostings_size() const;
  public:
  void clear_recostings();
  ::valhalla::Costing* mutable_recostings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Costing >*
      mutable_recostings();
  private:
  const ::valhalla::Costing& _internal_recostings(int index) const;
  ::valhalla::Costing* _internal_add_recostings();
  public:
  const ::valhalla::Costing& recostings(int index) const;
  ::valhalla::Costing* add_recostings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Costing >&
      recostings() const;

  // repeated .valhalla.Ring exclude_polygons = 47;
  int exclude_polygons_size() const;
  private:
  int _internal_exclude_polygons_size() const;
  public:
  void clear_exclude_polygons();
  ::valhalla::Ring* mutable_exclude_polygons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Ring >*
      mutable_exclude_polygons();
  private:
  const ::valhalla::Ring& _internal_exclude_polygons(int index) const;
  ::valhalla::Ring* _internal_add_exclude_polygons();
  public:
  const ::valhalla::Ring& exclude_polygons(int index) const;
  ::valhalla::Ring* add_exclude_polygons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Ring >&
      exclude_polygons() const;

  // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
  int expansion_properties_size() const;
  private:
  int _internal_expansion_properties_size() const;
  public:
  void clear_expansion_properties();
  private:
  ::valhalla::Options_ExpansionProperties _internal_expansion_properties(int index) const;
  void _internal_add_expansion_properties(::valhalla::Options_ExpansionProperties value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_expansion_properties();
  public:
  ::valhalla::Options_ExpansionProperties expansion_properties(int index) const;
  void set_expansion_properties(int index, ::valhalla::Options_ExpansionProperties value);
  void add_expansion_properties(::valhalla::Options_ExpansionProperties value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& expansion_properties() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_expansion_properties();

  // .valhalla.PbfFieldSelector pbf_field_selector = 52;
  bool has_pbf_field_selector() const;
  private:
  bool _internal_has_pbf_field_selector() const;
  public:
  void clear_pbf_field_selector();
  const ::valhalla::PbfFieldSelector& pbf_field_selector() const;
  PROTOBUF_NODISCARD ::valhalla::PbfFieldSelector* release_pbf_field_selector();
  ::valhalla::PbfFieldSelector* mutable_pbf_field_selector();
  void set_allocated_pbf_field_selector(::valhalla::PbfFieldSelector* pbf_field_selector);
  private:
  const ::valhalla::PbfFieldSelector& _internal_pbf_field_selector() const;
  ::valhalla::PbfFieldSelector* _internal_mutable_pbf_field_selector();
  public:
  void unsafe_arena_set_allocated_pbf_field_selector(
      ::valhalla::PbfFieldSelector* pbf_field_selector);
  ::valhalla::PbfFieldSelector* unsafe_arena_release_pbf_field_selector();

  // .valhalla.Options.Units units = 1;
  void clear_units();
  ::valhalla::Options_Units units() const;
  void set_units(::valhalla::Options_Units value);
  private:
  ::valhalla::Options_Units _internal_units() const;
  void _internal_set_units(::valhalla::Options_Units value);
  public:

  // .valhalla.DirectionsType directions_type = 3;
  void clear_directions_type();
  ::valhalla::DirectionsType directions_type() const;
  void set_directions_type(::valhalla::DirectionsType value);
  private:
  ::valhalla::DirectionsType _internal_directions_type() const;
  void _internal_set_directions_type(::valhalla::DirectionsType value);
  public:

  // .valhalla.Options.Format format = 4;
  void clear_format();
  ::valhalla::Options_Format format() const;
  void set_format(::valhalla::Options_Format value);
  private:
  ::valhalla::Options_Format _internal_format() const;
  void _internal_set_format(::valhalla::Options_Format value);
  public:

  // .valhalla.Options.Action action = 8;
  void clear_action();
  ::valhalla::Options_Action action() const;
  void set_action(::valhalla::Options_Action value);
  private:
  ::valhalla::Options_Action _internal_action() const;
  void _internal_set_action(::valhalla::Options_Action value);
  public:

  // .valhalla.Costing.Type costing_type = 12;
  void clear_costing_type();
  ::valhalla::Costing_Type costing_type() const;
  void set_costing_type(::valhalla::Costing_Type value);
  private:
  ::valhalla::Costing_Type _internal_costing_type() const;
  void _internal_set_costing_type(::valhalla::Costing_Type value);
  public:

  // .valhalla.Options.DateTimeType date_time_type = 18;
  void clear_date_time_type();
  ::valhalla::Options_DateTimeType date_time_type() const;
  void set_date_time_type(::valhalla::Options_DateTimeType value);
  private:
  ::valhalla::Options_DateTimeType _internal_date_time_type() const;
  void _internal_set_date_time_type(::valhalla::Options_DateTimeType value);
  public:

  // uint32 matrix_locations = 54;
  void clear_matrix_locations();
  uint32_t matrix_locations() const;
  void set_matrix_locations(uint32_t value);
  private:
  uint32_t _internal_matrix_locations() const;
  void _internal_set_matrix_locations(uint32_t value);
  public:

  // .valhalla.ShapeMatch shape_match = 28;
  void clear_shape_match();
  ::valhalla::ShapeMatch shape_match() const;
  void set_shape_match(::valhalla::ShapeMatch value);
  private:
  ::valhalla::ShapeMatch _internal_shape_match() const;
  void _internal_set_shape_match(::valhalla::ShapeMatch value);
  public:

  // .valhalla.FilterAction filter_action = 33;
  void clear_filter_action();
  ::valhalla::FilterAction filter_action() const;
  void set_filter_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_action() const;
  void _internal_set_filter_action(::valhalla::FilterAction value);
  public:

  // .valhalla.ShapeFormat shape_format = 38;
  void clear_shape_format();
  ::valhalla::ShapeFormat shape_format() const;
  void set_shape_format(::valhalla::ShapeFormat value);
  private:
  ::valhalla::ShapeFormat _internal_shape_format() const;
  void _internal_set_shape_format(::valhalla::ShapeFormat value);
  public:

  // bool reverse = 53;
  void clear_reverse();
  bool reverse() const;
  void set_reverse(bool value);
  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);
  public:

  // string language = 2;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string id = 5;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string jsonp = 6;
  bool has_jsonp() const;
  private:
  bool _internal_has_jsonp() const;
  public:
  void clear_jsonp();
  const std::string& jsonp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsonp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsonp();
  PROTOBUF_NODISCARD std::string* release_jsonp();
  void set_allocated_jsonp(std::string* jsonp);
  private:
  const std::string& _internal_jsonp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonp(const std::string& value);
  std::string* _internal_mutable_jsonp();
  public:

  // string encoded_polyline = 7;
  bool has_encoded_polyline() const;
  private:
  bool _internal_has_encoded_polyline() const;
  public:
  void clear_encoded_polyline();
  const std::string& encoded_polyline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded_polyline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded_polyline();
  PROTOBUF_NODISCARD std::string* release_encoded_polyline();
  void set_allocated_encoded_polyline(std::string* encoded_polyline);
  private:
  const std::string& _internal_encoded_polyline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_polyline(const std::string& value);
  std::string* _internal_mutable_encoded_polyline();
  public:

  // bool range = 10;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  bool range() const;
  void set_range(bool value);
  private:
  bool _internal_range() const;
  void _internal_set_range(bool value);
  public:

  // bool verbose = 11;
  bool has_verbose() const;
  private:
  bool _internal_has_verbose() const;
  public:
  void clear_verbose();
  bool verbose() const;
  void set_verbose(bool value);
  private:
  bool _internal_verbose() const;
  void _internal_set_verbose(bool value);
  public:

  // string date_time = 19;
  bool has_date_time() const;
  private:
  bool _internal_has_date_time() const;
  public:
  void clear_date_time();
  const std::string& date_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_time();
  PROTOBUF_NODISCARD std::string* release_date_time();
  void set_allocated_date_time(std::string* date_time);
  private:
  const std::string& _internal_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_time(const std::string& value);
  std::string* _internal_mutable_date_time();
  public:

  // double resample_distance = 21;
  bool has_resample_distance() const;
  private:
  bool _internal_has_resample_distance() const;
  public:
  void clear_resample_distance();
  double resample_distance() const;
  void set_resample_distance(double value);
  private:
  double _internal_resample_distance() const;
  void _internal_set_resample_distance(double value);
  public:

  // bool polygons = 23;
  bool has_polygons() const;
  private:
  bool _internal_has_polygons() const;
  public:
  void clear_polygons();
  bool polygons() const;
  void set_polygons(bool value);
  private:
  bool _internal_polygons() const;
  void _internal_set_polygons(bool value);
  public:

  // float denoise = 24;
  bool has_denoise() const;
  private:
  bool _internal_has_denoise() const;
  public:
  void clear_denoise();
  float denoise() const;
  void set_denoise(float value);
  private:
  float _internal_denoise() const;
  void _internal_set_denoise(float value);
  public:

  // float generalize = 25;
  bool has_generalize() const;
  private:
  bool _internal_has_generalize() const;
  public:
  void clear_generalize();
  float generalize() const;
  void set_generalize(float value);
  private:
  float _internal_generalize() const;
  void _internal_set_generalize(float value);
  public:

  // bool show_locations = 26;
  bool has_show_locations() const;
  private:
  bool _internal_has_show_locations() const;
  public:
  void clear_show_locations();
  bool show_locations() const;
  void set_show_locations(bool value);
  private:
  bool _internal_show_locations() const;
  void _internal_set_show_locations(bool value);
  public:

  // float gps_accuracy = 30;
  bool has_gps_accuracy() const;
  private:
  bool _internal_has_gps_accuracy() const;
  public:
  void clear_gps_accuracy();
  float gps_accuracy() const;
  void set_gps_accuracy(float value);
  private:
  float _internal_gps_accuracy() const;
  void _internal_set_gps_accuracy(float value);
  public:

  // float search_radius = 31;
  bool has_search_radius() const;
  private:
  bool _internal_has_search_radius() const;
  public:
  void clear_search_radius();
  float search_radius() const;
  void set_search_radius(float value);
  private:
  float _internal_search_radius() const;
  void _internal_set_search_radius(float value);
  public:

  // float turn_penalty_factor = 32;
  bool has_turn_penalty_factor() const;
  private:
  bool _internal_has_turn_penalty_factor() const;
  public:
  void clear_turn_penalty_factor();
  float turn_penalty_factor() const;
  void set_turn_penalty_factor(float value);
  private:
  float _internal_turn_penalty_factor() const;
  void _internal_set_turn_penalty_factor(float value);
  public:

  // float breakage_distance = 36;
  bool has_breakage_distance() const;
  private:
  bool _internal_has_breakage_distance() const;
  public:
  void clear_breakage_distance();
  float breakage_distance() const;
  void set_breakage_distance(float value);
  private:
  float _internal_breakage_distance() const;
  void _internal_set_breakage_distance(float value);
  public:

  // bool use_timestamps = 37;
  bool has_use_timestamps() const;
  private:
  bool _internal_has_use_timestamps() const;
  public:
  void clear_use_timestamps();
  bool use_timestamps() const;
  void set_use_timestamps(bool value);
  private:
  bool _internal_use_timestamps() const;
  void _internal_set_use_timestamps(bool value);
  public:

  // uint32 alternates = 39;
  bool has_alternates() const;
  private:
  bool _internal_has_alternates() const;
  public:
  void clear_alternates();
  uint32_t alternates() const;
  void set_alternates(uint32_t value);
  private:
  uint32_t _internal_alternates() const;
  void _internal_set_alternates(uint32_t value);
  public:

  // float interpolation_distance = 40;
  bool has_interpolation_distance() const;
  private:
  bool _internal_has_interpolation_distance() const;
  public:
  void clear_interpolation_distance();
  float interpolation_distance() const;
  void set_interpolation_distance(float value);
  private:
  float _internal_interpolation_distance() const;
  void _internal_set_interpolation_distance(float value);
  public:

  // bool guidance_views = 41;
  bool has_guidance_views() const;
  private:
  bool _internal_has_guidance_views() const;
  public:
  void clear_guidance_views();
  bool guidance_views() const;
  void set_guidance_views(bool value);
  private:
  bool _internal_guidance_views() const;
  void _internal_set_guidance_views(bool value);
  public:

  // uint32 height_precision = 43;
  bool has_height_precision() const;
  private:
  bool _internal_has_height_precision() const;
  public:
  void clear_height_precision();
  uint32_t height_precision() const;
  void set_height_precision(uint32_t value);
  private:
  uint32_t _internal_height_precision() const;
  void _internal_set_height_precision(uint32_t value);
  public:

  // bool roundabout_exits = 44;
  bool has_roundabout_exits() const;
  private:
  bool _internal_has_roundabout_exits() const;
  public:
  void clear_roundabout_exits();
  bool roundabout_exits() const;
  void set_roundabout_exits(bool value);
  private:
  bool _internal_roundabout_exits() const;
  void _internal_set_roundabout_exits(bool value);
  public:

  // bool linear_references = 45;
  bool has_linear_references() const;
  private:
  bool _internal_has_linear_references() const;
  public:
  void clear_linear_references();
  bool linear_references() const;
  void set_linear_references(bool value);
  private:
  bool _internal_linear_references() const;
  void _internal_set_linear_references(bool value);
  public:

  // bool prioritize_bidirectional = 48;
  bool has_prioritize_bidirectional() const;
  private:
  bool _internal_has_prioritize_bidirectional() const;
  public:
  void clear_prioritize_bidirectional();
  bool prioritize_bidirectional() const;
  void set_prioritize_bidirectional(bool value);
  private:
  bool _internal_prioritize_bidirectional() const;
  void _internal_set_prioritize_bidirectional(bool value);
  public:

  // .valhalla.Options.Action expansion_action = 49;
  bool has_expansion_action() const;
  private:
  bool _internal_has_expansion_action() const;
  public:
  void clear_expansion_action();
  ::valhalla::Options_Action expansion_action() const;
  void set_expansion_action(::valhalla::Options_Action value);
  private:
  ::valhalla::Options_Action _internal_expansion_action() const;
  void _internal_set_expansion_action(::valhalla::Options_Action value);
  public:

  // bool skip_opposites = 50;
  bool has_skip_opposites() const;
  private:
  bool _internal_has_skip_opposites() const;
  public:
  void clear_skip_opposites();
  bool skip_opposites() const;
  void set_skip_opposites(bool value);
  private:
  bool _internal_skip_opposites() const;
  void _internal_set_skip_opposites(bool value);
  public:

  void clear_has_language();
  HasLanguageCase has_language_case() const;
  void clear_has_id();
  HasIdCase has_id_case() const;
  void clear_has_jsonp();
  HasJsonpCase has_jsonp_case() const;
  void clear_has_encoded_polyline();
  HasEncodedPolylineCase has_encoded_polyline_case() const;
  void clear_has_range();
  HasRangeCase has_range_case() const;
  void clear_has_verbose();
  HasVerboseCase has_verbose_case() const;
  void clear_has_date_time();
  HasDateTimeCase has_date_time_case() const;
  void clear_has_resample_distance();
  HasResampleDistanceCase has_resample_distance_case() const;
  void clear_has_polygons();
  HasPolygonsCase has_polygons_case() const;
  void clear_has_denoise();
  HasDenoiseCase has_denoise_case() const;
  void clear_has_generalize();
  HasGeneralizeCase has_generalize_case() const;
  void clear_has_show_locations();
  HasShowLocationsCase has_show_locations_case() const;
  void clear_has_gps_accuracy();
  HasGpsAccuracyCase has_gps_accuracy_case() const;
  void clear_has_search_radius();
  HasSearchRadiusCase has_search_radius_case() const;
  void clear_has_turn_penalty_factor();
  HasTurnPenaltyFactorCase has_turn_penalty_factor_case() const;
  void clear_has_breakage_distance();
  HasBreakageDistanceCase has_breakage_distance_case() const;
  void clear_has_use_timestamps();
  HasUseTimestampsCase has_use_timestamps_case() const;
  void clear_has_alternates();
  HasAlternatesCase has_alternates_case() const;
  void clear_has_interpolation_distance();
  HasInterpolationDistanceCase has_interpolation_distance_case() const;
  void clear_has_guidance_views();
  HasGuidanceViewsCase has_guidance_views_case() const;
  void clear_has_height_precision();
  HasHeightPrecisionCase has_height_precision_case() const;
  void clear_has_roundabout_exits();
  HasRoundaboutExitsCase has_roundabout_exits_case() const;
  void clear_has_linear_references();
  HasLinearReferencesCase has_linear_references_case() const;
  void clear_has_prioritize_bidirectional();
  HasPrioritizeBidirectionalCase has_prioritize_bidirectional_case() const;
  void clear_has_expansion_action();
  HasExpansionActionCase has_expansion_action_case() const;
  void clear_has_skip_opposites();
  HasSkipOppositesCase has_skip_opposites_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Options)
 private:
  class _Internal;
  void set_has_language();
  void set_has_id();
  void set_has_jsonp();
  void set_has_encoded_polyline();
  void set_has_range();
  void set_has_verbose();
  void set_has_date_time();
  void set_has_resample_distance();
  void set_has_polygons();
  void set_has_denoise();
  void set_has_generalize();
  void set_has_show_locations();
  void set_has_gps_accuracy();
  void set_has_search_radius();
  void set_has_turn_penalty_factor();
  void set_has_breakage_distance();
  void set_has_use_timestamps();
  void set_has_alternates();
  void set_has_interpolation_distance();
  void set_has_guidance_views();
  void set_has_height_precision();
  void set_has_roundabout_exits();
  void set_has_linear_references();
  void set_has_prioritize_bidirectional();
  void set_has_expansion_action();
  void set_has_skip_opposites();

  inline bool has_has_language() const;
  inline void clear_has_has_language();

  inline bool has_has_id() const;
  inline void clear_has_has_id();

  inline bool has_has_jsonp() const;
  inline void clear_has_has_jsonp();

  inline bool has_has_encoded_polyline() const;
  inline void clear_has_has_encoded_polyline();

  inline bool has_has_range() const;
  inline void clear_has_has_range();

  inline bool has_has_verbose() const;
  inline void clear_has_has_verbose();

  inline bool has_has_date_time() const;
  inline void clear_has_has_date_time();

  inline bool has_has_resample_distance() const;
  inline void clear_has_has_resample_distance();

  inline bool has_has_polygons() const;
  inline void clear_has_has_polygons();

  inline bool has_has_denoise() const;
  inline void clear_has_has_denoise();

  inline bool has_has_generalize() const;
  inline void clear_has_has_generalize();

  inline bool has_has_show_locations() const;
  inline void clear_has_has_show_locations();

  inline bool has_has_gps_accuracy() const;
  inline void clear_has_has_gps_accuracy();

  inline bool has_has_search_radius() const;
  inline void clear_has_has_search_radius();

  inline bool has_has_turn_penalty_factor() const;
  inline void clear_has_has_turn_penalty_factor();

  inline bool has_has_breakage_distance() const;
  inline void clear_has_has_breakage_distance();

  inline bool has_has_use_timestamps() const;
  inline void clear_has_has_use_timestamps();

  inline bool has_has_alternates() const;
  inline void clear_has_has_alternates();

  inline bool has_has_interpolation_distance() const;
  inline void clear_has_has_interpolation_distance();

  inline bool has_has_guidance_views() const;
  inline void clear_has_has_guidance_views();

  inline bool has_has_height_precision() const;
  inline void clear_has_has_height_precision();

  inline bool has_has_roundabout_exits() const;
  inline void clear_has_has_roundabout_exits();

  inline bool has_has_linear_references() const;
  inline void clear_has_has_linear_references();

  inline bool has_has_prioritize_bidirectional() const;
  inline void clear_has_has_prioritize_bidirectional();

  inline bool has_has_expansion_action() const;
  inline void clear_has_has_expansion_action();

  inline bool has_has_skip_opposites() const;
  inline void clear_has_has_skip_opposites();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Options_CostingsEntry_DoNotUse,
      int32_t, ::valhalla::Costing,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> costings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > locations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > exclude_locations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > sources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > targets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > shape_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour > contours_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > trace_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_attributes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Costing > recostings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Ring > exclude_polygons_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> expansion_properties_;
  mutable std::atomic<int> _expansion_properties_cached_byte_size_;
  ::valhalla::PbfFieldSelector* pbf_field_selector_;
  int units_;
  int directions_type_;
  int format_;
  int action_;
  int costing_type_;
  int date_time_type_;
  uint32_t matrix_locations_;
  int shape_match_;
  int filter_action_;
  int shape_format_;
  bool reverse_;
  union HasLanguageUnion {
    constexpr HasLanguageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  } has_language_;
  union HasIdUnion {
    constexpr HasIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  } has_id_;
  union HasJsonpUnion {
    constexpr HasJsonpUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsonp_;
  } has_jsonp_;
  union HasEncodedPolylineUnion {
    constexpr HasEncodedPolylineUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_polyline_;
  } has_encoded_polyline_;
  union HasRangeUnion {
    constexpr HasRangeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool range_;
  } has_range_;
  union HasVerboseUnion {
    constexpr HasVerboseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool verbose_;
  } has_verbose_;
  union HasDateTimeUnion {
    constexpr HasDateTimeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_time_;
  } has_date_time_;
  union HasResampleDistanceUnion {
    constexpr HasResampleDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double resample_distance_;
  } has_resample_distance_;
  union HasPolygonsUnion {
    constexpr HasPolygonsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool polygons_;
  } has_polygons_;
  union HasDenoiseUnion {
    constexpr HasDenoiseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float denoise_;
  } has_denoise_;
  union HasGeneralizeUnion {
    constexpr HasGeneralizeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float generalize_;
  } has_generalize_;
  union HasShowLocationsUnion {
    constexpr HasShowLocationsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool show_locations_;
  } has_show_locations_;
  union HasGpsAccuracyUnion {
    constexpr HasGpsAccuracyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float gps_accuracy_;
  } has_gps_accuracy_;
  union HasSearchRadiusUnion {
    constexpr HasSearchRadiusUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float search_radius_;
  } has_search_radius_;
  union HasTurnPenaltyFactorUnion {
    constexpr HasTurnPenaltyFactorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float turn_penalty_factor_;
  } has_turn_penalty_factor_;
  union HasBreakageDistanceUnion {
    constexpr HasBreakageDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float breakage_distance_;
  } has_breakage_distance_;
  union HasUseTimestampsUnion {
    constexpr HasUseTimestampsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool use_timestamps_;
  } has_use_timestamps_;
  union HasAlternatesUnion {
    constexpr HasAlternatesUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t alternates_;
  } has_alternates_;
  union HasInterpolationDistanceUnion {
    constexpr HasInterpolationDistanceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float interpolation_distance_;
  } has_interpolation_distance_;
  union HasGuidanceViewsUnion {
    constexpr HasGuidanceViewsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool guidance_views_;
  } has_guidance_views_;
  union HasHeightPrecisionUnion {
    constexpr HasHeightPrecisionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t height_precision_;
  } has_height_precision_;
  union HasRoundaboutExitsUnion {
    constexpr HasRoundaboutExitsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool roundabout_exits_;
  } has_roundabout_exits_;
  union HasLinearReferencesUnion {
    constexpr HasLinearReferencesUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool linear_references_;
  } has_linear_references_;
  union HasPrioritizeBidirectionalUnion {
    constexpr HasPrioritizeBidirectionalUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool prioritize_bidirectional_;
  } has_prioritize_bidirectional_;
  union HasExpansionActionUnion {
    constexpr HasExpansionActionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int expansion_action_;
  } has_expansion_action_;
  union HasSkipOppositesUnion {
    constexpr HasSkipOppositesUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool skip_opposites_;
  } has_skip_opposites_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[26];

  friend struct ::TableStruct_options_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Contour

// float time = 1;
inline bool Contour::_internal_has_time() const {
  return has_time_case() == kTime;
}
inline bool Contour::has_time() const {
  return _internal_has_time();
}
inline void Contour::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void Contour::clear_time() {
  if (_internal_has_time()) {
    has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline float Contour::_internal_time() const {
  if (_internal_has_time()) {
    return has_time_.time_;
  }
  return 0;
}
inline void Contour::_internal_set_time(float value) {
  if (!_internal_has_time()) {
    clear_has_time();
    set_has_time();
  }
  has_time_.time_ = value;
}
inline float Contour::time() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.time)
  return _internal_time();
}
inline void Contour::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.Contour.time)
}

// string color = 2;
inline bool Contour::_internal_has_color() const {
  return has_color_case() == kColor;
}
inline bool Contour::has_color() const {
  return _internal_has_color();
}
inline void Contour::set_has_color() {
  _oneof_case_[1] = kColor;
}
inline void Contour::clear_color() {
  if (_internal_has_color()) {
    has_color_.color_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_color();
  }
}
inline const std::string& Contour::color() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline void Contour::set_color(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_color()) {
    clear_has_color();
    set_has_color();
    has_color_.color_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_color_.color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Contour.color)
}
inline std::string* Contour::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:valhalla.Contour.color)
  return _s;
}
inline const std::string& Contour::_internal_color() const {
  if (_internal_has_color()) {
    return has_color_.color_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Contour::_internal_set_color(const std::string& value) {
  if (!_internal_has_color()) {
    clear_has_color();
    set_has_color();
    has_color_.color_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_color_.color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Contour::_internal_mutable_color() {
  if (!_internal_has_color()) {
    clear_has_color();
    set_has_color();
    has_color_.color_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_color_.color_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Contour::release_color() {
  // @@protoc_insertion_point(field_release:valhalla.Contour.color)
  if (_internal_has_color()) {
    clear_has_has_color();
    return has_color_.color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Contour::set_allocated_color(std::string* color) {
  if (has_has_color()) {
    clear_has_color();
  }
  if (color != nullptr) {
    set_has_color();
    has_color_.color_.UnsafeSetDefault(color);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(color);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Contour.color)
}

// float distance = 3;
inline bool Contour::_internal_has_distance() const {
  return has_distance_case() == kDistance;
}
inline bool Contour::has_distance() const {
  return _internal_has_distance();
}
inline void Contour::set_has_distance() {
  _oneof_case_[2] = kDistance;
}
inline void Contour::clear_distance() {
  if (_internal_has_distance()) {
    has_distance_.distance_ = 0;
    clear_has_has_distance();
  }
}
inline float Contour::_internal_distance() const {
  if (_internal_has_distance()) {
    return has_distance_.distance_;
  }
  return 0;
}
inline void Contour::_internal_set_distance(float value) {
  if (!_internal_has_distance()) {
    clear_has_distance();
    set_has_distance();
  }
  has_distance_.distance_ = value;
}
inline float Contour::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.distance)
  return _internal_distance();
}
inline void Contour::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Contour.distance)
}

inline bool Contour::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void Contour::clear_has_has_time() {
  _oneof_case_[0] = HAS_TIME_NOT_SET;
}
inline bool Contour::has_has_color() const {
  return has_color_case() != HAS_COLOR_NOT_SET;
}
inline void Contour::clear_has_has_color() {
  _oneof_case_[1] = HAS_COLOR_NOT_SET;
}
inline bool Contour::has_has_distance() const {
  return has_distance_case() != HAS_DISTANCE_NOT_SET;
}
inline void Contour::clear_has_has_distance() {
  _oneof_case_[2] = HAS_DISTANCE_NOT_SET;
}
inline Contour::HasTimeCase Contour::has_time_case() const {
  return Contour::HasTimeCase(_oneof_case_[0]);
}
inline Contour::HasColorCase Contour::has_color_case() const {
  return Contour::HasColorCase(_oneof_case_[1]);
}
inline Contour::HasDistanceCase Contour::has_distance_case() const {
  return Contour::HasDistanceCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// Ring

// repeated .valhalla.LatLng coords = 1;
inline int Ring::_internal_coords_size() const {
  return coords_.size();
}
inline int Ring::coords_size() const {
  return _internal_coords_size();
}
inline ::valhalla::LatLng* Ring::mutable_coords(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Ring.coords)
  return coords_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >*
Ring::mutable_coords() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Ring.coords)
  return &coords_;
}
inline const ::valhalla::LatLng& Ring::_internal_coords(int index) const {
  return coords_.Get(index);
}
inline const ::valhalla::LatLng& Ring::coords(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Ring.coords)
  return _internal_coords(index);
}
inline ::valhalla::LatLng* Ring::_internal_add_coords() {
  return coords_.Add();
}
inline ::valhalla::LatLng* Ring::add_coords() {
  ::valhalla::LatLng* _add = _internal_add_coords();
  // @@protoc_insertion_point(field_add:valhalla.Ring.coords)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >&
Ring::coords() const {
  // @@protoc_insertion_point(field_list:valhalla.Ring.coords)
  return coords_;
}

// -------------------------------------------------------------------

// PbfFieldSelector

// bool options = 1;
inline void PbfFieldSelector::clear_options() {
  options_ = false;
}
inline bool PbfFieldSelector::_internal_options() const {
  return options_;
}
inline bool PbfFieldSelector::options() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.options)
  return _internal_options();
}
inline void PbfFieldSelector::_internal_set_options(bool value) {
  
  options_ = value;
}
inline void PbfFieldSelector::set_options(bool value) {
  _internal_set_options(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.options)
}

// bool trip = 2;
inline void PbfFieldSelector::clear_trip() {
  trip_ = false;
}
inline bool PbfFieldSelector::_internal_trip() const {
  return trip_;
}
inline bool PbfFieldSelector::trip() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.trip)
  return _internal_trip();
}
inline void PbfFieldSelector::_internal_set_trip(bool value) {
  
  trip_ = value;
}
inline void PbfFieldSelector::set_trip(bool value) {
  _internal_set_trip(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.trip)
}

// bool directions = 3;
inline void PbfFieldSelector::clear_directions() {
  directions_ = false;
}
inline bool PbfFieldSelector::_internal_directions() const {
  return directions_;
}
inline bool PbfFieldSelector::directions() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.directions)
  return _internal_directions();
}
inline void PbfFieldSelector::_internal_set_directions(bool value) {
  
  directions_ = value;
}
inline void PbfFieldSelector::set_directions(bool value) {
  _internal_set_directions(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.directions)
}

// bool status = 4;
inline void PbfFieldSelector::clear_status() {
  status_ = false;
}
inline bool PbfFieldSelector::_internal_status() const {
  return status_;
}
inline bool PbfFieldSelector::status() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.status)
  return _internal_status();
}
inline void PbfFieldSelector::_internal_set_status(bool value) {
  
  status_ = value;
}
inline void PbfFieldSelector::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.status)
}

// -------------------------------------------------------------------

// AvoidEdge

// uint64 id = 1;
inline bool AvoidEdge::_internal_has_id() const {
  return has_id_case() == kId;
}
inline bool AvoidEdge::has_id() const {
  return _internal_has_id();
}
inline void AvoidEdge::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void AvoidEdge::clear_id() {
  if (_internal_has_id()) {
    has_id_.id_ = uint64_t{0u};
    clear_has_has_id();
  }
}
inline uint64_t AvoidEdge::_internal_id() const {
  if (_internal_has_id()) {
    return has_id_.id_;
  }
  return uint64_t{0u};
}
inline void AvoidEdge::_internal_set_id(uint64_t value) {
  if (!_internal_has_id()) {
    clear_has_id();
    set_has_id();
  }
  has_id_.id_ = value;
}
inline uint64_t AvoidEdge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.id)
  return _internal_id();
}
inline void AvoidEdge::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.id)
}

// float percent_along = 2;
inline bool AvoidEdge::_internal_has_percent_along() const {
  return has_percent_along_case() == kPercentAlong;
}
inline bool AvoidEdge::has_percent_along() const {
  return _internal_has_percent_along();
}
inline void AvoidEdge::set_has_percent_along() {
  _oneof_case_[1] = kPercentAlong;
}
inline void AvoidEdge::clear_percent_along() {
  if (_internal_has_percent_along()) {
    has_percent_along_.percent_along_ = 0;
    clear_has_has_percent_along();
  }
}
inline float AvoidEdge::_internal_percent_along() const {
  if (_internal_has_percent_along()) {
    return has_percent_along_.percent_along_;
  }
  return 0;
}
inline void AvoidEdge::_internal_set_percent_along(float value) {
  if (!_internal_has_percent_along()) {
    clear_has_percent_along();
    set_has_percent_along();
  }
  has_percent_along_.percent_along_ = value;
}
inline float AvoidEdge::percent_along() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.percent_along)
  return _internal_percent_along();
}
inline void AvoidEdge::set_percent_along(float value) {
  _internal_set_percent_along(value);
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.percent_along)
}

inline bool AvoidEdge::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void AvoidEdge::clear_has_has_id() {
  _oneof_case_[0] = HAS_ID_NOT_SET;
}
inline bool AvoidEdge::has_has_percent_along() const {
  return has_percent_along_case() != HAS_PERCENT_ALONG_NOT_SET;
}
inline void AvoidEdge::clear_has_has_percent_along() {
  _oneof_case_[1] = HAS_PERCENT_ALONG_NOT_SET;
}
inline AvoidEdge::HasIdCase AvoidEdge::has_id_case() const {
  return AvoidEdge::HasIdCase(_oneof_case_[0]);
}
inline AvoidEdge::HasPercentAlongCase AvoidEdge::has_percent_along_case() const {
  return AvoidEdge::HasPercentAlongCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// Costing_Options

// float maneuver_penalty = 1;
inline bool Costing_Options::_internal_has_maneuver_penalty() const {
  return has_maneuver_penalty_case() == kManeuverPenalty;
}
inline bool Costing_Options::has_maneuver_penalty() const {
  return _internal_has_maneuver_penalty();
}
inline void Costing_Options::set_has_maneuver_penalty() {
  _oneof_case_[0] = kManeuverPenalty;
}
inline void Costing_Options::clear_maneuver_penalty() {
  if (_internal_has_maneuver_penalty()) {
    has_maneuver_penalty_.maneuver_penalty_ = 0;
    clear_has_has_maneuver_penalty();
  }
}
inline float Costing_Options::_internal_maneuver_penalty() const {
  if (_internal_has_maneuver_penalty()) {
    return has_maneuver_penalty_.maneuver_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_maneuver_penalty(float value) {
  if (!_internal_has_maneuver_penalty()) {
    clear_has_maneuver_penalty();
    set_has_maneuver_penalty();
  }
  has_maneuver_penalty_.maneuver_penalty_ = value;
}
inline float Costing_Options::maneuver_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.maneuver_penalty)
  return _internal_maneuver_penalty();
}
inline void Costing_Options::set_maneuver_penalty(float value) {
  _internal_set_maneuver_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.maneuver_penalty)
}

// float destination_only_penalty = 2;
inline bool Costing_Options::_internal_has_destination_only_penalty() const {
  return has_destination_only_penalty_case() == kDestinationOnlyPenalty;
}
inline bool Costing_Options::has_destination_only_penalty() const {
  return _internal_has_destination_only_penalty();
}
inline void Costing_Options::set_has_destination_only_penalty() {
  _oneof_case_[1] = kDestinationOnlyPenalty;
}
inline void Costing_Options::clear_destination_only_penalty() {
  if (_internal_has_destination_only_penalty()) {
    has_destination_only_penalty_.destination_only_penalty_ = 0;
    clear_has_has_destination_only_penalty();
  }
}
inline float Costing_Options::_internal_destination_only_penalty() const {
  if (_internal_has_destination_only_penalty()) {
    return has_destination_only_penalty_.destination_only_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_destination_only_penalty(float value) {
  if (!_internal_has_destination_only_penalty()) {
    clear_has_destination_only_penalty();
    set_has_destination_only_penalty();
  }
  has_destination_only_penalty_.destination_only_penalty_ = value;
}
inline float Costing_Options::destination_only_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.destination_only_penalty)
  return _internal_destination_only_penalty();
}
inline void Costing_Options::set_destination_only_penalty(float value) {
  _internal_set_destination_only_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.destination_only_penalty)
}

// float gate_cost = 3;
inline bool Costing_Options::_internal_has_gate_cost() const {
  return has_gate_cost_case() == kGateCost;
}
inline bool Costing_Options::has_gate_cost() const {
  return _internal_has_gate_cost();
}
inline void Costing_Options::set_has_gate_cost() {
  _oneof_case_[2] = kGateCost;
}
inline void Costing_Options::clear_gate_cost() {
  if (_internal_has_gate_cost()) {
    has_gate_cost_.gate_cost_ = 0;
    clear_has_has_gate_cost();
  }
}
inline float Costing_Options::_internal_gate_cost() const {
  if (_internal_has_gate_cost()) {
    return has_gate_cost_.gate_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_gate_cost(float value) {
  if (!_internal_has_gate_cost()) {
    clear_has_gate_cost();
    set_has_gate_cost();
  }
  has_gate_cost_.gate_cost_ = value;
}
inline float Costing_Options::gate_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.gate_cost)
  return _internal_gate_cost();
}
inline void Costing_Options::set_gate_cost(float value) {
  _internal_set_gate_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.gate_cost)
}

// float gate_penalty = 4;
inline bool Costing_Options::_internal_has_gate_penalty() const {
  return has_gate_penalty_case() == kGatePenalty;
}
inline bool Costing_Options::has_gate_penalty() const {
  return _internal_has_gate_penalty();
}
inline void Costing_Options::set_has_gate_penalty() {
  _oneof_case_[3] = kGatePenalty;
}
inline void Costing_Options::clear_gate_penalty() {
  if (_internal_has_gate_penalty()) {
    has_gate_penalty_.gate_penalty_ = 0;
    clear_has_has_gate_penalty();
  }
}
inline float Costing_Options::_internal_gate_penalty() const {
  if (_internal_has_gate_penalty()) {
    return has_gate_penalty_.gate_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_gate_penalty(float value) {
  if (!_internal_has_gate_penalty()) {
    clear_has_gate_penalty();
    set_has_gate_penalty();
  }
  has_gate_penalty_.gate_penalty_ = value;
}
inline float Costing_Options::gate_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.gate_penalty)
  return _internal_gate_penalty();
}
inline void Costing_Options::set_gate_penalty(float value) {
  _internal_set_gate_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.gate_penalty)
}

// float toll_booth_cost = 5;
inline bool Costing_Options::_internal_has_toll_booth_cost() const {
  return has_toll_booth_cost_case() == kTollBoothCost;
}
inline bool Costing_Options::has_toll_booth_cost() const {
  return _internal_has_toll_booth_cost();
}
inline void Costing_Options::set_has_toll_booth_cost() {
  _oneof_case_[4] = kTollBoothCost;
}
inline void Costing_Options::clear_toll_booth_cost() {
  if (_internal_has_toll_booth_cost()) {
    has_toll_booth_cost_.toll_booth_cost_ = 0;
    clear_has_has_toll_booth_cost();
  }
}
inline float Costing_Options::_internal_toll_booth_cost() const {
  if (_internal_has_toll_booth_cost()) {
    return has_toll_booth_cost_.toll_booth_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_toll_booth_cost(float value) {
  if (!_internal_has_toll_booth_cost()) {
    clear_has_toll_booth_cost();
    set_has_toll_booth_cost();
  }
  has_toll_booth_cost_.toll_booth_cost_ = value;
}
inline float Costing_Options::toll_booth_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.toll_booth_cost)
  return _internal_toll_booth_cost();
}
inline void Costing_Options::set_toll_booth_cost(float value) {
  _internal_set_toll_booth_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.toll_booth_cost)
}

// float toll_booth_penalty = 6;
inline bool Costing_Options::_internal_has_toll_booth_penalty() const {
  return has_toll_booth_penalty_case() == kTollBoothPenalty;
}
inline bool Costing_Options::has_toll_booth_penalty() const {
  return _internal_has_toll_booth_penalty();
}
inline void Costing_Options::set_has_toll_booth_penalty() {
  _oneof_case_[5] = kTollBoothPenalty;
}
inline void Costing_Options::clear_toll_booth_penalty() {
  if (_internal_has_toll_booth_penalty()) {
    has_toll_booth_penalty_.toll_booth_penalty_ = 0;
    clear_has_has_toll_booth_penalty();
  }
}
inline float Costing_Options::_internal_toll_booth_penalty() const {
  if (_internal_has_toll_booth_penalty()) {
    return has_toll_booth_penalty_.toll_booth_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_toll_booth_penalty(float value) {
  if (!_internal_has_toll_booth_penalty()) {
    clear_has_toll_booth_penalty();
    set_has_toll_booth_penalty();
  }
  has_toll_booth_penalty_.toll_booth_penalty_ = value;
}
inline float Costing_Options::toll_booth_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.toll_booth_penalty)
  return _internal_toll_booth_penalty();
}
inline void Costing_Options::set_toll_booth_penalty(float value) {
  _internal_set_toll_booth_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.toll_booth_penalty)
}

// float alley_penalty = 7;
inline bool Costing_Options::_internal_has_alley_penalty() const {
  return has_alley_penalty_case() == kAlleyPenalty;
}
inline bool Costing_Options::has_alley_penalty() const {
  return _internal_has_alley_penalty();
}
inline void Costing_Options::set_has_alley_penalty() {
  _oneof_case_[6] = kAlleyPenalty;
}
inline void Costing_Options::clear_alley_penalty() {
  if (_internal_has_alley_penalty()) {
    has_alley_penalty_.alley_penalty_ = 0;
    clear_has_has_alley_penalty();
  }
}
inline float Costing_Options::_internal_alley_penalty() const {
  if (_internal_has_alley_penalty()) {
    return has_alley_penalty_.alley_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_alley_penalty(float value) {
  if (!_internal_has_alley_penalty()) {
    clear_has_alley_penalty();
    set_has_alley_penalty();
  }
  has_alley_penalty_.alley_penalty_ = value;
}
inline float Costing_Options::alley_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.alley_penalty)
  return _internal_alley_penalty();
}
inline void Costing_Options::set_alley_penalty(float value) {
  _internal_set_alley_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.alley_penalty)
}

// float country_crossing_cost = 8;
inline bool Costing_Options::_internal_has_country_crossing_cost() const {
  return has_country_crossing_cost_case() == kCountryCrossingCost;
}
inline bool Costing_Options::has_country_crossing_cost() const {
  return _internal_has_country_crossing_cost();
}
inline void Costing_Options::set_has_country_crossing_cost() {
  _oneof_case_[7] = kCountryCrossingCost;
}
inline void Costing_Options::clear_country_crossing_cost() {
  if (_internal_has_country_crossing_cost()) {
    has_country_crossing_cost_.country_crossing_cost_ = 0;
    clear_has_has_country_crossing_cost();
  }
}
inline float Costing_Options::_internal_country_crossing_cost() const {
  if (_internal_has_country_crossing_cost()) {
    return has_country_crossing_cost_.country_crossing_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_country_crossing_cost(float value) {
  if (!_internal_has_country_crossing_cost()) {
    clear_has_country_crossing_cost();
    set_has_country_crossing_cost();
  }
  has_country_crossing_cost_.country_crossing_cost_ = value;
}
inline float Costing_Options::country_crossing_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.country_crossing_cost)
  return _internal_country_crossing_cost();
}
inline void Costing_Options::set_country_crossing_cost(float value) {
  _internal_set_country_crossing_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.country_crossing_cost)
}

// float country_crossing_penalty = 9;
inline bool Costing_Options::_internal_has_country_crossing_penalty() const {
  return has_country_crossing_penalty_case() == kCountryCrossingPenalty;
}
inline bool Costing_Options::has_country_crossing_penalty() const {
  return _internal_has_country_crossing_penalty();
}
inline void Costing_Options::set_has_country_crossing_penalty() {
  _oneof_case_[8] = kCountryCrossingPenalty;
}
inline void Costing_Options::clear_country_crossing_penalty() {
  if (_internal_has_country_crossing_penalty()) {
    has_country_crossing_penalty_.country_crossing_penalty_ = 0;
    clear_has_has_country_crossing_penalty();
  }
}
inline float Costing_Options::_internal_country_crossing_penalty() const {
  if (_internal_has_country_crossing_penalty()) {
    return has_country_crossing_penalty_.country_crossing_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_country_crossing_penalty(float value) {
  if (!_internal_has_country_crossing_penalty()) {
    clear_has_country_crossing_penalty();
    set_has_country_crossing_penalty();
  }
  has_country_crossing_penalty_.country_crossing_penalty_ = value;
}
inline float Costing_Options::country_crossing_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.country_crossing_penalty)
  return _internal_country_crossing_penalty();
}
inline void Costing_Options::set_country_crossing_penalty(float value) {
  _internal_set_country_crossing_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.country_crossing_penalty)
}

// float ferry_cost = 10;
inline bool Costing_Options::_internal_has_ferry_cost() const {
  return has_ferry_cost_case() == kFerryCost;
}
inline bool Costing_Options::has_ferry_cost() const {
  return _internal_has_ferry_cost();
}
inline void Costing_Options::set_has_ferry_cost() {
  _oneof_case_[9] = kFerryCost;
}
inline void Costing_Options::clear_ferry_cost() {
  if (_internal_has_ferry_cost()) {
    has_ferry_cost_.ferry_cost_ = 0;
    clear_has_has_ferry_cost();
  }
}
inline float Costing_Options::_internal_ferry_cost() const {
  if (_internal_has_ferry_cost()) {
    return has_ferry_cost_.ferry_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_ferry_cost(float value) {
  if (!_internal_has_ferry_cost()) {
    clear_has_ferry_cost();
    set_has_ferry_cost();
  }
  has_ferry_cost_.ferry_cost_ = value;
}
inline float Costing_Options::ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ferry_cost)
  return _internal_ferry_cost();
}
inline void Costing_Options::set_ferry_cost(float value) {
  _internal_set_ferry_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ferry_cost)
}

// float avoid_bad_surfaces = 11;
inline bool Costing_Options::_internal_has_avoid_bad_surfaces() const {
  return has_avoid_bad_surfaces_case() == kAvoidBadSurfaces;
}
inline bool Costing_Options::has_avoid_bad_surfaces() const {
  return _internal_has_avoid_bad_surfaces();
}
inline void Costing_Options::set_has_avoid_bad_surfaces() {
  _oneof_case_[10] = kAvoidBadSurfaces;
}
inline void Costing_Options::clear_avoid_bad_surfaces() {
  if (_internal_has_avoid_bad_surfaces()) {
    has_avoid_bad_surfaces_.avoid_bad_surfaces_ = 0;
    clear_has_has_avoid_bad_surfaces();
  }
}
inline float Costing_Options::_internal_avoid_bad_surfaces() const {
  if (_internal_has_avoid_bad_surfaces()) {
    return has_avoid_bad_surfaces_.avoid_bad_surfaces_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_avoid_bad_surfaces(float value) {
  if (!_internal_has_avoid_bad_surfaces()) {
    clear_has_avoid_bad_surfaces();
    set_has_avoid_bad_surfaces();
  }
  has_avoid_bad_surfaces_.avoid_bad_surfaces_ = value;
}
inline float Costing_Options::avoid_bad_surfaces() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.avoid_bad_surfaces)
  return _internal_avoid_bad_surfaces();
}
inline void Costing_Options::set_avoid_bad_surfaces(float value) {
  _internal_set_avoid_bad_surfaces(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.avoid_bad_surfaces)
}

// float use_ferry = 12;
inline bool Costing_Options::_internal_has_use_ferry() const {
  return has_use_ferry_case() == kUseFerry;
}
inline bool Costing_Options::has_use_ferry() const {
  return _internal_has_use_ferry();
}
inline void Costing_Options::set_has_use_ferry() {
  _oneof_case_[11] = kUseFerry;
}
inline void Costing_Options::clear_use_ferry() {
  if (_internal_has_use_ferry()) {
    has_use_ferry_.use_ferry_ = 0;
    clear_has_has_use_ferry();
  }
}
inline float Costing_Options::_internal_use_ferry() const {
  if (_internal_has_use_ferry()) {
    return has_use_ferry_.use_ferry_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_ferry(float value) {
  if (!_internal_has_use_ferry()) {
    clear_has_use_ferry();
    set_has_use_ferry();
  }
  has_use_ferry_.use_ferry_ = value;
}
inline float Costing_Options::use_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_ferry)
  return _internal_use_ferry();
}
inline void Costing_Options::set_use_ferry(float value) {
  _internal_set_use_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_ferry)
}

// float use_highways = 13;
inline bool Costing_Options::_internal_has_use_highways() const {
  return has_use_highways_case() == kUseHighways;
}
inline bool Costing_Options::has_use_highways() const {
  return _internal_has_use_highways();
}
inline void Costing_Options::set_has_use_highways() {
  _oneof_case_[12] = kUseHighways;
}
inline void Costing_Options::clear_use_highways() {
  if (_internal_has_use_highways()) {
    has_use_highways_.use_highways_ = 0;
    clear_has_has_use_highways();
  }
}
inline float Costing_Options::_internal_use_highways() const {
  if (_internal_has_use_highways()) {
    return has_use_highways_.use_highways_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_highways(float value) {
  if (!_internal_has_use_highways()) {
    clear_has_use_highways();
    set_has_use_highways();
  }
  has_use_highways_.use_highways_ = value;
}
inline float Costing_Options::use_highways() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_highways)
  return _internal_use_highways();
}
inline void Costing_Options::set_use_highways(float value) {
  _internal_set_use_highways(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_highways)
}

// float use_tolls = 14;
inline bool Costing_Options::_internal_has_use_tolls() const {
  return has_use_tolls_case() == kUseTolls;
}
inline bool Costing_Options::has_use_tolls() const {
  return _internal_has_use_tolls();
}
inline void Costing_Options::set_has_use_tolls() {
  _oneof_case_[13] = kUseTolls;
}
inline void Costing_Options::clear_use_tolls() {
  if (_internal_has_use_tolls()) {
    has_use_tolls_.use_tolls_ = 0;
    clear_has_has_use_tolls();
  }
}
inline float Costing_Options::_internal_use_tolls() const {
  if (_internal_has_use_tolls()) {
    return has_use_tolls_.use_tolls_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_tolls(float value) {
  if (!_internal_has_use_tolls()) {
    clear_has_use_tolls();
    set_has_use_tolls();
  }
  has_use_tolls_.use_tolls_ = value;
}
inline float Costing_Options::use_tolls() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_tolls)
  return _internal_use_tolls();
}
inline void Costing_Options::set_use_tolls(float value) {
  _internal_set_use_tolls(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_tolls)
}

// float use_roads = 15;
inline bool Costing_Options::_internal_has_use_roads() const {
  return has_use_roads_case() == kUseRoads;
}
inline bool Costing_Options::has_use_roads() const {
  return _internal_has_use_roads();
}
inline void Costing_Options::set_has_use_roads() {
  _oneof_case_[14] = kUseRoads;
}
inline void Costing_Options::clear_use_roads() {
  if (_internal_has_use_roads()) {
    has_use_roads_.use_roads_ = 0;
    clear_has_has_use_roads();
  }
}
inline float Costing_Options::_internal_use_roads() const {
  if (_internal_has_use_roads()) {
    return has_use_roads_.use_roads_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_roads(float value) {
  if (!_internal_has_use_roads()) {
    clear_has_use_roads();
    set_has_use_roads();
  }
  has_use_roads_.use_roads_ = value;
}
inline float Costing_Options::use_roads() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_roads)
  return _internal_use_roads();
}
inline void Costing_Options::set_use_roads(float value) {
  _internal_set_use_roads(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_roads)
}

// uint32 max_distance = 16;
inline bool Costing_Options::_internal_has_max_distance() const {
  return has_max_distance_case() == kMaxDistance;
}
inline bool Costing_Options::has_max_distance() const {
  return _internal_has_max_distance();
}
inline void Costing_Options::set_has_max_distance() {
  _oneof_case_[15] = kMaxDistance;
}
inline void Costing_Options::clear_max_distance() {
  if (_internal_has_max_distance()) {
    has_max_distance_.max_distance_ = 0u;
    clear_has_has_max_distance();
  }
}
inline uint32_t Costing_Options::_internal_max_distance() const {
  if (_internal_has_max_distance()) {
    return has_max_distance_.max_distance_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_max_distance(uint32_t value) {
  if (!_internal_has_max_distance()) {
    clear_has_max_distance();
    set_has_max_distance();
  }
  has_max_distance_.max_distance_ = value;
}
inline uint32_t Costing_Options::max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.max_distance)
  return _internal_max_distance();
}
inline void Costing_Options::set_max_distance(uint32_t value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.max_distance)
}

// float walking_speed = 17;
inline bool Costing_Options::_internal_has_walking_speed() const {
  return has_walking_speed_case() == kWalkingSpeed;
}
inline bool Costing_Options::has_walking_speed() const {
  return _internal_has_walking_speed();
}
inline void Costing_Options::set_has_walking_speed() {
  _oneof_case_[16] = kWalkingSpeed;
}
inline void Costing_Options::clear_walking_speed() {
  if (_internal_has_walking_speed()) {
    has_walking_speed_.walking_speed_ = 0;
    clear_has_has_walking_speed();
  }
}
inline float Costing_Options::_internal_walking_speed() const {
  if (_internal_has_walking_speed()) {
    return has_walking_speed_.walking_speed_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_walking_speed(float value) {
  if (!_internal_has_walking_speed()) {
    clear_has_walking_speed();
    set_has_walking_speed();
  }
  has_walking_speed_.walking_speed_ = value;
}
inline float Costing_Options::walking_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.walking_speed)
  return _internal_walking_speed();
}
inline void Costing_Options::set_walking_speed(float value) {
  _internal_set_walking_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.walking_speed)
}

// float step_penalty = 18;
inline bool Costing_Options::_internal_has_step_penalty() const {
  return has_step_penalty_case() == kStepPenalty;
}
inline bool Costing_Options::has_step_penalty() const {
  return _internal_has_step_penalty();
}
inline void Costing_Options::set_has_step_penalty() {
  _oneof_case_[17] = kStepPenalty;
}
inline void Costing_Options::clear_step_penalty() {
  if (_internal_has_step_penalty()) {
    has_step_penalty_.step_penalty_ = 0;
    clear_has_has_step_penalty();
  }
}
inline float Costing_Options::_internal_step_penalty() const {
  if (_internal_has_step_penalty()) {
    return has_step_penalty_.step_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_step_penalty(float value) {
  if (!_internal_has_step_penalty()) {
    clear_has_step_penalty();
    set_has_step_penalty();
  }
  has_step_penalty_.step_penalty_ = value;
}
inline float Costing_Options::step_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.step_penalty)
  return _internal_step_penalty();
}
inline void Costing_Options::set_step_penalty(float value) {
  _internal_set_step_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.step_penalty)
}

// uint32 max_grade = 19;
inline bool Costing_Options::_internal_has_max_grade() const {
  return has_max_grade_case() == kMaxGrade;
}
inline bool Costing_Options::has_max_grade() const {
  return _internal_has_max_grade();
}
inline void Costing_Options::set_has_max_grade() {
  _oneof_case_[18] = kMaxGrade;
}
inline void Costing_Options::clear_max_grade() {
  if (_internal_has_max_grade()) {
    has_max_grade_.max_grade_ = 0u;
    clear_has_has_max_grade();
  }
}
inline uint32_t Costing_Options::_internal_max_grade() const {
  if (_internal_has_max_grade()) {
    return has_max_grade_.max_grade_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_max_grade(uint32_t value) {
  if (!_internal_has_max_grade()) {
    clear_has_max_grade();
    set_has_max_grade();
  }
  has_max_grade_.max_grade_ = value;
}
inline uint32_t Costing_Options::max_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.max_grade)
  return _internal_max_grade();
}
inline void Costing_Options::set_max_grade(uint32_t value) {
  _internal_set_max_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.max_grade)
}

// uint32 max_hiking_difficulty = 20;
inline bool Costing_Options::_internal_has_max_hiking_difficulty() const {
  return has_max_hiking_difficulty_case() == kMaxHikingDifficulty;
}
inline bool Costing_Options::has_max_hiking_difficulty() const {
  return _internal_has_max_hiking_difficulty();
}
inline void Costing_Options::set_has_max_hiking_difficulty() {
  _oneof_case_[19] = kMaxHikingDifficulty;
}
inline void Costing_Options::clear_max_hiking_difficulty() {
  if (_internal_has_max_hiking_difficulty()) {
    has_max_hiking_difficulty_.max_hiking_difficulty_ = 0u;
    clear_has_has_max_hiking_difficulty();
  }
}
inline uint32_t Costing_Options::_internal_max_hiking_difficulty() const {
  if (_internal_has_max_hiking_difficulty()) {
    return has_max_hiking_difficulty_.max_hiking_difficulty_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_max_hiking_difficulty(uint32_t value) {
  if (!_internal_has_max_hiking_difficulty()) {
    clear_has_max_hiking_difficulty();
    set_has_max_hiking_difficulty();
  }
  has_max_hiking_difficulty_.max_hiking_difficulty_ = value;
}
inline uint32_t Costing_Options::max_hiking_difficulty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.max_hiking_difficulty)
  return _internal_max_hiking_difficulty();
}
inline void Costing_Options::set_max_hiking_difficulty(uint32_t value) {
  _internal_set_max_hiking_difficulty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.max_hiking_difficulty)
}

// float mode_factor = 21;
inline bool Costing_Options::_internal_has_mode_factor() const {
  return has_mode_factor_case() == kModeFactor;
}
inline bool Costing_Options::has_mode_factor() const {
  return _internal_has_mode_factor();
}
inline void Costing_Options::set_has_mode_factor() {
  _oneof_case_[20] = kModeFactor;
}
inline void Costing_Options::clear_mode_factor() {
  if (_internal_has_mode_factor()) {
    has_mode_factor_.mode_factor_ = 0;
    clear_has_has_mode_factor();
  }
}
inline float Costing_Options::_internal_mode_factor() const {
  if (_internal_has_mode_factor()) {
    return has_mode_factor_.mode_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_mode_factor(float value) {
  if (!_internal_has_mode_factor()) {
    clear_has_mode_factor();
    set_has_mode_factor();
  }
  has_mode_factor_.mode_factor_ = value;
}
inline float Costing_Options::mode_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.mode_factor)
  return _internal_mode_factor();
}
inline void Costing_Options::set_mode_factor(float value) {
  _internal_set_mode_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.mode_factor)
}

// float walkway_factor = 22;
inline bool Costing_Options::_internal_has_walkway_factor() const {
  return has_walkway_factor_case() == kWalkwayFactor;
}
inline bool Costing_Options::has_walkway_factor() const {
  return _internal_has_walkway_factor();
}
inline void Costing_Options::set_has_walkway_factor() {
  _oneof_case_[21] = kWalkwayFactor;
}
inline void Costing_Options::clear_walkway_factor() {
  if (_internal_has_walkway_factor()) {
    has_walkway_factor_.walkway_factor_ = 0;
    clear_has_has_walkway_factor();
  }
}
inline float Costing_Options::_internal_walkway_factor() const {
  if (_internal_has_walkway_factor()) {
    return has_walkway_factor_.walkway_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_walkway_factor(float value) {
  if (!_internal_has_walkway_factor()) {
    clear_has_walkway_factor();
    set_has_walkway_factor();
  }
  has_walkway_factor_.walkway_factor_ = value;
}
inline float Costing_Options::walkway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.walkway_factor)
  return _internal_walkway_factor();
}
inline void Costing_Options::set_walkway_factor(float value) {
  _internal_set_walkway_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.walkway_factor)
}

// float sidewalk_factor = 23;
inline bool Costing_Options::_internal_has_sidewalk_factor() const {
  return has_sidewalk_factor_case() == kSidewalkFactor;
}
inline bool Costing_Options::has_sidewalk_factor() const {
  return _internal_has_sidewalk_factor();
}
inline void Costing_Options::set_has_sidewalk_factor() {
  _oneof_case_[22] = kSidewalkFactor;
}
inline void Costing_Options::clear_sidewalk_factor() {
  if (_internal_has_sidewalk_factor()) {
    has_sidewalk_factor_.sidewalk_factor_ = 0;
    clear_has_has_sidewalk_factor();
  }
}
inline float Costing_Options::_internal_sidewalk_factor() const {
  if (_internal_has_sidewalk_factor()) {
    return has_sidewalk_factor_.sidewalk_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_sidewalk_factor(float value) {
  if (!_internal_has_sidewalk_factor()) {
    clear_has_sidewalk_factor();
    set_has_sidewalk_factor();
  }
  has_sidewalk_factor_.sidewalk_factor_ = value;
}
inline float Costing_Options::sidewalk_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.sidewalk_factor)
  return _internal_sidewalk_factor();
}
inline void Costing_Options::set_sidewalk_factor(float value) {
  _internal_set_sidewalk_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.sidewalk_factor)
}

// float alley_factor = 24;
inline bool Costing_Options::_internal_has_alley_factor() const {
  return has_alley_factor_case() == kAlleyFactor;
}
inline bool Costing_Options::has_alley_factor() const {
  return _internal_has_alley_factor();
}
inline void Costing_Options::set_has_alley_factor() {
  _oneof_case_[23] = kAlleyFactor;
}
inline void Costing_Options::clear_alley_factor() {
  if (_internal_has_alley_factor()) {
    has_alley_factor_.alley_factor_ = 0;
    clear_has_has_alley_factor();
  }
}
inline float Costing_Options::_internal_alley_factor() const {
  if (_internal_has_alley_factor()) {
    return has_alley_factor_.alley_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_alley_factor(float value) {
  if (!_internal_has_alley_factor()) {
    clear_has_alley_factor();
    set_has_alley_factor();
  }
  has_alley_factor_.alley_factor_ = value;
}
inline float Costing_Options::alley_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.alley_factor)
  return _internal_alley_factor();
}
inline void Costing_Options::set_alley_factor(float value) {
  _internal_set_alley_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.alley_factor)
}

// float driveway_factor = 25;
inline bool Costing_Options::_internal_has_driveway_factor() const {
  return has_driveway_factor_case() == kDrivewayFactor;
}
inline bool Costing_Options::has_driveway_factor() const {
  return _internal_has_driveway_factor();
}
inline void Costing_Options::set_has_driveway_factor() {
  _oneof_case_[24] = kDrivewayFactor;
}
inline void Costing_Options::clear_driveway_factor() {
  if (_internal_has_driveway_factor()) {
    has_driveway_factor_.driveway_factor_ = 0;
    clear_has_has_driveway_factor();
  }
}
inline float Costing_Options::_internal_driveway_factor() const {
  if (_internal_has_driveway_factor()) {
    return has_driveway_factor_.driveway_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_driveway_factor(float value) {
  if (!_internal_has_driveway_factor()) {
    clear_has_driveway_factor();
    set_has_driveway_factor();
  }
  has_driveway_factor_.driveway_factor_ = value;
}
inline float Costing_Options::driveway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.driveway_factor)
  return _internal_driveway_factor();
}
inline void Costing_Options::set_driveway_factor(float value) {
  _internal_set_driveway_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.driveway_factor)
}

// float driveway_penalty = 26;
inline bool Costing_Options::_internal_has_driveway_penalty() const {
  return has_driveway_penalty_case() == kDrivewayPenalty;
}
inline bool Costing_Options::has_driveway_penalty() const {
  return _internal_has_driveway_penalty();
}
inline void Costing_Options::set_has_driveway_penalty() {
  _oneof_case_[25] = kDrivewayPenalty;
}
inline void Costing_Options::clear_driveway_penalty() {
  if (_internal_has_driveway_penalty()) {
    has_driveway_penalty_.driveway_penalty_ = 0;
    clear_has_has_driveway_penalty();
  }
}
inline float Costing_Options::_internal_driveway_penalty() const {
  if (_internal_has_driveway_penalty()) {
    return has_driveway_penalty_.driveway_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_driveway_penalty(float value) {
  if (!_internal_has_driveway_penalty()) {
    clear_has_driveway_penalty();
    set_has_driveway_penalty();
  }
  has_driveway_penalty_.driveway_penalty_ = value;
}
inline float Costing_Options::driveway_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.driveway_penalty)
  return _internal_driveway_penalty();
}
inline void Costing_Options::set_driveway_penalty(float value) {
  _internal_set_driveway_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.driveway_penalty)
}

// uint32 transit_start_end_max_distance = 27;
inline bool Costing_Options::_internal_has_transit_start_end_max_distance() const {
  return has_transit_start_end_max_distance_case() == kTransitStartEndMaxDistance;
}
inline bool Costing_Options::has_transit_start_end_max_distance() const {
  return _internal_has_transit_start_end_max_distance();
}
inline void Costing_Options::set_has_transit_start_end_max_distance() {
  _oneof_case_[26] = kTransitStartEndMaxDistance;
}
inline void Costing_Options::clear_transit_start_end_max_distance() {
  if (_internal_has_transit_start_end_max_distance()) {
    has_transit_start_end_max_distance_.transit_start_end_max_distance_ = 0u;
    clear_has_has_transit_start_end_max_distance();
  }
}
inline uint32_t Costing_Options::_internal_transit_start_end_max_distance() const {
  if (_internal_has_transit_start_end_max_distance()) {
    return has_transit_start_end_max_distance_.transit_start_end_max_distance_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_transit_start_end_max_distance(uint32_t value) {
  if (!_internal_has_transit_start_end_max_distance()) {
    clear_has_transit_start_end_max_distance();
    set_has_transit_start_end_max_distance();
  }
  has_transit_start_end_max_distance_.transit_start_end_max_distance_ = value;
}
inline uint32_t Costing_Options::transit_start_end_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transit_start_end_max_distance)
  return _internal_transit_start_end_max_distance();
}
inline void Costing_Options::set_transit_start_end_max_distance(uint32_t value) {
  _internal_set_transit_start_end_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transit_start_end_max_distance)
}

// uint32 transit_transfer_max_distance = 28;
inline bool Costing_Options::_internal_has_transit_transfer_max_distance() const {
  return has_transit_transfer_max_distance_case() == kTransitTransferMaxDistance;
}
inline bool Costing_Options::has_transit_transfer_max_distance() const {
  return _internal_has_transit_transfer_max_distance();
}
inline void Costing_Options::set_has_transit_transfer_max_distance() {
  _oneof_case_[27] = kTransitTransferMaxDistance;
}
inline void Costing_Options::clear_transit_transfer_max_distance() {
  if (_internal_has_transit_transfer_max_distance()) {
    has_transit_transfer_max_distance_.transit_transfer_max_distance_ = 0u;
    clear_has_has_transit_transfer_max_distance();
  }
}
inline uint32_t Costing_Options::_internal_transit_transfer_max_distance() const {
  if (_internal_has_transit_transfer_max_distance()) {
    return has_transit_transfer_max_distance_.transit_transfer_max_distance_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_transit_transfer_max_distance(uint32_t value) {
  if (!_internal_has_transit_transfer_max_distance()) {
    clear_has_transit_transfer_max_distance();
    set_has_transit_transfer_max_distance();
  }
  has_transit_transfer_max_distance_.transit_transfer_max_distance_ = value;
}
inline uint32_t Costing_Options::transit_transfer_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transit_transfer_max_distance)
  return _internal_transit_transfer_max_distance();
}
inline void Costing_Options::set_transit_transfer_max_distance(uint32_t value) {
  _internal_set_transit_transfer_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transit_transfer_max_distance)
}

// string transport_type = 29;
inline bool Costing_Options::_internal_has_transport_type() const {
  return has_transport_type_case() == kTransportType;
}
inline bool Costing_Options::has_transport_type() const {
  return _internal_has_transport_type();
}
inline void Costing_Options::set_has_transport_type() {
  _oneof_case_[28] = kTransportType;
}
inline void Costing_Options::clear_transport_type() {
  if (_internal_has_transport_type()) {
    has_transport_type_.transport_type_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_transport_type();
  }
}
inline const std::string& Costing_Options::transport_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transport_type)
  return _internal_transport_type();
}
template <typename ArgT0, typename... ArgT>
inline void Costing_Options::set_transport_type(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_transport_type()) {
    clear_has_transport_type();
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_transport_type_.transport_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transport_type)
}
inline std::string* Costing_Options::mutable_transport_type() {
  std::string* _s = _internal_mutable_transport_type();
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.transport_type)
  return _s;
}
inline const std::string& Costing_Options::_internal_transport_type() const {
  if (_internal_has_transport_type()) {
    return has_transport_type_.transport_type_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Costing_Options::_internal_set_transport_type(const std::string& value) {
  if (!_internal_has_transport_type()) {
    clear_has_transport_type();
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_transport_type_.transport_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Costing_Options::_internal_mutable_transport_type() {
  if (!_internal_has_transport_type()) {
    clear_has_transport_type();
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_transport_type_.transport_type_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Costing_Options::release_transport_type() {
  // @@protoc_insertion_point(field_release:valhalla.Costing.Options.transport_type)
  if (_internal_has_transport_type()) {
    clear_has_has_transport_type();
    return has_transport_type_.transport_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Costing_Options::set_allocated_transport_type(std::string* transport_type) {
  if (has_has_transport_type()) {
    clear_has_transport_type();
  }
  if (transport_type != nullptr) {
    set_has_transport_type();
    has_transport_type_.transport_type_.UnsafeSetDefault(transport_type);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(transport_type);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Costing.Options.transport_type)
}

// float top_speed = 30;
inline bool Costing_Options::_internal_has_top_speed() const {
  return has_top_speed_case() == kTopSpeed;
}
inline bool Costing_Options::has_top_speed() const {
  return _internal_has_top_speed();
}
inline void Costing_Options::set_has_top_speed() {
  _oneof_case_[29] = kTopSpeed;
}
inline void Costing_Options::clear_top_speed() {
  if (_internal_has_top_speed()) {
    has_top_speed_.top_speed_ = 0;
    clear_has_has_top_speed();
  }
}
inline float Costing_Options::_internal_top_speed() const {
  if (_internal_has_top_speed()) {
    return has_top_speed_.top_speed_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_top_speed(float value) {
  if (!_internal_has_top_speed()) {
    clear_has_top_speed();
    set_has_top_speed();
  }
  has_top_speed_.top_speed_ = value;
}
inline float Costing_Options::top_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.top_speed)
  return _internal_top_speed();
}
inline void Costing_Options::set_top_speed(float value) {
  _internal_set_top_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.top_speed)
}

// float use_hills = 31;
inline bool Costing_Options::_internal_has_use_hills() const {
  return has_use_hills_case() == kUseHills;
}
inline bool Costing_Options::has_use_hills() const {
  return _internal_has_use_hills();
}
inline void Costing_Options::set_has_use_hills() {
  _oneof_case_[30] = kUseHills;
}
inline void Costing_Options::clear_use_hills() {
  if (_internal_has_use_hills()) {
    has_use_hills_.use_hills_ = 0;
    clear_has_has_use_hills();
  }
}
inline float Costing_Options::_internal_use_hills() const {
  if (_internal_has_use_hills()) {
    return has_use_hills_.use_hills_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_hills(float value) {
  if (!_internal_has_use_hills()) {
    clear_has_use_hills();
    set_has_use_hills();
  }
  has_use_hills_.use_hills_ = value;
}
inline float Costing_Options::use_hills() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_hills)
  return _internal_use_hills();
}
inline void Costing_Options::set_use_hills(float value) {
  _internal_set_use_hills(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_hills)
}

// float use_primary = 32;
inline bool Costing_Options::_internal_has_use_primary() const {
  return has_use_primary_case() == kUsePrimary;
}
inline bool Costing_Options::has_use_primary() const {
  return _internal_has_use_primary();
}
inline void Costing_Options::set_has_use_primary() {
  _oneof_case_[31] = kUsePrimary;
}
inline void Costing_Options::clear_use_primary() {
  if (_internal_has_use_primary()) {
    has_use_primary_.use_primary_ = 0;
    clear_has_has_use_primary();
  }
}
inline float Costing_Options::_internal_use_primary() const {
  if (_internal_has_use_primary()) {
    return has_use_primary_.use_primary_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_primary(float value) {
  if (!_internal_has_use_primary()) {
    clear_has_use_primary();
    set_has_use_primary();
  }
  has_use_primary_.use_primary_ = value;
}
inline float Costing_Options::use_primary() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_primary)
  return _internal_use_primary();
}
inline void Costing_Options::set_use_primary(float value) {
  _internal_set_use_primary(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_primary)
}

// float use_trails = 33;
inline bool Costing_Options::_internal_has_use_trails() const {
  return has_use_trails_case() == kUseTrails;
}
inline bool Costing_Options::has_use_trails() const {
  return _internal_has_use_trails();
}
inline void Costing_Options::set_has_use_trails() {
  _oneof_case_[32] = kUseTrails;
}
inline void Costing_Options::clear_use_trails() {
  if (_internal_has_use_trails()) {
    has_use_trails_.use_trails_ = 0;
    clear_has_has_use_trails();
  }
}
inline float Costing_Options::_internal_use_trails() const {
  if (_internal_has_use_trails()) {
    return has_use_trails_.use_trails_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_trails(float value) {
  if (!_internal_has_use_trails()) {
    clear_has_use_trails();
    set_has_use_trails();
  }
  has_use_trails_.use_trails_ = value;
}
inline float Costing_Options::use_trails() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_trails)
  return _internal_use_trails();
}
inline void Costing_Options::set_use_trails(float value) {
  _internal_set_use_trails(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_trails)
}

// float low_class_penalty = 34;
inline bool Costing_Options::_internal_has_low_class_penalty() const {
  return has_low_class_penalty_case() == kLowClassPenalty;
}
inline bool Costing_Options::has_low_class_penalty() const {
  return _internal_has_low_class_penalty();
}
inline void Costing_Options::set_has_low_class_penalty() {
  _oneof_case_[33] = kLowClassPenalty;
}
inline void Costing_Options::clear_low_class_penalty() {
  if (_internal_has_low_class_penalty()) {
    has_low_class_penalty_.low_class_penalty_ = 0;
    clear_has_has_low_class_penalty();
  }
}
inline float Costing_Options::_internal_low_class_penalty() const {
  if (_internal_has_low_class_penalty()) {
    return has_low_class_penalty_.low_class_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_low_class_penalty(float value) {
  if (!_internal_has_low_class_penalty()) {
    clear_has_low_class_penalty();
    set_has_low_class_penalty();
  }
  has_low_class_penalty_.low_class_penalty_ = value;
}
inline float Costing_Options::low_class_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.low_class_penalty)
  return _internal_low_class_penalty();
}
inline void Costing_Options::set_low_class_penalty(float value) {
  _internal_set_low_class_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.low_class_penalty)
}

// bool hazmat = 35;
inline bool Costing_Options::_internal_has_hazmat() const {
  return has_hazmat_case() == kHazmat;
}
inline bool Costing_Options::has_hazmat() const {
  return _internal_has_hazmat();
}
inline void Costing_Options::set_has_hazmat() {
  _oneof_case_[34] = kHazmat;
}
inline void Costing_Options::clear_hazmat() {
  if (_internal_has_hazmat()) {
    has_hazmat_.hazmat_ = false;
    clear_has_has_hazmat();
  }
}
inline bool Costing_Options::_internal_hazmat() const {
  if (_internal_has_hazmat()) {
    return has_hazmat_.hazmat_;
  }
  return false;
}
inline void Costing_Options::_internal_set_hazmat(bool value) {
  if (!_internal_has_hazmat()) {
    clear_has_hazmat();
    set_has_hazmat();
  }
  has_hazmat_.hazmat_ = value;
}
inline bool Costing_Options::hazmat() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.hazmat)
  return _internal_hazmat();
}
inline void Costing_Options::set_hazmat(bool value) {
  _internal_set_hazmat(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.hazmat)
}

// float weight = 36;
inline bool Costing_Options::_internal_has_weight() const {
  return has_weight_case() == kWeight;
}
inline bool Costing_Options::has_weight() const {
  return _internal_has_weight();
}
inline void Costing_Options::set_has_weight() {
  _oneof_case_[35] = kWeight;
}
inline void Costing_Options::clear_weight() {
  if (_internal_has_weight()) {
    has_weight_.weight_ = 0;
    clear_has_has_weight();
  }
}
inline float Costing_Options::_internal_weight() const {
  if (_internal_has_weight()) {
    return has_weight_.weight_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_weight(float value) {
  if (!_internal_has_weight()) {
    clear_has_weight();
    set_has_weight();
  }
  has_weight_.weight_ = value;
}
inline float Costing_Options::weight() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.weight)
  return _internal_weight();
}
inline void Costing_Options::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.weight)
}

// float axle_load = 37;
inline bool Costing_Options::_internal_has_axle_load() const {
  return has_axle_load_case() == kAxleLoad;
}
inline bool Costing_Options::has_axle_load() const {
  return _internal_has_axle_load();
}
inline void Costing_Options::set_has_axle_load() {
  _oneof_case_[36] = kAxleLoad;
}
inline void Costing_Options::clear_axle_load() {
  if (_internal_has_axle_load()) {
    has_axle_load_.axle_load_ = 0;
    clear_has_has_axle_load();
  }
}
inline float Costing_Options::_internal_axle_load() const {
  if (_internal_has_axle_load()) {
    return has_axle_load_.axle_load_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_axle_load(float value) {
  if (!_internal_has_axle_load()) {
    clear_has_axle_load();
    set_has_axle_load();
  }
  has_axle_load_.axle_load_ = value;
}
inline float Costing_Options::axle_load() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.axle_load)
  return _internal_axle_load();
}
inline void Costing_Options::set_axle_load(float value) {
  _internal_set_axle_load(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.axle_load)
}

// float height = 38;
inline bool Costing_Options::_internal_has_height() const {
  return has_height_case() == kHeight;
}
inline bool Costing_Options::has_height() const {
  return _internal_has_height();
}
inline void Costing_Options::set_has_height() {
  _oneof_case_[37] = kHeight;
}
inline void Costing_Options::clear_height() {
  if (_internal_has_height()) {
    has_height_.height_ = 0;
    clear_has_has_height();
  }
}
inline float Costing_Options::_internal_height() const {
  if (_internal_has_height()) {
    return has_height_.height_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_height(float value) {
  if (!_internal_has_height()) {
    clear_has_height();
    set_has_height();
  }
  has_height_.height_ = value;
}
inline float Costing_Options::height() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.height)
  return _internal_height();
}
inline void Costing_Options::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.height)
}

// float width = 39;
inline bool Costing_Options::_internal_has_width() const {
  return has_width_case() == kWidth;
}
inline bool Costing_Options::has_width() const {
  return _internal_has_width();
}
inline void Costing_Options::set_has_width() {
  _oneof_case_[38] = kWidth;
}
inline void Costing_Options::clear_width() {
  if (_internal_has_width()) {
    has_width_.width_ = 0;
    clear_has_has_width();
  }
}
inline float Costing_Options::_internal_width() const {
  if (_internal_has_width()) {
    return has_width_.width_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_width(float value) {
  if (!_internal_has_width()) {
    clear_has_width();
    set_has_width();
  }
  has_width_.width_ = value;
}
inline float Costing_Options::width() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.width)
  return _internal_width();
}
inline void Costing_Options::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.width)
}

// float length = 40;
inline bool Costing_Options::_internal_has_length() const {
  return has_length_case() == kLength;
}
inline bool Costing_Options::has_length() const {
  return _internal_has_length();
}
inline void Costing_Options::set_has_length() {
  _oneof_case_[39] = kLength;
}
inline void Costing_Options::clear_length() {
  if (_internal_has_length()) {
    has_length_.length_ = 0;
    clear_has_has_length();
  }
}
inline float Costing_Options::_internal_length() const {
  if (_internal_has_length()) {
    return has_length_.length_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_length(float value) {
  if (!_internal_has_length()) {
    clear_has_length();
    set_has_length();
  }
  has_length_.length_ = value;
}
inline float Costing_Options::length() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.length)
  return _internal_length();
}
inline void Costing_Options::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.length)
}

// float cycling_speed = 41;
inline bool Costing_Options::_internal_has_cycling_speed() const {
  return has_cycling_speed_case() == kCyclingSpeed;
}
inline bool Costing_Options::has_cycling_speed() const {
  return _internal_has_cycling_speed();
}
inline void Costing_Options::set_has_cycling_speed() {
  _oneof_case_[40] = kCyclingSpeed;
}
inline void Costing_Options::clear_cycling_speed() {
  if (_internal_has_cycling_speed()) {
    has_cycling_speed_.cycling_speed_ = 0;
    clear_has_has_cycling_speed();
  }
}
inline float Costing_Options::_internal_cycling_speed() const {
  if (_internal_has_cycling_speed()) {
    return has_cycling_speed_.cycling_speed_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_cycling_speed(float value) {
  if (!_internal_has_cycling_speed()) {
    clear_has_cycling_speed();
    set_has_cycling_speed();
  }
  has_cycling_speed_.cycling_speed_ = value;
}
inline float Costing_Options::cycling_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.cycling_speed)
  return _internal_cycling_speed();
}
inline void Costing_Options::set_cycling_speed(float value) {
  _internal_set_cycling_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.cycling_speed)
}

// bool wheelchair = 42;
inline bool Costing_Options::_internal_has_wheelchair() const {
  return has_wheelchair_case() == kWheelchair;
}
inline bool Costing_Options::has_wheelchair() const {
  return _internal_has_wheelchair();
}
inline void Costing_Options::set_has_wheelchair() {
  _oneof_case_[41] = kWheelchair;
}
inline void Costing_Options::clear_wheelchair() {
  if (_internal_has_wheelchair()) {
    has_wheelchair_.wheelchair_ = false;
    clear_has_has_wheelchair();
  }
}
inline bool Costing_Options::_internal_wheelchair() const {
  if (_internal_has_wheelchair()) {
    return has_wheelchair_.wheelchair_;
  }
  return false;
}
inline void Costing_Options::_internal_set_wheelchair(bool value) {
  if (!_internal_has_wheelchair()) {
    clear_has_wheelchair();
    set_has_wheelchair();
  }
  has_wheelchair_.wheelchair_ = value;
}
inline bool Costing_Options::wheelchair() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.wheelchair)
  return _internal_wheelchair();
}
inline void Costing_Options::set_wheelchair(bool value) {
  _internal_set_wheelchair(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.wheelchair)
}

// bool bicycle = 43;
inline bool Costing_Options::_internal_has_bicycle() const {
  return has_bicycle_case() == kBicycle;
}
inline bool Costing_Options::has_bicycle() const {
  return _internal_has_bicycle();
}
inline void Costing_Options::set_has_bicycle() {
  _oneof_case_[42] = kBicycle;
}
inline void Costing_Options::clear_bicycle() {
  if (_internal_has_bicycle()) {
    has_bicycle_.bicycle_ = false;
    clear_has_has_bicycle();
  }
}
inline bool Costing_Options::_internal_bicycle() const {
  if (_internal_has_bicycle()) {
    return has_bicycle_.bicycle_;
  }
  return false;
}
inline void Costing_Options::_internal_set_bicycle(bool value) {
  if (!_internal_has_bicycle()) {
    clear_has_bicycle();
    set_has_bicycle();
  }
  has_bicycle_.bicycle_ = value;
}
inline bool Costing_Options::bicycle() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.bicycle)
  return _internal_bicycle();
}
inline void Costing_Options::set_bicycle(bool value) {
  _internal_set_bicycle(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.bicycle)
}

// float use_bus = 44;
inline bool Costing_Options::_internal_has_use_bus() const {
  return has_use_bus_case() == kUseBus;
}
inline bool Costing_Options::has_use_bus() const {
  return _internal_has_use_bus();
}
inline void Costing_Options::set_has_use_bus() {
  _oneof_case_[43] = kUseBus;
}
inline void Costing_Options::clear_use_bus() {
  if (_internal_has_use_bus()) {
    has_use_bus_.use_bus_ = 0;
    clear_has_has_use_bus();
  }
}
inline float Costing_Options::_internal_use_bus() const {
  if (_internal_has_use_bus()) {
    return has_use_bus_.use_bus_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_bus(float value) {
  if (!_internal_has_use_bus()) {
    clear_has_use_bus();
    set_has_use_bus();
  }
  has_use_bus_.use_bus_ = value;
}
inline float Costing_Options::use_bus() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_bus)
  return _internal_use_bus();
}
inline void Costing_Options::set_use_bus(float value) {
  _internal_set_use_bus(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_bus)
}

// float use_rail = 45;
inline bool Costing_Options::_internal_has_use_rail() const {
  return has_use_rail_case() == kUseRail;
}
inline bool Costing_Options::has_use_rail() const {
  return _internal_has_use_rail();
}
inline void Costing_Options::set_has_use_rail() {
  _oneof_case_[44] = kUseRail;
}
inline void Costing_Options::clear_use_rail() {
  if (_internal_has_use_rail()) {
    has_use_rail_.use_rail_ = 0;
    clear_has_has_use_rail();
  }
}
inline float Costing_Options::_internal_use_rail() const {
  if (_internal_has_use_rail()) {
    return has_use_rail_.use_rail_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_rail(float value) {
  if (!_internal_has_use_rail()) {
    clear_has_use_rail();
    set_has_use_rail();
  }
  has_use_rail_.use_rail_ = value;
}
inline float Costing_Options::use_rail() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_rail)
  return _internal_use_rail();
}
inline void Costing_Options::set_use_rail(float value) {
  _internal_set_use_rail(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_rail)
}

// float use_transfers = 46;
inline bool Costing_Options::_internal_has_use_transfers() const {
  return has_use_transfers_case() == kUseTransfers;
}
inline bool Costing_Options::has_use_transfers() const {
  return _internal_has_use_transfers();
}
inline void Costing_Options::set_has_use_transfers() {
  _oneof_case_[45] = kUseTransfers;
}
inline void Costing_Options::clear_use_transfers() {
  if (_internal_has_use_transfers()) {
    has_use_transfers_.use_transfers_ = 0;
    clear_has_has_use_transfers();
  }
}
inline float Costing_Options::_internal_use_transfers() const {
  if (_internal_has_use_transfers()) {
    return has_use_transfers_.use_transfers_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_transfers(float value) {
  if (!_internal_has_use_transfers()) {
    clear_has_use_transfers();
    set_has_use_transfers();
  }
  has_use_transfers_.use_transfers_ = value;
}
inline float Costing_Options::use_transfers() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_transfers)
  return _internal_use_transfers();
}
inline void Costing_Options::set_use_transfers(float value) {
  _internal_set_use_transfers(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_transfers)
}

// float transfer_cost = 47;
inline bool Costing_Options::_internal_has_transfer_cost() const {
  return has_transfer_cost_case() == kTransferCost;
}
inline bool Costing_Options::has_transfer_cost() const {
  return _internal_has_transfer_cost();
}
inline void Costing_Options::set_has_transfer_cost() {
  _oneof_case_[46] = kTransferCost;
}
inline void Costing_Options::clear_transfer_cost() {
  if (_internal_has_transfer_cost()) {
    has_transfer_cost_.transfer_cost_ = 0;
    clear_has_has_transfer_cost();
  }
}
inline float Costing_Options::_internal_transfer_cost() const {
  if (_internal_has_transfer_cost()) {
    return has_transfer_cost_.transfer_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_transfer_cost(float value) {
  if (!_internal_has_transfer_cost()) {
    clear_has_transfer_cost();
    set_has_transfer_cost();
  }
  has_transfer_cost_.transfer_cost_ = value;
}
inline float Costing_Options::transfer_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transfer_cost)
  return _internal_transfer_cost();
}
inline void Costing_Options::set_transfer_cost(float value) {
  _internal_set_transfer_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transfer_cost)
}

// float transfer_penalty = 48;
inline bool Costing_Options::_internal_has_transfer_penalty() const {
  return has_transfer_penalty_case() == kTransferPenalty;
}
inline bool Costing_Options::has_transfer_penalty() const {
  return _internal_has_transfer_penalty();
}
inline void Costing_Options::set_has_transfer_penalty() {
  _oneof_case_[47] = kTransferPenalty;
}
inline void Costing_Options::clear_transfer_penalty() {
  if (_internal_has_transfer_penalty()) {
    has_transfer_penalty_.transfer_penalty_ = 0;
    clear_has_has_transfer_penalty();
  }
}
inline float Costing_Options::_internal_transfer_penalty() const {
  if (_internal_has_transfer_penalty()) {
    return has_transfer_penalty_.transfer_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_transfer_penalty(float value) {
  if (!_internal_has_transfer_penalty()) {
    clear_has_transfer_penalty();
    set_has_transfer_penalty();
  }
  has_transfer_penalty_.transfer_penalty_ = value;
}
inline float Costing_Options::transfer_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transfer_penalty)
  return _internal_transfer_penalty();
}
inline void Costing_Options::set_transfer_penalty(float value) {
  _internal_set_transfer_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transfer_penalty)
}

// .valhalla.FilterAction filter_stop_action = 49;
inline void Costing_Options::clear_filter_stop_action() {
  filter_stop_action_ = 0;
}
inline ::valhalla::FilterAction Costing_Options::_internal_filter_stop_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_stop_action_);
}
inline ::valhalla::FilterAction Costing_Options::filter_stop_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_stop_action)
  return _internal_filter_stop_action();
}
inline void Costing_Options::_internal_set_filter_stop_action(::valhalla::FilterAction value) {
  
  filter_stop_action_ = value;
}
inline void Costing_Options::set_filter_stop_action(::valhalla::FilterAction value) {
  _internal_set_filter_stop_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_stop_action)
}

// repeated string filter_stop_ids = 50;
inline int Costing_Options::_internal_filter_stop_ids_size() const {
  return filter_stop_ids_.size();
}
inline int Costing_Options::filter_stop_ids_size() const {
  return _internal_filter_stop_ids_size();
}
inline void Costing_Options::clear_filter_stop_ids() {
  filter_stop_ids_.Clear();
}
inline std::string* Costing_Options::add_filter_stop_ids() {
  std::string* _s = _internal_add_filter_stop_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Costing.Options.filter_stop_ids)
  return _s;
}
inline const std::string& Costing_Options::_internal_filter_stop_ids(int index) const {
  return filter_stop_ids_.Get(index);
}
inline const std::string& Costing_Options::filter_stop_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_stop_ids)
  return _internal_filter_stop_ids(index);
}
inline std::string* Costing_Options::mutable_filter_stop_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.filter_stop_ids)
  return filter_stop_ids_.Mutable(index);
}
inline void Costing_Options::set_filter_stop_ids(int index, const std::string& value) {
  filter_stop_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::set_filter_stop_ids(int index, std::string&& value) {
  filter_stop_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::set_filter_stop_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_stop_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::set_filter_stop_ids(int index, const char* value, size_t size) {
  filter_stop_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Costing.Options.filter_stop_ids)
}
inline std::string* Costing_Options::_internal_add_filter_stop_ids() {
  return filter_stop_ids_.Add();
}
inline void Costing_Options::add_filter_stop_ids(const std::string& value) {
  filter_stop_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(std::string&& value) {
  filter_stop_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_stop_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(const char* value, size_t size) {
  filter_stop_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Costing.Options.filter_stop_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Costing_Options::filter_stop_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.filter_stop_ids)
  return filter_stop_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Costing_Options::mutable_filter_stop_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.filter_stop_ids)
  return &filter_stop_ids_;
}

// .valhalla.FilterAction filter_operator_action = 51;
inline void Costing_Options::clear_filter_operator_action() {
  filter_operator_action_ = 0;
}
inline ::valhalla::FilterAction Costing_Options::_internal_filter_operator_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_operator_action_);
}
inline ::valhalla::FilterAction Costing_Options::filter_operator_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_operator_action)
  return _internal_filter_operator_action();
}
inline void Costing_Options::_internal_set_filter_operator_action(::valhalla::FilterAction value) {
  
  filter_operator_action_ = value;
}
inline void Costing_Options::set_filter_operator_action(::valhalla::FilterAction value) {
  _internal_set_filter_operator_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_operator_action)
}

// repeated string filter_operator_ids = 52;
inline int Costing_Options::_internal_filter_operator_ids_size() const {
  return filter_operator_ids_.size();
}
inline int Costing_Options::filter_operator_ids_size() const {
  return _internal_filter_operator_ids_size();
}
inline void Costing_Options::clear_filter_operator_ids() {
  filter_operator_ids_.Clear();
}
inline std::string* Costing_Options::add_filter_operator_ids() {
  std::string* _s = _internal_add_filter_operator_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Costing.Options.filter_operator_ids)
  return _s;
}
inline const std::string& Costing_Options::_internal_filter_operator_ids(int index) const {
  return filter_operator_ids_.Get(index);
}
inline const std::string& Costing_Options::filter_operator_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_operator_ids)
  return _internal_filter_operator_ids(index);
}
inline std::string* Costing_Options::mutable_filter_operator_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.filter_operator_ids)
  return filter_operator_ids_.Mutable(index);
}
inline void Costing_Options::set_filter_operator_ids(int index, const std::string& value) {
  filter_operator_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::set_filter_operator_ids(int index, std::string&& value) {
  filter_operator_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::set_filter_operator_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_operator_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::set_filter_operator_ids(int index, const char* value, size_t size) {
  filter_operator_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Costing.Options.filter_operator_ids)
}
inline std::string* Costing_Options::_internal_add_filter_operator_ids() {
  return filter_operator_ids_.Add();
}
inline void Costing_Options::add_filter_operator_ids(const std::string& value) {
  filter_operator_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(std::string&& value) {
  filter_operator_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_operator_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(const char* value, size_t size) {
  filter_operator_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Costing.Options.filter_operator_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Costing_Options::filter_operator_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.filter_operator_ids)
  return filter_operator_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Costing_Options::mutable_filter_operator_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.filter_operator_ids)
  return &filter_operator_ids_;
}

// .valhalla.FilterAction filter_route_action = 53;
inline void Costing_Options::clear_filter_route_action() {
  filter_route_action_ = 0;
}
inline ::valhalla::FilterAction Costing_Options::_internal_filter_route_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_route_action_);
}
inline ::valhalla::FilterAction Costing_Options::filter_route_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_route_action)
  return _internal_filter_route_action();
}
inline void Costing_Options::_internal_set_filter_route_action(::valhalla::FilterAction value) {
  
  filter_route_action_ = value;
}
inline void Costing_Options::set_filter_route_action(::valhalla::FilterAction value) {
  _internal_set_filter_route_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_route_action)
}

// repeated string filter_route_ids = 54;
inline int Costing_Options::_internal_filter_route_ids_size() const {
  return filter_route_ids_.size();
}
inline int Costing_Options::filter_route_ids_size() const {
  return _internal_filter_route_ids_size();
}
inline void Costing_Options::clear_filter_route_ids() {
  filter_route_ids_.Clear();
}
inline std::string* Costing_Options::add_filter_route_ids() {
  std::string* _s = _internal_add_filter_route_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Costing.Options.filter_route_ids)
  return _s;
}
inline const std::string& Costing_Options::_internal_filter_route_ids(int index) const {
  return filter_route_ids_.Get(index);
}
inline const std::string& Costing_Options::filter_route_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_route_ids)
  return _internal_filter_route_ids(index);
}
inline std::string* Costing_Options::mutable_filter_route_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.filter_route_ids)
  return filter_route_ids_.Mutable(index);
}
inline void Costing_Options::set_filter_route_ids(int index, const std::string& value) {
  filter_route_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::set_filter_route_ids(int index, std::string&& value) {
  filter_route_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::set_filter_route_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_route_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::set_filter_route_ids(int index, const char* value, size_t size) {
  filter_route_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Costing.Options.filter_route_ids)
}
inline std::string* Costing_Options::_internal_add_filter_route_ids() {
  return filter_route_ids_.Add();
}
inline void Costing_Options::add_filter_route_ids(const std::string& value) {
  filter_route_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(std::string&& value) {
  filter_route_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_route_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(const char* value, size_t size) {
  filter_route_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Costing.Options.filter_route_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Costing_Options::filter_route_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.filter_route_ids)
  return filter_route_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Costing_Options::mutable_filter_route_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.filter_route_ids)
  return &filter_route_ids_;
}

// uint32 flow_mask = 55;
inline bool Costing_Options::_internal_has_flow_mask() const {
  return has_flow_mask_case() == kFlowMask;
}
inline bool Costing_Options::has_flow_mask() const {
  return _internal_has_flow_mask();
}
inline void Costing_Options::set_has_flow_mask() {
  _oneof_case_[48] = kFlowMask;
}
inline void Costing_Options::clear_flow_mask() {
  if (_internal_has_flow_mask()) {
    has_flow_mask_.flow_mask_ = 0u;
    clear_has_has_flow_mask();
  }
}
inline uint32_t Costing_Options::_internal_flow_mask() const {
  if (_internal_has_flow_mask()) {
    return has_flow_mask_.flow_mask_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_flow_mask(uint32_t value) {
  if (!_internal_has_flow_mask()) {
    clear_has_flow_mask();
    set_has_flow_mask();
  }
  has_flow_mask_.flow_mask_ = value;
}
inline uint32_t Costing_Options::flow_mask() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.flow_mask)
  return _internal_flow_mask();
}
inline void Costing_Options::set_flow_mask(uint32_t value) {
  _internal_set_flow_mask(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.flow_mask)
}

// float bike_share_cost = 56;
inline bool Costing_Options::_internal_has_bike_share_cost() const {
  return has_bike_share_cost_case() == kBikeShareCost;
}
inline bool Costing_Options::has_bike_share_cost() const {
  return _internal_has_bike_share_cost();
}
inline void Costing_Options::set_has_bike_share_cost() {
  _oneof_case_[49] = kBikeShareCost;
}
inline void Costing_Options::clear_bike_share_cost() {
  if (_internal_has_bike_share_cost()) {
    has_bike_share_cost_.bike_share_cost_ = 0;
    clear_has_has_bike_share_cost();
  }
}
inline float Costing_Options::_internal_bike_share_cost() const {
  if (_internal_has_bike_share_cost()) {
    return has_bike_share_cost_.bike_share_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_bike_share_cost(float value) {
  if (!_internal_has_bike_share_cost()) {
    clear_has_bike_share_cost();
    set_has_bike_share_cost();
  }
  has_bike_share_cost_.bike_share_cost_ = value;
}
inline float Costing_Options::bike_share_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.bike_share_cost)
  return _internal_bike_share_cost();
}
inline void Costing_Options::set_bike_share_cost(float value) {
  _internal_set_bike_share_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.bike_share_cost)
}

// float bike_share_penalty = 57;
inline bool Costing_Options::_internal_has_bike_share_penalty() const {
  return has_bike_share_penalty_case() == kBikeSharePenalty;
}
inline bool Costing_Options::has_bike_share_penalty() const {
  return _internal_has_bike_share_penalty();
}
inline void Costing_Options::set_has_bike_share_penalty() {
  _oneof_case_[50] = kBikeSharePenalty;
}
inline void Costing_Options::clear_bike_share_penalty() {
  if (_internal_has_bike_share_penalty()) {
    has_bike_share_penalty_.bike_share_penalty_ = 0;
    clear_has_has_bike_share_penalty();
  }
}
inline float Costing_Options::_internal_bike_share_penalty() const {
  if (_internal_has_bike_share_penalty()) {
    return has_bike_share_penalty_.bike_share_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_bike_share_penalty(float value) {
  if (!_internal_has_bike_share_penalty()) {
    clear_has_bike_share_penalty();
    set_has_bike_share_penalty();
  }
  has_bike_share_penalty_.bike_share_penalty_ = value;
}
inline float Costing_Options::bike_share_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.bike_share_penalty)
  return _internal_bike_share_penalty();
}
inline void Costing_Options::set_bike_share_penalty(float value) {
  _internal_set_bike_share_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.bike_share_penalty)
}

// float rail_ferry_cost = 58;
inline bool Costing_Options::_internal_has_rail_ferry_cost() const {
  return has_rail_ferry_cost_case() == kRailFerryCost;
}
inline bool Costing_Options::has_rail_ferry_cost() const {
  return _internal_has_rail_ferry_cost();
}
inline void Costing_Options::set_has_rail_ferry_cost() {
  _oneof_case_[51] = kRailFerryCost;
}
inline void Costing_Options::clear_rail_ferry_cost() {
  if (_internal_has_rail_ferry_cost()) {
    has_rail_ferry_cost_.rail_ferry_cost_ = 0;
    clear_has_has_rail_ferry_cost();
  }
}
inline float Costing_Options::_internal_rail_ferry_cost() const {
  if (_internal_has_rail_ferry_cost()) {
    return has_rail_ferry_cost_.rail_ferry_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_rail_ferry_cost(float value) {
  if (!_internal_has_rail_ferry_cost()) {
    clear_has_rail_ferry_cost();
    set_has_rail_ferry_cost();
  }
  has_rail_ferry_cost_.rail_ferry_cost_ = value;
}
inline float Costing_Options::rail_ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.rail_ferry_cost)
  return _internal_rail_ferry_cost();
}
inline void Costing_Options::set_rail_ferry_cost(float value) {
  _internal_set_rail_ferry_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.rail_ferry_cost)
}

// float use_rail_ferry = 59;
inline bool Costing_Options::_internal_has_use_rail_ferry() const {
  return has_use_rail_ferry_case() == kUseRailFerry;
}
inline bool Costing_Options::has_use_rail_ferry() const {
  return _internal_has_use_rail_ferry();
}
inline void Costing_Options::set_has_use_rail_ferry() {
  _oneof_case_[52] = kUseRailFerry;
}
inline void Costing_Options::clear_use_rail_ferry() {
  if (_internal_has_use_rail_ferry()) {
    has_use_rail_ferry_.use_rail_ferry_ = 0;
    clear_has_has_use_rail_ferry();
  }
}
inline float Costing_Options::_internal_use_rail_ferry() const {
  if (_internal_has_use_rail_ferry()) {
    return has_use_rail_ferry_.use_rail_ferry_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_rail_ferry(float value) {
  if (!_internal_has_use_rail_ferry()) {
    clear_has_use_rail_ferry();
    set_has_use_rail_ferry();
  }
  has_use_rail_ferry_.use_rail_ferry_ = value;
}
inline float Costing_Options::use_rail_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_rail_ferry)
  return _internal_use_rail_ferry();
}
inline void Costing_Options::set_use_rail_ferry(float value) {
  _internal_set_use_rail_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_rail_ferry)
}

// bool ignore_restrictions = 60;
inline bool Costing_Options::_internal_has_ignore_restrictions() const {
  return has_ignore_restrictions_case() == kIgnoreRestrictions;
}
inline bool Costing_Options::has_ignore_restrictions() const {
  return _internal_has_ignore_restrictions();
}
inline void Costing_Options::set_has_ignore_restrictions() {
  _oneof_case_[53] = kIgnoreRestrictions;
}
inline void Costing_Options::clear_ignore_restrictions() {
  if (_internal_has_ignore_restrictions()) {
    has_ignore_restrictions_.ignore_restrictions_ = false;
    clear_has_has_ignore_restrictions();
  }
}
inline bool Costing_Options::_internal_ignore_restrictions() const {
  if (_internal_has_ignore_restrictions()) {
    return has_ignore_restrictions_.ignore_restrictions_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_restrictions(bool value) {
  if (!_internal_has_ignore_restrictions()) {
    clear_has_ignore_restrictions();
    set_has_ignore_restrictions();
  }
  has_ignore_restrictions_.ignore_restrictions_ = value;
}
inline bool Costing_Options::ignore_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_restrictions)
  return _internal_ignore_restrictions();
}
inline void Costing_Options::set_ignore_restrictions(bool value) {
  _internal_set_ignore_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_restrictions)
}

// bool ignore_oneways = 61;
inline bool Costing_Options::_internal_has_ignore_oneways() const {
  return has_ignore_oneways_case() == kIgnoreOneways;
}
inline bool Costing_Options::has_ignore_oneways() const {
  return _internal_has_ignore_oneways();
}
inline void Costing_Options::set_has_ignore_oneways() {
  _oneof_case_[54] = kIgnoreOneways;
}
inline void Costing_Options::clear_ignore_oneways() {
  if (_internal_has_ignore_oneways()) {
    has_ignore_oneways_.ignore_oneways_ = false;
    clear_has_has_ignore_oneways();
  }
}
inline bool Costing_Options::_internal_ignore_oneways() const {
  if (_internal_has_ignore_oneways()) {
    return has_ignore_oneways_.ignore_oneways_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_oneways(bool value) {
  if (!_internal_has_ignore_oneways()) {
    clear_has_ignore_oneways();
    set_has_ignore_oneways();
  }
  has_ignore_oneways_.ignore_oneways_ = value;
}
inline bool Costing_Options::ignore_oneways() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_oneways)
  return _internal_ignore_oneways();
}
inline void Costing_Options::set_ignore_oneways(bool value) {
  _internal_set_ignore_oneways(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_oneways)
}

// bool ignore_access = 62;
inline bool Costing_Options::_internal_has_ignore_access() const {
  return has_ignore_access_case() == kIgnoreAccess;
}
inline bool Costing_Options::has_ignore_access() const {
  return _internal_has_ignore_access();
}
inline void Costing_Options::set_has_ignore_access() {
  _oneof_case_[55] = kIgnoreAccess;
}
inline void Costing_Options::clear_ignore_access() {
  if (_internal_has_ignore_access()) {
    has_ignore_access_.ignore_access_ = false;
    clear_has_has_ignore_access();
  }
}
inline bool Costing_Options::_internal_ignore_access() const {
  if (_internal_has_ignore_access()) {
    return has_ignore_access_.ignore_access_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_access(bool value) {
  if (!_internal_has_ignore_access()) {
    clear_has_ignore_access();
    set_has_ignore_access();
  }
  has_ignore_access_.ignore_access_ = value;
}
inline bool Costing_Options::ignore_access() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_access)
  return _internal_ignore_access();
}
inline void Costing_Options::set_ignore_access(bool value) {
  _internal_set_ignore_access(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_access)
}

// bool ignore_closures = 63;
inline bool Costing_Options::_internal_has_ignore_closures() const {
  return has_ignore_closures_case() == kIgnoreClosures;
}
inline bool Costing_Options::has_ignore_closures() const {
  return _internal_has_ignore_closures();
}
inline void Costing_Options::set_has_ignore_closures() {
  _oneof_case_[56] = kIgnoreClosures;
}
inline void Costing_Options::clear_ignore_closures() {
  if (_internal_has_ignore_closures()) {
    has_ignore_closures_.ignore_closures_ = false;
    clear_has_has_ignore_closures();
  }
}
inline bool Costing_Options::_internal_ignore_closures() const {
  if (_internal_has_ignore_closures()) {
    return has_ignore_closures_.ignore_closures_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_closures(bool value) {
  if (!_internal_has_ignore_closures()) {
    clear_has_ignore_closures();
    set_has_ignore_closures();
  }
  has_ignore_closures_.ignore_closures_ = value;
}
inline bool Costing_Options::ignore_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_closures)
  return _internal_ignore_closures();
}
inline void Costing_Options::set_ignore_closures(bool value) {
  _internal_set_ignore_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_closures)
}

// bool shortest = 64;
inline bool Costing_Options::_internal_has_shortest() const {
  return has_shortest_case() == kShortest;
}
inline bool Costing_Options::has_shortest() const {
  return _internal_has_shortest();
}
inline void Costing_Options::set_has_shortest() {
  _oneof_case_[57] = kShortest;
}
inline void Costing_Options::clear_shortest() {
  if (_internal_has_shortest()) {
    has_shortest_.shortest_ = false;
    clear_has_has_shortest();
  }
}
inline bool Costing_Options::_internal_shortest() const {
  if (_internal_has_shortest()) {
    return has_shortest_.shortest_;
  }
  return false;
}
inline void Costing_Options::_internal_set_shortest(bool value) {
  if (!_internal_has_shortest()) {
    clear_has_shortest();
    set_has_shortest();
  }
  has_shortest_.shortest_ = value;
}
inline bool Costing_Options::shortest() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.shortest)
  return _internal_shortest();
}
inline void Costing_Options::set_shortest(bool value) {
  _internal_set_shortest(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.shortest)
}

// float service_penalty = 65;
inline bool Costing_Options::_internal_has_service_penalty() const {
  return has_service_penalty_case() == kServicePenalty;
}
inline bool Costing_Options::has_service_penalty() const {
  return _internal_has_service_penalty();
}
inline void Costing_Options::set_has_service_penalty() {
  _oneof_case_[58] = kServicePenalty;
}
inline void Costing_Options::clear_service_penalty() {
  if (_internal_has_service_penalty()) {
    has_service_penalty_.service_penalty_ = 0;
    clear_has_has_service_penalty();
  }
}
inline float Costing_Options::_internal_service_penalty() const {
  if (_internal_has_service_penalty()) {
    return has_service_penalty_.service_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_service_penalty(float value) {
  if (!_internal_has_service_penalty()) {
    clear_has_service_penalty();
    set_has_service_penalty();
  }
  has_service_penalty_.service_penalty_ = value;
}
inline float Costing_Options::service_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.service_penalty)
  return _internal_service_penalty();
}
inline void Costing_Options::set_service_penalty(float value) {
  _internal_set_service_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.service_penalty)
}

// float use_tracks = 66;
inline bool Costing_Options::_internal_has_use_tracks() const {
  return has_use_tracks_case() == kUseTracks;
}
inline bool Costing_Options::has_use_tracks() const {
  return _internal_has_use_tracks();
}
inline void Costing_Options::set_has_use_tracks() {
  _oneof_case_[59] = kUseTracks;
}
inline void Costing_Options::clear_use_tracks() {
  if (_internal_has_use_tracks()) {
    has_use_tracks_.use_tracks_ = 0;
    clear_has_has_use_tracks();
  }
}
inline float Costing_Options::_internal_use_tracks() const {
  if (_internal_has_use_tracks()) {
    return has_use_tracks_.use_tracks_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_tracks(float value) {
  if (!_internal_has_use_tracks()) {
    clear_has_use_tracks();
    set_has_use_tracks();
  }
  has_use_tracks_.use_tracks_ = value;
}
inline float Costing_Options::use_tracks() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_tracks)
  return _internal_use_tracks();
}
inline void Costing_Options::set_use_tracks(float value) {
  _internal_set_use_tracks(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_tracks)
}

// float use_distance = 67;
inline bool Costing_Options::_internal_has_use_distance() const {
  return has_use_distance_case() == kUseDistance;
}
inline bool Costing_Options::has_use_distance() const {
  return _internal_has_use_distance();
}
inline void Costing_Options::set_has_use_distance() {
  _oneof_case_[60] = kUseDistance;
}
inline void Costing_Options::clear_use_distance() {
  if (_internal_has_use_distance()) {
    has_use_distance_.use_distance_ = 0;
    clear_has_has_use_distance();
  }
}
inline float Costing_Options::_internal_use_distance() const {
  if (_internal_has_use_distance()) {
    return has_use_distance_.use_distance_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_distance(float value) {
  if (!_internal_has_use_distance()) {
    clear_has_use_distance();
    set_has_use_distance();
  }
  has_use_distance_.use_distance_ = value;
}
inline float Costing_Options::use_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_distance)
  return _internal_use_distance();
}
inline void Costing_Options::set_use_distance(float value) {
  _internal_set_use_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_distance)
}

// float use_living_streets = 68;
inline bool Costing_Options::_internal_has_use_living_streets() const {
  return has_use_living_streets_case() == kUseLivingStreets;
}
inline bool Costing_Options::has_use_living_streets() const {
  return _internal_has_use_living_streets();
}
inline void Costing_Options::set_has_use_living_streets() {
  _oneof_case_[61] = kUseLivingStreets;
}
inline void Costing_Options::clear_use_living_streets() {
  if (_internal_has_use_living_streets()) {
    has_use_living_streets_.use_living_streets_ = 0;
    clear_has_has_use_living_streets();
  }
}
inline float Costing_Options::_internal_use_living_streets() const {
  if (_internal_has_use_living_streets()) {
    return has_use_living_streets_.use_living_streets_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_living_streets(float value) {
  if (!_internal_has_use_living_streets()) {
    clear_has_use_living_streets();
    set_has_use_living_streets();
  }
  has_use_living_streets_.use_living_streets_ = value;
}
inline float Costing_Options::use_living_streets() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_living_streets)
  return _internal_use_living_streets();
}
inline void Costing_Options::set_use_living_streets(float value) {
  _internal_set_use_living_streets(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_living_streets)
}

// float service_factor = 69;
inline bool Costing_Options::_internal_has_service_factor() const {
  return has_service_factor_case() == kServiceFactor;
}
inline bool Costing_Options::has_service_factor() const {
  return _internal_has_service_factor();
}
inline void Costing_Options::set_has_service_factor() {
  _oneof_case_[62] = kServiceFactor;
}
inline void Costing_Options::clear_service_factor() {
  if (_internal_has_service_factor()) {
    has_service_factor_.service_factor_ = 0;
    clear_has_has_service_factor();
  }
}
inline float Costing_Options::_internal_service_factor() const {
  if (_internal_has_service_factor()) {
    return has_service_factor_.service_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_service_factor(float value) {
  if (!_internal_has_service_factor()) {
    clear_has_service_factor();
    set_has_service_factor();
  }
  has_service_factor_.service_factor_ = value;
}
inline float Costing_Options::service_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.service_factor)
  return _internal_service_factor();
}
inline void Costing_Options::set_service_factor(float value) {
  _internal_set_service_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.service_factor)
}

// float closure_factor = 70;
inline bool Costing_Options::_internal_has_closure_factor() const {
  return has_closure_factor_case() == kClosureFactor;
}
inline bool Costing_Options::has_closure_factor() const {
  return _internal_has_closure_factor();
}
inline void Costing_Options::set_has_closure_factor() {
  _oneof_case_[63] = kClosureFactor;
}
inline void Costing_Options::clear_closure_factor() {
  if (_internal_has_closure_factor()) {
    has_closure_factor_.closure_factor_ = 0;
    clear_has_has_closure_factor();
  }
}
inline float Costing_Options::_internal_closure_factor() const {
  if (_internal_has_closure_factor()) {
    return has_closure_factor_.closure_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_closure_factor(float value) {
  if (!_internal_has_closure_factor()) {
    clear_has_closure_factor();
    set_has_closure_factor();
  }
  has_closure_factor_.closure_factor_ = value;
}
inline float Costing_Options::closure_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.closure_factor)
  return _internal_closure_factor();
}
inline void Costing_Options::set_closure_factor(float value) {
  _internal_set_closure_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.closure_factor)
}

// float private_access_penalty = 71;
inline bool Costing_Options::_internal_has_private_access_penalty() const {
  return has_private_access_penalty_case() == kPrivateAccessPenalty;
}
inline bool Costing_Options::has_private_access_penalty() const {
  return _internal_has_private_access_penalty();
}
inline void Costing_Options::set_has_private_access_penalty() {
  _oneof_case_[64] = kPrivateAccessPenalty;
}
inline void Costing_Options::clear_private_access_penalty() {
  if (_internal_has_private_access_penalty()) {
    has_private_access_penalty_.private_access_penalty_ = 0;
    clear_has_has_private_access_penalty();
  }
}
inline float Costing_Options::_internal_private_access_penalty() const {
  if (_internal_has_private_access_penalty()) {
    return has_private_access_penalty_.private_access_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_private_access_penalty(float value) {
  if (!_internal_has_private_access_penalty()) {
    clear_has_private_access_penalty();
    set_has_private_access_penalty();
  }
  has_private_access_penalty_.private_access_penalty_ = value;
}
inline float Costing_Options::private_access_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.private_access_penalty)
  return _internal_private_access_penalty();
}
inline void Costing_Options::set_private_access_penalty(float value) {
  _internal_set_private_access_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.private_access_penalty)
}

// bool exclude_unpaved = 72;
inline bool Costing_Options::_internal_has_exclude_unpaved() const {
  return has_exclude_unpaved_case() == kExcludeUnpaved;
}
inline bool Costing_Options::has_exclude_unpaved() const {
  return _internal_has_exclude_unpaved();
}
inline void Costing_Options::set_has_exclude_unpaved() {
  _oneof_case_[65] = kExcludeUnpaved;
}
inline void Costing_Options::clear_exclude_unpaved() {
  if (_internal_has_exclude_unpaved()) {
    has_exclude_unpaved_.exclude_unpaved_ = false;
    clear_has_has_exclude_unpaved();
  }
}
inline bool Costing_Options::_internal_exclude_unpaved() const {
  if (_internal_has_exclude_unpaved()) {
    return has_exclude_unpaved_.exclude_unpaved_;
  }
  return false;
}
inline void Costing_Options::_internal_set_exclude_unpaved(bool value) {
  if (!_internal_has_exclude_unpaved()) {
    clear_has_exclude_unpaved();
    set_has_exclude_unpaved();
  }
  has_exclude_unpaved_.exclude_unpaved_ = value;
}
inline bool Costing_Options::exclude_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.exclude_unpaved)
  return _internal_exclude_unpaved();
}
inline void Costing_Options::set_exclude_unpaved(bool value) {
  _internal_set_exclude_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.exclude_unpaved)
}

// bool include_hot = 73;
inline bool Costing_Options::_internal_has_include_hot() const {
  return has_include_hot_case() == kIncludeHot;
}
inline bool Costing_Options::has_include_hot() const {
  return _internal_has_include_hot();
}
inline void Costing_Options::set_has_include_hot() {
  _oneof_case_[66] = kIncludeHot;
}
inline void Costing_Options::clear_include_hot() {
  if (_internal_has_include_hot()) {
    has_include_hot_.include_hot_ = false;
    clear_has_has_include_hot();
  }
}
inline bool Costing_Options::_internal_include_hot() const {
  if (_internal_has_include_hot()) {
    return has_include_hot_.include_hot_;
  }
  return false;
}
inline void Costing_Options::_internal_set_include_hot(bool value) {
  if (!_internal_has_include_hot()) {
    clear_has_include_hot();
    set_has_include_hot();
  }
  has_include_hot_.include_hot_ = value;
}
inline bool Costing_Options::include_hot() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.include_hot)
  return _internal_include_hot();
}
inline void Costing_Options::set_include_hot(bool value) {
  _internal_set_include_hot(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.include_hot)
}

// bool include_hov2 = 74;
inline bool Costing_Options::_internal_has_include_hov2() const {
  return has_include_hov2_case() == kIncludeHov2;
}
inline bool Costing_Options::has_include_hov2() const {
  return _internal_has_include_hov2();
}
inline void Costing_Options::set_has_include_hov2() {
  _oneof_case_[67] = kIncludeHov2;
}
inline void Costing_Options::clear_include_hov2() {
  if (_internal_has_include_hov2()) {
    has_include_hov2_.include_hov2_ = false;
    clear_has_has_include_hov2();
  }
}
inline bool Costing_Options::_internal_include_hov2() const {
  if (_internal_has_include_hov2()) {
    return has_include_hov2_.include_hov2_;
  }
  return false;
}
inline void Costing_Options::_internal_set_include_hov2(bool value) {
  if (!_internal_has_include_hov2()) {
    clear_has_include_hov2();
    set_has_include_hov2();
  }
  has_include_hov2_.include_hov2_ = value;
}
inline bool Costing_Options::include_hov2() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.include_hov2)
  return _internal_include_hov2();
}
inline void Costing_Options::set_include_hov2(bool value) {
  _internal_set_include_hov2(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.include_hov2)
}

// bool include_hov3 = 75;
inline bool Costing_Options::_internal_has_include_hov3() const {
  return has_include_hov3_case() == kIncludeHov3;
}
inline bool Costing_Options::has_include_hov3() const {
  return _internal_has_include_hov3();
}
inline void Costing_Options::set_has_include_hov3() {
  _oneof_case_[68] = kIncludeHov3;
}
inline void Costing_Options::clear_include_hov3() {
  if (_internal_has_include_hov3()) {
    has_include_hov3_.include_hov3_ = false;
    clear_has_has_include_hov3();
  }
}
inline bool Costing_Options::_internal_include_hov3() const {
  if (_internal_has_include_hov3()) {
    return has_include_hov3_.include_hov3_;
  }
  return false;
}
inline void Costing_Options::_internal_set_include_hov3(bool value) {
  if (!_internal_has_include_hov3()) {
    clear_has_include_hov3();
    set_has_include_hov3();
  }
  has_include_hov3_.include_hov3_ = value;
}
inline bool Costing_Options::include_hov3() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.include_hov3)
  return _internal_include_hov3();
}
inline void Costing_Options::set_include_hov3(bool value) {
  _internal_set_include_hov3(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.include_hov3)
}

// bool exclude_cash_only_tolls = 76;
inline bool Costing_Options::_internal_has_exclude_cash_only_tolls() const {
  return has_exclude_cash_only_tolls_case() == kExcludeCashOnlyTolls;
}
inline bool Costing_Options::has_exclude_cash_only_tolls() const {
  return _internal_has_exclude_cash_only_tolls();
}
inline void Costing_Options::set_has_exclude_cash_only_tolls() {
  _oneof_case_[69] = kExcludeCashOnlyTolls;
}
inline void Costing_Options::clear_exclude_cash_only_tolls() {
  if (_internal_has_exclude_cash_only_tolls()) {
    has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = false;
    clear_has_has_exclude_cash_only_tolls();
  }
}
inline bool Costing_Options::_internal_exclude_cash_only_tolls() const {
  if (_internal_has_exclude_cash_only_tolls()) {
    return has_exclude_cash_only_tolls_.exclude_cash_only_tolls_;
  }
  return false;
}
inline void Costing_Options::_internal_set_exclude_cash_only_tolls(bool value) {
  if (!_internal_has_exclude_cash_only_tolls()) {
    clear_has_exclude_cash_only_tolls();
    set_has_exclude_cash_only_tolls();
  }
  has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = value;
}
inline bool Costing_Options::exclude_cash_only_tolls() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.exclude_cash_only_tolls)
  return _internal_exclude_cash_only_tolls();
}
inline void Costing_Options::set_exclude_cash_only_tolls(bool value) {
  _internal_set_exclude_cash_only_tolls(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.exclude_cash_only_tolls)
}

// uint32 restriction_probability = 77;
inline bool Costing_Options::_internal_has_restriction_probability() const {
  return has_restriction_probability_case() == kRestrictionProbability;
}
inline bool Costing_Options::has_restriction_probability() const {
  return _internal_has_restriction_probability();
}
inline void Costing_Options::set_has_restriction_probability() {
  _oneof_case_[70] = kRestrictionProbability;
}
inline void Costing_Options::clear_restriction_probability() {
  if (_internal_has_restriction_probability()) {
    has_restriction_probability_.restriction_probability_ = 0u;
    clear_has_has_restriction_probability();
  }
}
inline uint32_t Costing_Options::_internal_restriction_probability() const {
  if (_internal_has_restriction_probability()) {
    return has_restriction_probability_.restriction_probability_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_restriction_probability(uint32_t value) {
  if (!_internal_has_restriction_probability()) {
    clear_has_restriction_probability();
    set_has_restriction_probability();
  }
  has_restriction_probability_.restriction_probability_ = value;
}
inline uint32_t Costing_Options::restriction_probability() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.restriction_probability)
  return _internal_restriction_probability();
}
inline void Costing_Options::set_restriction_probability(uint32_t value) {
  _internal_set_restriction_probability(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.restriction_probability)
}

// repeated .valhalla.AvoidEdge exclude_edges = 78;
inline int Costing_Options::_internal_exclude_edges_size() const {
  return exclude_edges_.size();
}
inline int Costing_Options::exclude_edges_size() const {
  return _internal_exclude_edges_size();
}
inline void Costing_Options::clear_exclude_edges() {
  exclude_edges_.Clear();
}
inline ::valhalla::AvoidEdge* Costing_Options::mutable_exclude_edges(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.exclude_edges)
  return exclude_edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >*
Costing_Options::mutable_exclude_edges() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.exclude_edges)
  return &exclude_edges_;
}
inline const ::valhalla::AvoidEdge& Costing_Options::_internal_exclude_edges(int index) const {
  return exclude_edges_.Get(index);
}
inline const ::valhalla::AvoidEdge& Costing_Options::exclude_edges(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.exclude_edges)
  return _internal_exclude_edges(index);
}
inline ::valhalla::AvoidEdge* Costing_Options::_internal_add_exclude_edges() {
  return exclude_edges_.Add();
}
inline ::valhalla::AvoidEdge* Costing_Options::add_exclude_edges() {
  ::valhalla::AvoidEdge* _add = _internal_add_exclude_edges();
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.exclude_edges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >&
Costing_Options::exclude_edges() const {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.exclude_edges)
  return exclude_edges_;
}

// float elevator_penalty = 79;
inline bool Costing_Options::_internal_has_elevator_penalty() const {
  return has_elevator_penalty_case() == kElevatorPenalty;
}
inline bool Costing_Options::has_elevator_penalty() const {
  return _internal_has_elevator_penalty();
}
inline void Costing_Options::set_has_elevator_penalty() {
  _oneof_case_[71] = kElevatorPenalty;
}
inline void Costing_Options::clear_elevator_penalty() {
  if (_internal_has_elevator_penalty()) {
    has_elevator_penalty_.elevator_penalty_ = 0;
    clear_has_has_elevator_penalty();
  }
}
inline float Costing_Options::_internal_elevator_penalty() const {
  if (_internal_has_elevator_penalty()) {
    return has_elevator_penalty_.elevator_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_elevator_penalty(float value) {
  if (!_internal_has_elevator_penalty()) {
    clear_has_elevator_penalty();
    set_has_elevator_penalty();
  }
  has_elevator_penalty_.elevator_penalty_ = value;
}
inline float Costing_Options::elevator_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.elevator_penalty)
  return _internal_elevator_penalty();
}
inline void Costing_Options::set_elevator_penalty(float value) {
  _internal_set_elevator_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.elevator_penalty)
}

inline bool Costing_Options::has_has_maneuver_penalty() const {
  return has_maneuver_penalty_case() != HAS_MANEUVER_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_maneuver_penalty() {
  _oneof_case_[0] = HAS_MANEUVER_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_destination_only_penalty() const {
  return has_destination_only_penalty_case() != HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_destination_only_penalty() {
  _oneof_case_[1] = HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_gate_cost() const {
  return has_gate_cost_case() != HAS_GATE_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_gate_cost() {
  _oneof_case_[2] = HAS_GATE_COST_NOT_SET;
}
inline bool Costing_Options::has_has_gate_penalty() const {
  return has_gate_penalty_case() != HAS_GATE_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_gate_penalty() {
  _oneof_case_[3] = HAS_GATE_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_toll_booth_cost() const {
  return has_toll_booth_cost_case() != HAS_TOLL_BOOTH_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_toll_booth_cost() {
  _oneof_case_[4] = HAS_TOLL_BOOTH_COST_NOT_SET;
}
inline bool Costing_Options::has_has_toll_booth_penalty() const {
  return has_toll_booth_penalty_case() != HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_toll_booth_penalty() {
  _oneof_case_[5] = HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_alley_penalty() const {
  return has_alley_penalty_case() != HAS_ALLEY_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_alley_penalty() {
  _oneof_case_[6] = HAS_ALLEY_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_country_crossing_cost() const {
  return has_country_crossing_cost_case() != HAS_COUNTRY_CROSSING_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_country_crossing_cost() {
  _oneof_case_[7] = HAS_COUNTRY_CROSSING_COST_NOT_SET;
}
inline bool Costing_Options::has_has_country_crossing_penalty() const {
  return has_country_crossing_penalty_case() != HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_country_crossing_penalty() {
  _oneof_case_[8] = HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_ferry_cost() const {
  return has_ferry_cost_case() != HAS_FERRY_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_ferry_cost() {
  _oneof_case_[9] = HAS_FERRY_COST_NOT_SET;
}
inline bool Costing_Options::has_has_avoid_bad_surfaces() const {
  return has_avoid_bad_surfaces_case() != HAS_AVOID_BAD_SURFACES_NOT_SET;
}
inline void Costing_Options::clear_has_has_avoid_bad_surfaces() {
  _oneof_case_[10] = HAS_AVOID_BAD_SURFACES_NOT_SET;
}
inline bool Costing_Options::has_has_use_ferry() const {
  return has_use_ferry_case() != HAS_USE_FERRY_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_ferry() {
  _oneof_case_[11] = HAS_USE_FERRY_NOT_SET;
}
inline bool Costing_Options::has_has_use_highways() const {
  return has_use_highways_case() != HAS_USE_HIGHWAYS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_highways() {
  _oneof_case_[12] = HAS_USE_HIGHWAYS_NOT_SET;
}
inline bool Costing_Options::has_has_use_tolls() const {
  return has_use_tolls_case() != HAS_USE_TOLLS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_tolls() {
  _oneof_case_[13] = HAS_USE_TOLLS_NOT_SET;
}
inline bool Costing_Options::has_has_use_roads() const {
  return has_use_roads_case() != HAS_USE_ROADS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_roads() {
  _oneof_case_[14] = HAS_USE_ROADS_NOT_SET;
}
inline bool Costing_Options::has_has_max_distance() const {
  return has_max_distance_case() != HAS_MAX_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_max_distance() {
  _oneof_case_[15] = HAS_MAX_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_walking_speed() const {
  return has_walking_speed_case() != HAS_WALKING_SPEED_NOT_SET;
}
inline void Costing_Options::clear_has_has_walking_speed() {
  _oneof_case_[16] = HAS_WALKING_SPEED_NOT_SET;
}
inline bool Costing_Options::has_has_step_penalty() const {
  return has_step_penalty_case() != HAS_STEP_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_step_penalty() {
  _oneof_case_[17] = HAS_STEP_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_max_grade() const {
  return has_max_grade_case() != HAS_MAX_GRADE_NOT_SET;
}
inline void Costing_Options::clear_has_has_max_grade() {
  _oneof_case_[18] = HAS_MAX_GRADE_NOT_SET;
}
inline bool Costing_Options::has_has_max_hiking_difficulty() const {
  return has_max_hiking_difficulty_case() != HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_max_hiking_difficulty() {
  _oneof_case_[19] = HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}
inline bool Costing_Options::has_has_mode_factor() const {
  return has_mode_factor_case() != HAS_MODE_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_mode_factor() {
  _oneof_case_[20] = HAS_MODE_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_walkway_factor() const {
  return has_walkway_factor_case() != HAS_WALKWAY_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_walkway_factor() {
  _oneof_case_[21] = HAS_WALKWAY_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_sidewalk_factor() const {
  return has_sidewalk_factor_case() != HAS_SIDEWALK_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_sidewalk_factor() {
  _oneof_case_[22] = HAS_SIDEWALK_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_alley_factor() const {
  return has_alley_factor_case() != HAS_ALLEY_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_alley_factor() {
  _oneof_case_[23] = HAS_ALLEY_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_driveway_factor() const {
  return has_driveway_factor_case() != HAS_DRIVEWAY_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_driveway_factor() {
  _oneof_case_[24] = HAS_DRIVEWAY_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_driveway_penalty() const {
  return has_driveway_penalty_case() != HAS_DRIVEWAY_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_driveway_penalty() {
  _oneof_case_[25] = HAS_DRIVEWAY_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_transit_start_end_max_distance() const {
  return has_transit_start_end_max_distance_case() != HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_transit_start_end_max_distance() {
  _oneof_case_[26] = HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_transit_transfer_max_distance() const {
  return has_transit_transfer_max_distance_case() != HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_transit_transfer_max_distance() {
  _oneof_case_[27] = HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_transport_type() const {
  return has_transport_type_case() != HAS_TRANSPORT_TYPE_NOT_SET;
}
inline void Costing_Options::clear_has_has_transport_type() {
  _oneof_case_[28] = HAS_TRANSPORT_TYPE_NOT_SET;
}
inline bool Costing_Options::has_has_top_speed() const {
  return has_top_speed_case() != HAS_TOP_SPEED_NOT_SET;
}
inline void Costing_Options::clear_has_has_top_speed() {
  _oneof_case_[29] = HAS_TOP_SPEED_NOT_SET;
}
inline bool Costing_Options::has_has_use_hills() const {
  return has_use_hills_case() != HAS_USE_HILLS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_hills() {
  _oneof_case_[30] = HAS_USE_HILLS_NOT_SET;
}
inline bool Costing_Options::has_has_use_primary() const {
  return has_use_primary_case() != HAS_USE_PRIMARY_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_primary() {
  _oneof_case_[31] = HAS_USE_PRIMARY_NOT_SET;
}
inline bool Costing_Options::has_has_use_trails() const {
  return has_use_trails_case() != HAS_USE_TRAILS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_trails() {
  _oneof_case_[32] = HAS_USE_TRAILS_NOT_SET;
}
inline bool Costing_Options::has_has_low_class_penalty() const {
  return has_low_class_penalty_case() != HAS_LOW_CLASS_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_low_class_penalty() {
  _oneof_case_[33] = HAS_LOW_CLASS_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_hazmat() const {
  return has_hazmat_case() != HAS_HAZMAT_NOT_SET;
}
inline void Costing_Options::clear_has_has_hazmat() {
  _oneof_case_[34] = HAS_HAZMAT_NOT_SET;
}
inline bool Costing_Options::has_has_weight() const {
  return has_weight_case() != HAS_WEIGHT_NOT_SET;
}
inline void Costing_Options::clear_has_has_weight() {
  _oneof_case_[35] = HAS_WEIGHT_NOT_SET;
}
inline bool Costing_Options::has_has_axle_load() const {
  return has_axle_load_case() != HAS_AXLE_LOAD_NOT_SET;
}
inline void Costing_Options::clear_has_has_axle_load() {
  _oneof_case_[36] = HAS_AXLE_LOAD_NOT_SET;
}
inline bool Costing_Options::has_has_height() const {
  return has_height_case() != HAS_HEIGHT_NOT_SET;
}
inline void Costing_Options::clear_has_has_height() {
  _oneof_case_[37] = HAS_HEIGHT_NOT_SET;
}
inline bool Costing_Options::has_has_width() const {
  return has_width_case() != HAS_WIDTH_NOT_SET;
}
inline void Costing_Options::clear_has_has_width() {
  _oneof_case_[38] = HAS_WIDTH_NOT_SET;
}
inline bool Costing_Options::has_has_length() const {
  return has_length_case() != HAS_LENGTH_NOT_SET;
}
inline void Costing_Options::clear_has_has_length() {
  _oneof_case_[39] = HAS_LENGTH_NOT_SET;
}
inline bool Costing_Options::has_has_cycling_speed() const {
  return has_cycling_speed_case() != HAS_CYCLING_SPEED_NOT_SET;
}
inline void Costing_Options::clear_has_has_cycling_speed() {
  _oneof_case_[40] = HAS_CYCLING_SPEED_NOT_SET;
}
inline bool Costing_Options::has_has_wheelchair() const {
  return has_wheelchair_case() != HAS_WHEELCHAIR_NOT_SET;
}
inline void Costing_Options::clear_has_has_wheelchair() {
  _oneof_case_[41] = HAS_WHEELCHAIR_NOT_SET;
}
inline bool Costing_Options::has_has_bicycle() const {
  return has_bicycle_case() != HAS_BICYCLE_NOT_SET;
}
inline void Costing_Options::clear_has_has_bicycle() {
  _oneof_case_[42] = HAS_BICYCLE_NOT_SET;
}
inline bool Costing_Options::has_has_use_bus() const {
  return has_use_bus_case() != HAS_USE_BUS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_bus() {
  _oneof_case_[43] = HAS_USE_BUS_NOT_SET;
}
inline bool Costing_Options::has_has_use_rail() const {
  return has_use_rail_case() != HAS_USE_RAIL_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_rail() {
  _oneof_case_[44] = HAS_USE_RAIL_NOT_SET;
}
inline bool Costing_Options::has_has_use_transfers() const {
  return has_use_transfers_case() != HAS_USE_TRANSFERS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_transfers() {
  _oneof_case_[45] = HAS_USE_TRANSFERS_NOT_SET;
}
inline bool Costing_Options::has_has_transfer_cost() const {
  return has_transfer_cost_case() != HAS_TRANSFER_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_transfer_cost() {
  _oneof_case_[46] = HAS_TRANSFER_COST_NOT_SET;
}
inline bool Costing_Options::has_has_transfer_penalty() const {
  return has_transfer_penalty_case() != HAS_TRANSFER_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_transfer_penalty() {
  _oneof_case_[47] = HAS_TRANSFER_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_flow_mask() const {
  return has_flow_mask_case() != HAS_FLOW_MASK_NOT_SET;
}
inline void Costing_Options::clear_has_has_flow_mask() {
  _oneof_case_[48] = HAS_FLOW_MASK_NOT_SET;
}
inline bool Costing_Options::has_has_bike_share_cost() const {
  return has_bike_share_cost_case() != HAS_BIKE_SHARE_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_bike_share_cost() {
  _oneof_case_[49] = HAS_BIKE_SHARE_COST_NOT_SET;
}
inline bool Costing_Options::has_has_bike_share_penalty() const {
  return has_bike_share_penalty_case() != HAS_BIKE_SHARE_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_bike_share_penalty() {
  _oneof_case_[50] = HAS_BIKE_SHARE_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_rail_ferry_cost() const {
  return has_rail_ferry_cost_case() != HAS_RAIL_FERRY_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_rail_ferry_cost() {
  _oneof_case_[51] = HAS_RAIL_FERRY_COST_NOT_SET;
}
inline bool Costing_Options::has_has_use_rail_ferry() const {
  return has_use_rail_ferry_case() != HAS_USE_RAIL_FERRY_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_rail_ferry() {
  _oneof_case_[52] = HAS_USE_RAIL_FERRY_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_restrictions() const {
  return has_ignore_restrictions_case() != HAS_IGNORE_RESTRICTIONS_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_restrictions() {
  _oneof_case_[53] = HAS_IGNORE_RESTRICTIONS_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_oneways() const {
  return has_ignore_oneways_case() != HAS_IGNORE_ONEWAYS_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_oneways() {
  _oneof_case_[54] = HAS_IGNORE_ONEWAYS_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_access() const {
  return has_ignore_access_case() != HAS_IGNORE_ACCESS_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_access() {
  _oneof_case_[55] = HAS_IGNORE_ACCESS_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_closures() const {
  return has_ignore_closures_case() != HAS_IGNORE_CLOSURES_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_closures() {
  _oneof_case_[56] = HAS_IGNORE_CLOSURES_NOT_SET;
}
inline bool Costing_Options::has_has_shortest() const {
  return has_shortest_case() != HAS_SHORTEST_NOT_SET;
}
inline void Costing_Options::clear_has_has_shortest() {
  _oneof_case_[57] = HAS_SHORTEST_NOT_SET;
}
inline bool Costing_Options::has_has_service_penalty() const {
  return has_service_penalty_case() != HAS_SERVICE_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_service_penalty() {
  _oneof_case_[58] = HAS_SERVICE_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_use_tracks() const {
  return has_use_tracks_case() != HAS_USE_TRACKS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_tracks() {
  _oneof_case_[59] = HAS_USE_TRACKS_NOT_SET;
}
inline bool Costing_Options::has_has_use_distance() const {
  return has_use_distance_case() != HAS_USE_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_distance() {
  _oneof_case_[60] = HAS_USE_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_use_living_streets() const {
  return has_use_living_streets_case() != HAS_USE_LIVING_STREETS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_living_streets() {
  _oneof_case_[61] = HAS_USE_LIVING_STREETS_NOT_SET;
}
inline bool Costing_Options::has_has_service_factor() const {
  return has_service_factor_case() != HAS_SERVICE_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_service_factor() {
  _oneof_case_[62] = HAS_SERVICE_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_closure_factor() const {
  return has_closure_factor_case() != HAS_CLOSURE_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_closure_factor() {
  _oneof_case_[63] = HAS_CLOSURE_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_private_access_penalty() const {
  return has_private_access_penalty_case() != HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_private_access_penalty() {
  _oneof_case_[64] = HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_exclude_unpaved() const {
  return has_exclude_unpaved_case() != HAS_EXCLUDE_UNPAVED_NOT_SET;
}
inline void Costing_Options::clear_has_has_exclude_unpaved() {
  _oneof_case_[65] = HAS_EXCLUDE_UNPAVED_NOT_SET;
}
inline bool Costing_Options::has_has_include_hot() const {
  return has_include_hot_case() != HAS_INCLUDE_HOT_NOT_SET;
}
inline void Costing_Options::clear_has_has_include_hot() {
  _oneof_case_[66] = HAS_INCLUDE_HOT_NOT_SET;
}
inline bool Costing_Options::has_has_include_hov2() const {
  return has_include_hov2_case() != HAS_INCLUDE_HOV2_NOT_SET;
}
inline void Costing_Options::clear_has_has_include_hov2() {
  _oneof_case_[67] = HAS_INCLUDE_HOV2_NOT_SET;
}
inline bool Costing_Options::has_has_include_hov3() const {
  return has_include_hov3_case() != HAS_INCLUDE_HOV3_NOT_SET;
}
inline void Costing_Options::clear_has_has_include_hov3() {
  _oneof_case_[68] = HAS_INCLUDE_HOV3_NOT_SET;
}
inline bool Costing_Options::has_has_exclude_cash_only_tolls() const {
  return has_exclude_cash_only_tolls_case() != HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}
inline void Costing_Options::clear_has_has_exclude_cash_only_tolls() {
  _oneof_case_[69] = HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}
inline bool Costing_Options::has_has_restriction_probability() const {
  return has_restriction_probability_case() != HAS_RESTRICTION_PROBABILITY_NOT_SET;
}
inline void Costing_Options::clear_has_has_restriction_probability() {
  _oneof_case_[70] = HAS_RESTRICTION_PROBABILITY_NOT_SET;
}
inline bool Costing_Options::has_has_elevator_penalty() const {
  return has_elevator_penalty_case() != HAS_ELEVATOR_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_elevator_penalty() {
  _oneof_case_[71] = HAS_ELEVATOR_PENALTY_NOT_SET;
}
inline Costing_Options::HasManeuverPenaltyCase Costing_Options::has_maneuver_penalty_case() const {
  return Costing_Options::HasManeuverPenaltyCase(_oneof_case_[0]);
}
inline Costing_Options::HasDestinationOnlyPenaltyCase Costing_Options::has_destination_only_penalty_case() const {
  return Costing_Options::HasDestinationOnlyPenaltyCase(_oneof_case_[1]);
}
inline Costing_Options::HasGateCostCase Costing_Options::has_gate_cost_case() const {
  return Costing_Options::HasGateCostCase(_oneof_case_[2]);
}
inline Costing_Options::HasGatePenaltyCase Costing_Options::has_gate_penalty_case() const {
  return Costing_Options::HasGatePenaltyCase(_oneof_case_[3]);
}
inline Costing_Options::HasTollBoothCostCase Costing_Options::has_toll_booth_cost_case() const {
  return Costing_Options::HasTollBoothCostCase(_oneof_case_[4]);
}
inline Costing_Options::HasTollBoothPenaltyCase Costing_Options::has_toll_booth_penalty_case() const {
  return Costing_Options::HasTollBoothPenaltyCase(_oneof_case_[5]);
}
inline Costing_Options::HasAlleyPenaltyCase Costing_Options::has_alley_penalty_case() const {
  return Costing_Options::HasAlleyPenaltyCase(_oneof_case_[6]);
}
inline Costing_Options::HasCountryCrossingCostCase Costing_Options::has_country_crossing_cost_case() const {
  return Costing_Options::HasCountryCrossingCostCase(_oneof_case_[7]);
}
inline Costing_Options::HasCountryCrossingPenaltyCase Costing_Options::has_country_crossing_penalty_case() const {
  return Costing_Options::HasCountryCrossingPenaltyCase(_oneof_case_[8]);
}
inline Costing_Options::HasFerryCostCase Costing_Options::has_ferry_cost_case() const {
  return Costing_Options::HasFerryCostCase(_oneof_case_[9]);
}
inline Costing_Options::HasAvoidBadSurfacesCase Costing_Options::has_avoid_bad_surfaces_case() const {
  return Costing_Options::HasAvoidBadSurfacesCase(_oneof_case_[10]);
}
inline Costing_Options::HasUseFerryCase Costing_Options::has_use_ferry_case() const {
  return Costing_Options::HasUseFerryCase(_oneof_case_[11]);
}
inline Costing_Options::HasUseHighwaysCase Costing_Options::has_use_highways_case() const {
  return Costing_Options::HasUseHighwaysCase(_oneof_case_[12]);
}
inline Costing_Options::HasUseTollsCase Costing_Options::has_use_tolls_case() const {
  return Costing_Options::HasUseTollsCase(_oneof_case_[13]);
}
inline Costing_Options::HasUseRoadsCase Costing_Options::has_use_roads_case() const {
  return Costing_Options::HasUseRoadsCase(_oneof_case_[14]);
}
inline Costing_Options::HasMaxDistanceCase Costing_Options::has_max_distance_case() const {
  return Costing_Options::HasMaxDistanceCase(_oneof_case_[15]);
}
inline Costing_Options::HasWalkingSpeedCase Costing_Options::has_walking_speed_case() const {
  return Costing_Options::HasWalkingSpeedCase(_oneof_case_[16]);
}
inline Costing_Options::HasStepPenaltyCase Costing_Options::has_step_penalty_case() const {
  return Costing_Options::HasStepPenaltyCase(_oneof_case_[17]);
}
inline Costing_Options::HasMaxGradeCase Costing_Options::has_max_grade_case() const {
  return Costing_Options::HasMaxGradeCase(_oneof_case_[18]);
}
inline Costing_Options::HasMaxHikingDifficultyCase Costing_Options::has_max_hiking_difficulty_case() const {
  return Costing_Options::HasMaxHikingDifficultyCase(_oneof_case_[19]);
}
inline Costing_Options::HasModeFactorCase Costing_Options::has_mode_factor_case() const {
  return Costing_Options::HasModeFactorCase(_oneof_case_[20]);
}
inline Costing_Options::HasWalkwayFactorCase Costing_Options::has_walkway_factor_case() const {
  return Costing_Options::HasWalkwayFactorCase(_oneof_case_[21]);
}
inline Costing_Options::HasSidewalkFactorCase Costing_Options::has_sidewalk_factor_case() const {
  return Costing_Options::HasSidewalkFactorCase(_oneof_case_[22]);
}
inline Costing_Options::HasAlleyFactorCase Costing_Options::has_alley_factor_case() const {
  return Costing_Options::HasAlleyFactorCase(_oneof_case_[23]);
}
inline Costing_Options::HasDrivewayFactorCase Costing_Options::has_driveway_factor_case() const {
  return Costing_Options::HasDrivewayFactorCase(_oneof_case_[24]);
}
inline Costing_Options::HasDrivewayPenaltyCase Costing_Options::has_driveway_penalty_case() const {
  return Costing_Options::HasDrivewayPenaltyCase(_oneof_case_[25]);
}
inline Costing_Options::HasTransitStartEndMaxDistanceCase Costing_Options::has_transit_start_end_max_distance_case() const {
  return Costing_Options::HasTransitStartEndMaxDistanceCase(_oneof_case_[26]);
}
inline Costing_Options::HasTransitTransferMaxDistanceCase Costing_Options::has_transit_transfer_max_distance_case() const {
  return Costing_Options::HasTransitTransferMaxDistanceCase(_oneof_case_[27]);
}
inline Costing_Options::HasTransportTypeCase Costing_Options::has_transport_type_case() const {
  return Costing_Options::HasTransportTypeCase(_oneof_case_[28]);
}
inline Costing_Options::HasTopSpeedCase Costing_Options::has_top_speed_case() const {
  return Costing_Options::HasTopSpeedCase(_oneof_case_[29]);
}
inline Costing_Options::HasUseHillsCase Costing_Options::has_use_hills_case() const {
  return Costing_Options::HasUseHillsCase(_oneof_case_[30]);
}
inline Costing_Options::HasUsePrimaryCase Costing_Options::has_use_primary_case() const {
  return Costing_Options::HasUsePrimaryCase(_oneof_case_[31]);
}
inline Costing_Options::HasUseTrailsCase Costing_Options::has_use_trails_case() const {
  return Costing_Options::HasUseTrailsCase(_oneof_case_[32]);
}
inline Costing_Options::HasLowClassPenaltyCase Costing_Options::has_low_class_penalty_case() const {
  return Costing_Options::HasLowClassPenaltyCase(_oneof_case_[33]);
}
inline Costing_Options::HasHazmatCase Costing_Options::has_hazmat_case() const {
  return Costing_Options::HasHazmatCase(_oneof_case_[34]);
}
inline Costing_Options::HasWeightCase Costing_Options::has_weight_case() const {
  return Costing_Options::HasWeightCase(_oneof_case_[35]);
}
inline Costing_Options::HasAxleLoadCase Costing_Options::has_axle_load_case() const {
  return Costing_Options::HasAxleLoadCase(_oneof_case_[36]);
}
inline Costing_Options::HasHeightCase Costing_Options::has_height_case() const {
  return Costing_Options::HasHeightCase(_oneof_case_[37]);
}
inline Costing_Options::HasWidthCase Costing_Options::has_width_case() const {
  return Costing_Options::HasWidthCase(_oneof_case_[38]);
}
inline Costing_Options::HasLengthCase Costing_Options::has_length_case() const {
  return Costing_Options::HasLengthCase(_oneof_case_[39]);
}
inline Costing_Options::HasCyclingSpeedCase Costing_Options::has_cycling_speed_case() const {
  return Costing_Options::HasCyclingSpeedCase(_oneof_case_[40]);
}
inline Costing_Options::HasWheelchairCase Costing_Options::has_wheelchair_case() const {
  return Costing_Options::HasWheelchairCase(_oneof_case_[41]);
}
inline Costing_Options::HasBicycleCase Costing_Options::has_bicycle_case() const {
  return Costing_Options::HasBicycleCase(_oneof_case_[42]);
}
inline Costing_Options::HasUseBusCase Costing_Options::has_use_bus_case() const {
  return Costing_Options::HasUseBusCase(_oneof_case_[43]);
}
inline Costing_Options::HasUseRailCase Costing_Options::has_use_rail_case() const {
  return Costing_Options::HasUseRailCase(_oneof_case_[44]);
}
inline Costing_Options::HasUseTransfersCase Costing_Options::has_use_transfers_case() const {
  return Costing_Options::HasUseTransfersCase(_oneof_case_[45]);
}
inline Costing_Options::HasTransferCostCase Costing_Options::has_transfer_cost_case() const {
  return Costing_Options::HasTransferCostCase(_oneof_case_[46]);
}
inline Costing_Options::HasTransferPenaltyCase Costing_Options::has_transfer_penalty_case() const {
  return Costing_Options::HasTransferPenaltyCase(_oneof_case_[47]);
}
inline Costing_Options::HasFlowMaskCase Costing_Options::has_flow_mask_case() const {
  return Costing_Options::HasFlowMaskCase(_oneof_case_[48]);
}
inline Costing_Options::HasBikeShareCostCase Costing_Options::has_bike_share_cost_case() const {
  return Costing_Options::HasBikeShareCostCase(_oneof_case_[49]);
}
inline Costing_Options::HasBikeSharePenaltyCase Costing_Options::has_bike_share_penalty_case() const {
  return Costing_Options::HasBikeSharePenaltyCase(_oneof_case_[50]);
}
inline Costing_Options::HasRailFerryCostCase Costing_Options::has_rail_ferry_cost_case() const {
  return Costing_Options::HasRailFerryCostCase(_oneof_case_[51]);
}
inline Costing_Options::HasUseRailFerryCase Costing_Options::has_use_rail_ferry_case() const {
  return Costing_Options::HasUseRailFerryCase(_oneof_case_[52]);
}
inline Costing_Options::HasIgnoreRestrictionsCase Costing_Options::has_ignore_restrictions_case() const {
  return Costing_Options::HasIgnoreRestrictionsCase(_oneof_case_[53]);
}
inline Costing_Options::HasIgnoreOnewaysCase Costing_Options::has_ignore_oneways_case() const {
  return Costing_Options::HasIgnoreOnewaysCase(_oneof_case_[54]);
}
inline Costing_Options::HasIgnoreAccessCase Costing_Options::has_ignore_access_case() const {
  return Costing_Options::HasIgnoreAccessCase(_oneof_case_[55]);
}
inline Costing_Options::HasIgnoreClosuresCase Costing_Options::has_ignore_closures_case() const {
  return Costing_Options::HasIgnoreClosuresCase(_oneof_case_[56]);
}
inline Costing_Options::HasShortestCase Costing_Options::has_shortest_case() const {
  return Costing_Options::HasShortestCase(_oneof_case_[57]);
}
inline Costing_Options::HasServicePenaltyCase Costing_Options::has_service_penalty_case() const {
  return Costing_Options::HasServicePenaltyCase(_oneof_case_[58]);
}
inline Costing_Options::HasUseTracksCase Costing_Options::has_use_tracks_case() const {
  return Costing_Options::HasUseTracksCase(_oneof_case_[59]);
}
inline Costing_Options::HasUseDistanceCase Costing_Options::has_use_distance_case() const {
  return Costing_Options::HasUseDistanceCase(_oneof_case_[60]);
}
inline Costing_Options::HasUseLivingStreetsCase Costing_Options::has_use_living_streets_case() const {
  return Costing_Options::HasUseLivingStreetsCase(_oneof_case_[61]);
}
inline Costing_Options::HasServiceFactorCase Costing_Options::has_service_factor_case() const {
  return Costing_Options::HasServiceFactorCase(_oneof_case_[62]);
}
inline Costing_Options::HasClosureFactorCase Costing_Options::has_closure_factor_case() const {
  return Costing_Options::HasClosureFactorCase(_oneof_case_[63]);
}
inline Costing_Options::HasPrivateAccessPenaltyCase Costing_Options::has_private_access_penalty_case() const {
  return Costing_Options::HasPrivateAccessPenaltyCase(_oneof_case_[64]);
}
inline Costing_Options::HasExcludeUnpavedCase Costing_Options::has_exclude_unpaved_case() const {
  return Costing_Options::HasExcludeUnpavedCase(_oneof_case_[65]);
}
inline Costing_Options::HasIncludeHotCase Costing_Options::has_include_hot_case() const {
  return Costing_Options::HasIncludeHotCase(_oneof_case_[66]);
}
inline Costing_Options::HasIncludeHov2Case Costing_Options::has_include_hov2_case() const {
  return Costing_Options::HasIncludeHov2Case(_oneof_case_[67]);
}
inline Costing_Options::HasIncludeHov3Case Costing_Options::has_include_hov3_case() const {
  return Costing_Options::HasIncludeHov3Case(_oneof_case_[68]);
}
inline Costing_Options::HasExcludeCashOnlyTollsCase Costing_Options::has_exclude_cash_only_tolls_case() const {
  return Costing_Options::HasExcludeCashOnlyTollsCase(_oneof_case_[69]);
}
inline Costing_Options::HasRestrictionProbabilityCase Costing_Options::has_restriction_probability_case() const {
  return Costing_Options::HasRestrictionProbabilityCase(_oneof_case_[70]);
}
inline Costing_Options::HasElevatorPenaltyCase Costing_Options::has_elevator_penalty_case() const {
  return Costing_Options::HasElevatorPenaltyCase(_oneof_case_[71]);
}
// -------------------------------------------------------------------

// Costing

// .valhalla.Costing.Options options = 1;
inline bool Costing::_internal_has_options() const {
  return has_options_case() == kOptions;
}
inline bool Costing::has_options() const {
  return _internal_has_options();
}
inline void Costing::set_has_options() {
  _oneof_case_[0] = kOptions;
}
inline void Costing::clear_options() {
  if (_internal_has_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete has_options_.options_;
    }
    clear_has_has_options();
  }
}
inline ::valhalla::Costing_Options* Costing::release_options() {
  // @@protoc_insertion_point(field_release:valhalla.Costing.options)
  if (_internal_has_options()) {
    clear_has_has_options();
      ::valhalla::Costing_Options* temp = has_options_.options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    has_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::valhalla::Costing_Options& Costing::_internal_options() const {
  return _internal_has_options()
      ? *has_options_.options_
      : reinterpret_cast< ::valhalla::Costing_Options&>(::valhalla::_Costing_Options_default_instance_);
}
inline const ::valhalla::Costing_Options& Costing::options() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.options)
  return _internal_options();
}
inline ::valhalla::Costing_Options* Costing::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:valhalla.Costing.options)
  if (_internal_has_options()) {
    clear_has_has_options();
    ::valhalla::Costing_Options* temp = has_options_.options_;
    has_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Costing::unsafe_arena_set_allocated_options(::valhalla::Costing_Options* options) {
  clear_has_options();
  if (options) {
    set_has_options();
    has_options_.options_ = options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Costing.options)
}
inline ::valhalla::Costing_Options* Costing::_internal_mutable_options() {
  if (!_internal_has_options()) {
    clear_has_options();
    set_has_options();
    has_options_.options_ = CreateMaybeMessage< ::valhalla::Costing_Options >(GetArenaForAllocation());
  }
  return has_options_.options_;
}
inline ::valhalla::Costing_Options* Costing::mutable_options() {
  ::valhalla::Costing_Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.options)
  return _msg;
}

// .valhalla.Costing.Type type = 2;
inline void Costing::clear_type() {
  type_ = 0;
}
inline ::valhalla::Costing_Type Costing::_internal_type() const {
  return static_cast< ::valhalla::Costing_Type >(type_);
}
inline ::valhalla::Costing_Type Costing::type() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.type)
  return _internal_type();
}
inline void Costing::_internal_set_type(::valhalla::Costing_Type value) {
  
  type_ = value;
}
inline void Costing::set_type(::valhalla::Costing_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.type)
}

// string name = 3;
inline bool Costing::_internal_has_name() const {
  return has_name_case() == kName;
}
inline bool Costing::has_name() const {
  return _internal_has_name();
}
inline void Costing::set_has_name() {
  _oneof_case_[1] = kName;
}
inline void Costing::clear_name() {
  if (_internal_has_name()) {
    has_name_.name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_name();
  }
}
inline const std::string& Costing::name() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void Costing::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_has_name();
    set_has_name();
    has_name_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_name_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Costing.name)
}
inline std::string* Costing::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.name)
  return _s;
}
inline const std::string& Costing::_internal_name() const {
  if (_internal_has_name()) {
    return has_name_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Costing::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_has_name();
    set_has_name();
    has_name_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_name_.name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Costing::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_has_name();
    set_has_name();
    has_name_.name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_name_.name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Costing::release_name() {
  // @@protoc_insertion_point(field_release:valhalla.Costing.name)
  if (_internal_has_name()) {
    clear_has_has_name();
    return has_name_.name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Costing::set_allocated_name(std::string* name) {
  if (has_has_name()) {
    clear_has_name();
  }
  if (name != nullptr) {
    set_has_name();
    has_name_.name_.UnsafeSetDefault(name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Costing.name)
}

// bool filter_closures = 4;
inline bool Costing::_internal_has_filter_closures() const {
  return has_filter_closures_case() == kFilterClosures;
}
inline bool Costing::has_filter_closures() const {
  return _internal_has_filter_closures();
}
inline void Costing::set_has_filter_closures() {
  _oneof_case_[2] = kFilterClosures;
}
inline void Costing::clear_filter_closures() {
  if (_internal_has_filter_closures()) {
    has_filter_closures_.filter_closures_ = false;
    clear_has_has_filter_closures();
  }
}
inline bool Costing::_internal_filter_closures() const {
  if (_internal_has_filter_closures()) {
    return has_filter_closures_.filter_closures_;
  }
  return false;
}
inline void Costing::_internal_set_filter_closures(bool value) {
  if (!_internal_has_filter_closures()) {
    clear_has_filter_closures();
    set_has_filter_closures();
  }
  has_filter_closures_.filter_closures_ = value;
}
inline bool Costing::filter_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.filter_closures)
  return _internal_filter_closures();
}
inline void Costing::set_filter_closures(bool value) {
  _internal_set_filter_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.filter_closures)
}

inline bool Costing::has_has_options() const {
  return has_options_case() != HAS_OPTIONS_NOT_SET;
}
inline void Costing::clear_has_has_options() {
  _oneof_case_[0] = HAS_OPTIONS_NOT_SET;
}
inline bool Costing::has_has_name() const {
  return has_name_case() != HAS_NAME_NOT_SET;
}
inline void Costing::clear_has_has_name() {
  _oneof_case_[1] = HAS_NAME_NOT_SET;
}
inline bool Costing::has_has_filter_closures() const {
  return has_filter_closures_case() != HAS_FILTER_CLOSURES_NOT_SET;
}
inline void Costing::clear_has_has_filter_closures() {
  _oneof_case_[2] = HAS_FILTER_CLOSURES_NOT_SET;
}
inline Costing::HasOptionsCase Costing::has_options_case() const {
  return Costing::HasOptionsCase(_oneof_case_[0]);
}
inline Costing::HasNameCase Costing::has_name_case() const {
  return Costing::HasNameCase(_oneof_case_[1]);
}
inline Costing::HasFilterClosuresCase Costing::has_filter_closures_case() const {
  return Costing::HasFilterClosuresCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Options

// .valhalla.Options.Units units = 1;
inline void Options::clear_units() {
  units_ = 0;
}
inline ::valhalla::Options_Units Options::_internal_units() const {
  return static_cast< ::valhalla::Options_Units >(units_);
}
inline ::valhalla::Options_Units Options::units() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.units)
  return _internal_units();
}
inline void Options::_internal_set_units(::valhalla::Options_Units value) {
  
  units_ = value;
}
inline void Options::set_units(::valhalla::Options_Units value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.units)
}

// string language = 2;
inline bool Options::_internal_has_language() const {
  return has_language_case() == kLanguage;
}
inline bool Options::has_language() const {
  return _internal_has_language();
}
inline void Options::set_has_language() {
  _oneof_case_[0] = kLanguage;
}
inline void Options::clear_language() {
  if (_internal_has_language()) {
    has_language_.language_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_language();
  }
}
inline const std::string& Options::language() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline void Options::set_language(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_language()) {
    clear_has_language();
    set_has_language();
    has_language_.language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_language_.language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.language)
}
inline std::string* Options::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.language)
  return _s;
}
inline const std::string& Options::_internal_language() const {
  if (_internal_has_language()) {
    return has_language_.language_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Options::_internal_set_language(const std::string& value) {
  if (!_internal_has_language()) {
    clear_has_language();
    set_has_language();
    has_language_.language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_language_.language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_language() {
  if (!_internal_has_language()) {
    clear_has_language();
    set_has_language();
    has_language_.language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_language_.language_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_language() {
  // @@protoc_insertion_point(field_release:valhalla.Options.language)
  if (_internal_has_language()) {
    clear_has_has_language();
    return has_language_.language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Options::set_allocated_language(std::string* language) {
  if (has_has_language()) {
    clear_has_language();
  }
  if (language != nullptr) {
    set_has_language();
    has_language_.language_.UnsafeSetDefault(language);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(language);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.language)
}

// .valhalla.DirectionsType directions_type = 3;
inline void Options::clear_directions_type() {
  directions_type_ = 0;
}
inline ::valhalla::DirectionsType Options::_internal_directions_type() const {
  return static_cast< ::valhalla::DirectionsType >(directions_type_);
}
inline ::valhalla::DirectionsType Options::directions_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.directions_type)
  return _internal_directions_type();
}
inline void Options::_internal_set_directions_type(::valhalla::DirectionsType value) {
  
  directions_type_ = value;
}
inline void Options::set_directions_type(::valhalla::DirectionsType value) {
  _internal_set_directions_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.directions_type)
}

// .valhalla.Options.Format format = 4;
inline void Options::clear_format() {
  format_ = 0;
}
inline ::valhalla::Options_Format Options::_internal_format() const {
  return static_cast< ::valhalla::Options_Format >(format_);
}
inline ::valhalla::Options_Format Options::format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.format)
  return _internal_format();
}
inline void Options::_internal_set_format(::valhalla::Options_Format value) {
  
  format_ = value;
}
inline void Options::set_format(::valhalla::Options_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.format)
}

// string id = 5;
inline bool Options::_internal_has_id() const {
  return has_id_case() == kId;
}
inline bool Options::has_id() const {
  return _internal_has_id();
}
inline void Options::set_has_id() {
  _oneof_case_[1] = kId;
}
inline void Options::clear_id() {
  if (_internal_has_id()) {
    has_id_.id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_id();
  }
}
inline const std::string& Options::id() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline void Options::set_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_id()) {
    clear_has_id();
    set_has_id();
    has_id_.id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_id_.id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.id)
}
inline std::string* Options::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.id)
  return _s;
}
inline const std::string& Options::_internal_id() const {
  if (_internal_has_id()) {
    return has_id_.id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Options::_internal_set_id(const std::string& value) {
  if (!_internal_has_id()) {
    clear_has_id();
    set_has_id();
    has_id_.id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_id_.id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_id() {
  if (!_internal_has_id()) {
    clear_has_id();
    set_has_id();
    has_id_.id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_id_.id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_id() {
  // @@protoc_insertion_point(field_release:valhalla.Options.id)
  if (_internal_has_id()) {
    clear_has_has_id();
    return has_id_.id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Options::set_allocated_id(std::string* id) {
  if (has_has_id()) {
    clear_has_id();
  }
  if (id != nullptr) {
    set_has_id();
    has_id_.id_.UnsafeSetDefault(id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.id)
}

// string jsonp = 6;
inline bool Options::_internal_has_jsonp() const {
  return has_jsonp_case() == kJsonp;
}
inline bool Options::has_jsonp() const {
  return _internal_has_jsonp();
}
inline void Options::set_has_jsonp() {
  _oneof_case_[2] = kJsonp;
}
inline void Options::clear_jsonp() {
  if (_internal_has_jsonp()) {
    has_jsonp_.jsonp_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_jsonp();
  }
}
inline const std::string& Options::jsonp() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.jsonp)
  return _internal_jsonp();
}
template <typename ArgT0, typename... ArgT>
inline void Options::set_jsonp(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_jsonp()) {
    clear_has_jsonp();
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_jsonp_.jsonp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.jsonp)
}
inline std::string* Options::mutable_jsonp() {
  std::string* _s = _internal_mutable_jsonp();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.jsonp)
  return _s;
}
inline const std::string& Options::_internal_jsonp() const {
  if (_internal_has_jsonp()) {
    return has_jsonp_.jsonp_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Options::_internal_set_jsonp(const std::string& value) {
  if (!_internal_has_jsonp()) {
    clear_has_jsonp();
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_jsonp_.jsonp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_jsonp() {
  if (!_internal_has_jsonp()) {
    clear_has_jsonp();
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_jsonp_.jsonp_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_jsonp() {
  // @@protoc_insertion_point(field_release:valhalla.Options.jsonp)
  if (_internal_has_jsonp()) {
    clear_has_has_jsonp();
    return has_jsonp_.jsonp_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Options::set_allocated_jsonp(std::string* jsonp) {
  if (has_has_jsonp()) {
    clear_has_jsonp();
  }
  if (jsonp != nullptr) {
    set_has_jsonp();
    has_jsonp_.jsonp_.UnsafeSetDefault(jsonp);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(jsonp);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.jsonp)
}

// string encoded_polyline = 7;
inline bool Options::_internal_has_encoded_polyline() const {
  return has_encoded_polyline_case() == kEncodedPolyline;
}
inline bool Options::has_encoded_polyline() const {
  return _internal_has_encoded_polyline();
}
inline void Options::set_has_encoded_polyline() {
  _oneof_case_[3] = kEncodedPolyline;
}
inline void Options::clear_encoded_polyline() {
  if (_internal_has_encoded_polyline()) {
    has_encoded_polyline_.encoded_polyline_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_encoded_polyline();
  }
}
inline const std::string& Options::encoded_polyline() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.encoded_polyline)
  return _internal_encoded_polyline();
}
template <typename ArgT0, typename... ArgT>
inline void Options::set_encoded_polyline(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_encoded_polyline()) {
    clear_has_encoded_polyline();
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_encoded_polyline_.encoded_polyline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.encoded_polyline)
}
inline std::string* Options::mutable_encoded_polyline() {
  std::string* _s = _internal_mutable_encoded_polyline();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.encoded_polyline)
  return _s;
}
inline const std::string& Options::_internal_encoded_polyline() const {
  if (_internal_has_encoded_polyline()) {
    return has_encoded_polyline_.encoded_polyline_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Options::_internal_set_encoded_polyline(const std::string& value) {
  if (!_internal_has_encoded_polyline()) {
    clear_has_encoded_polyline();
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_encoded_polyline_.encoded_polyline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_encoded_polyline() {
  if (!_internal_has_encoded_polyline()) {
    clear_has_encoded_polyline();
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_encoded_polyline_.encoded_polyline_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_encoded_polyline() {
  // @@protoc_insertion_point(field_release:valhalla.Options.encoded_polyline)
  if (_internal_has_encoded_polyline()) {
    clear_has_has_encoded_polyline();
    return has_encoded_polyline_.encoded_polyline_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Options::set_allocated_encoded_polyline(std::string* encoded_polyline) {
  if (has_has_encoded_polyline()) {
    clear_has_encoded_polyline();
  }
  if (encoded_polyline != nullptr) {
    set_has_encoded_polyline();
    has_encoded_polyline_.encoded_polyline_.UnsafeSetDefault(encoded_polyline);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(encoded_polyline);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.encoded_polyline)
}

// .valhalla.Options.Action action = 8;
inline void Options::clear_action() {
  action_ = 0;
}
inline ::valhalla::Options_Action Options::_internal_action() const {
  return static_cast< ::valhalla::Options_Action >(action_);
}
inline ::valhalla::Options_Action Options::action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.action)
  return _internal_action();
}
inline void Options::_internal_set_action(::valhalla::Options_Action value) {
  
  action_ = value;
}
inline void Options::set_action(::valhalla::Options_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.action)
}

// bool range = 10;
inline bool Options::_internal_has_range() const {
  return has_range_case() == kRange;
}
inline bool Options::has_range() const {
  return _internal_has_range();
}
inline void Options::set_has_range() {
  _oneof_case_[4] = kRange;
}
inline void Options::clear_range() {
  if (_internal_has_range()) {
    has_range_.range_ = false;
    clear_has_has_range();
  }
}
inline bool Options::_internal_range() const {
  if (_internal_has_range()) {
    return has_range_.range_;
  }
  return false;
}
inline void Options::_internal_set_range(bool value) {
  if (!_internal_has_range()) {
    clear_has_range();
    set_has_range();
  }
  has_range_.range_ = value;
}
inline bool Options::range() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.range)
  return _internal_range();
}
inline void Options::set_range(bool value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.range)
}

// bool verbose = 11;
inline bool Options::_internal_has_verbose() const {
  return has_verbose_case() == kVerbose;
}
inline bool Options::has_verbose() const {
  return _internal_has_verbose();
}
inline void Options::set_has_verbose() {
  _oneof_case_[5] = kVerbose;
}
inline void Options::clear_verbose() {
  if (_internal_has_verbose()) {
    has_verbose_.verbose_ = false;
    clear_has_has_verbose();
  }
}
inline bool Options::_internal_verbose() const {
  if (_internal_has_verbose()) {
    return has_verbose_.verbose_;
  }
  return false;
}
inline void Options::_internal_set_verbose(bool value) {
  if (!_internal_has_verbose()) {
    clear_has_verbose();
    set_has_verbose();
  }
  has_verbose_.verbose_ = value;
}
inline bool Options::verbose() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.verbose)
  return _internal_verbose();
}
inline void Options::set_verbose(bool value) {
  _internal_set_verbose(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.verbose)
}

// .valhalla.Costing.Type costing_type = 12;
inline void Options::clear_costing_type() {
  costing_type_ = 0;
}
inline ::valhalla::Costing_Type Options::_internal_costing_type() const {
  return static_cast< ::valhalla::Costing_Type >(costing_type_);
}
inline ::valhalla::Costing_Type Options::costing_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.costing_type)
  return _internal_costing_type();
}
inline void Options::_internal_set_costing_type(::valhalla::Costing_Type value) {
  
  costing_type_ = value;
}
inline void Options::set_costing_type(::valhalla::Costing_Type value) {
  _internal_set_costing_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.costing_type)
}

// map<int32, .valhalla.Costing> costings = 13;
inline int Options::_internal_costings_size() const {
  return costings_.size();
}
inline int Options::costings_size() const {
  return _internal_costings_size();
}
inline void Options::clear_costings() {
  costings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >&
Options::_internal_costings() const {
  return costings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >&
Options::costings() const {
  // @@protoc_insertion_point(field_map:valhalla.Options.costings)
  return _internal_costings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >*
Options::_internal_mutable_costings() {
  return costings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::valhalla::Costing >*
Options::mutable_costings() {
  // @@protoc_insertion_point(field_mutable_map:valhalla.Options.costings)
  return _internal_mutable_costings();
}

// repeated .valhalla.Location locations = 14;
inline int Options::_internal_locations_size() const {
  return locations_.size();
}
inline int Options::locations_size() const {
  return _internal_locations_size();
}
inline ::valhalla::Location* Options::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.locations)
  return locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.locations)
  return &locations_;
}
inline const ::valhalla::Location& Options::_internal_locations(int index) const {
  return locations_.Get(index);
}
inline const ::valhalla::Location& Options::locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.locations)
  return _internal_locations(index);
}
inline ::valhalla::Location* Options::_internal_add_locations() {
  return locations_.Add();
}
inline ::valhalla::Location* Options::add_locations() {
  ::valhalla::Location* _add = _internal_add_locations();
  // @@protoc_insertion_point(field_add:valhalla.Options.locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::locations() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.locations)
  return locations_;
}

// repeated .valhalla.Location exclude_locations = 15;
inline int Options::_internal_exclude_locations_size() const {
  return exclude_locations_.size();
}
inline int Options::exclude_locations_size() const {
  return _internal_exclude_locations_size();
}
inline ::valhalla::Location* Options::mutable_exclude_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.exclude_locations)
  return exclude_locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_exclude_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.exclude_locations)
  return &exclude_locations_;
}
inline const ::valhalla::Location& Options::_internal_exclude_locations(int index) const {
  return exclude_locations_.Get(index);
}
inline const ::valhalla::Location& Options::exclude_locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.exclude_locations)
  return _internal_exclude_locations(index);
}
inline ::valhalla::Location* Options::_internal_add_exclude_locations() {
  return exclude_locations_.Add();
}
inline ::valhalla::Location* Options::add_exclude_locations() {
  ::valhalla::Location* _add = _internal_add_exclude_locations();
  // @@protoc_insertion_point(field_add:valhalla.Options.exclude_locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::exclude_locations() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.exclude_locations)
  return exclude_locations_;
}

// repeated .valhalla.Location sources = 16;
inline int Options::_internal_sources_size() const {
  return sources_.size();
}
inline int Options::sources_size() const {
  return _internal_sources_size();
}
inline ::valhalla::Location* Options::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.sources)
  return sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.sources)
  return &sources_;
}
inline const ::valhalla::Location& Options::_internal_sources(int index) const {
  return sources_.Get(index);
}
inline const ::valhalla::Location& Options::sources(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.sources)
  return _internal_sources(index);
}
inline ::valhalla::Location* Options::_internal_add_sources() {
  return sources_.Add();
}
inline ::valhalla::Location* Options::add_sources() {
  ::valhalla::Location* _add = _internal_add_sources();
  // @@protoc_insertion_point(field_add:valhalla.Options.sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::sources() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.sources)
  return sources_;
}

// repeated .valhalla.Location targets = 17;
inline int Options::_internal_targets_size() const {
  return targets_.size();
}
inline int Options::targets_size() const {
  return _internal_targets_size();
}
inline ::valhalla::Location* Options::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.targets)
  return &targets_;
}
inline const ::valhalla::Location& Options::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::valhalla::Location& Options::targets(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.targets)
  return _internal_targets(index);
}
inline ::valhalla::Location* Options::_internal_add_targets() {
  return targets_.Add();
}
inline ::valhalla::Location* Options::add_targets() {
  ::valhalla::Location* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:valhalla.Options.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::targets() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.targets)
  return targets_;
}

// .valhalla.Options.DateTimeType date_time_type = 18;
inline void Options::clear_date_time_type() {
  date_time_type_ = 0;
}
inline ::valhalla::Options_DateTimeType Options::_internal_date_time_type() const {
  return static_cast< ::valhalla::Options_DateTimeType >(date_time_type_);
}
inline ::valhalla::Options_DateTimeType Options::date_time_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time_type)
  return _internal_date_time_type();
}
inline void Options::_internal_set_date_time_type(::valhalla::Options_DateTimeType value) {
  
  date_time_type_ = value;
}
inline void Options::set_date_time_type(::valhalla::Options_DateTimeType value) {
  _internal_set_date_time_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time_type)
}

// string date_time = 19;
inline bool Options::_internal_has_date_time() const {
  return has_date_time_case() == kDateTime;
}
inline bool Options::has_date_time() const {
  return _internal_has_date_time();
}
inline void Options::set_has_date_time() {
  _oneof_case_[6] = kDateTime;
}
inline void Options::clear_date_time() {
  if (_internal_has_date_time()) {
    has_date_time_.date_time_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_has_date_time();
  }
}
inline const std::string& Options::date_time() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time)
  return _internal_date_time();
}
template <typename ArgT0, typename... ArgT>
inline void Options::set_date_time(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_date_time()) {
    clear_has_date_time();
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_date_time_.date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time)
}
inline std::string* Options::mutable_date_time() {
  std::string* _s = _internal_mutable_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.date_time)
  return _s;
}
inline const std::string& Options::_internal_date_time() const {
  if (_internal_has_date_time()) {
    return has_date_time_.date_time_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Options::_internal_set_date_time(const std::string& value) {
  if (!_internal_has_date_time()) {
    clear_has_date_time();
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  has_date_time_.date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_date_time() {
  if (!_internal_has_date_time()) {
    clear_has_date_time();
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return has_date_time_.date_time_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_date_time() {
  // @@protoc_insertion_point(field_release:valhalla.Options.date_time)
  if (_internal_has_date_time()) {
    clear_has_has_date_time();
    return has_date_time_.date_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Options::set_allocated_date_time(std::string* date_time) {
  if (has_has_date_time()) {
    clear_has_date_time();
  }
  if (date_time != nullptr) {
    set_has_date_time();
    has_date_time_.date_time_.UnsafeSetDefault(date_time);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(date_time);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.date_time)
}

// repeated .valhalla.Location shape = 20;
inline int Options::_internal_shape_size() const {
  return shape_.size();
}
inline int Options::shape_size() const {
  return _internal_shape_size();
}
inline ::valhalla::Location* Options::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.shape)
  return shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.shape)
  return &shape_;
}
inline const ::valhalla::Location& Options::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline const ::valhalla::Location& Options::shape(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape)
  return _internal_shape(index);
}
inline ::valhalla::Location* Options::_internal_add_shape() {
  return shape_.Add();
}
inline ::valhalla::Location* Options::add_shape() {
  ::valhalla::Location* _add = _internal_add_shape();
  // @@protoc_insertion_point(field_add:valhalla.Options.shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::shape() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.shape)
  return shape_;
}

// double resample_distance = 21;
inline bool Options::_internal_has_resample_distance() const {
  return has_resample_distance_case() == kResampleDistance;
}
inline bool Options::has_resample_distance() const {
  return _internal_has_resample_distance();
}
inline void Options::set_has_resample_distance() {
  _oneof_case_[7] = kResampleDistance;
}
inline void Options::clear_resample_distance() {
  if (_internal_has_resample_distance()) {
    has_resample_distance_.resample_distance_ = 0;
    clear_has_has_resample_distance();
  }
}
inline double Options::_internal_resample_distance() const {
  if (_internal_has_resample_distance()) {
    return has_resample_distance_.resample_distance_;
  }
  return 0;
}
inline void Options::_internal_set_resample_distance(double value) {
  if (!_internal_has_resample_distance()) {
    clear_has_resample_distance();
    set_has_resample_distance();
  }
  has_resample_distance_.resample_distance_ = value;
}
inline double Options::resample_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.resample_distance)
  return _internal_resample_distance();
}
inline void Options::set_resample_distance(double value) {
  _internal_set_resample_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.resample_distance)
}

// repeated .valhalla.Contour contours = 22;
inline int Options::_internal_contours_size() const {
  return contours_.size();
}
inline int Options::contours_size() const {
  return _internal_contours_size();
}
inline void Options::clear_contours() {
  contours_.Clear();
}
inline ::valhalla::Contour* Options::mutable_contours(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.contours)
  return contours_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >*
Options::mutable_contours() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.contours)
  return &contours_;
}
inline const ::valhalla::Contour& Options::_internal_contours(int index) const {
  return contours_.Get(index);
}
inline const ::valhalla::Contour& Options::contours(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.contours)
  return _internal_contours(index);
}
inline ::valhalla::Contour* Options::_internal_add_contours() {
  return contours_.Add();
}
inline ::valhalla::Contour* Options::add_contours() {
  ::valhalla::Contour* _add = _internal_add_contours();
  // @@protoc_insertion_point(field_add:valhalla.Options.contours)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >&
Options::contours() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.contours)
  return contours_;
}

// bool polygons = 23;
inline bool Options::_internal_has_polygons() const {
  return has_polygons_case() == kPolygons;
}
inline bool Options::has_polygons() const {
  return _internal_has_polygons();
}
inline void Options::set_has_polygons() {
  _oneof_case_[8] = kPolygons;
}
inline void Options::clear_polygons() {
  if (_internal_has_polygons()) {
    has_polygons_.polygons_ = false;
    clear_has_has_polygons();
  }
}
inline bool Options::_internal_polygons() const {
  if (_internal_has_polygons()) {
    return has_polygons_.polygons_;
  }
  return false;
}
inline void Options::_internal_set_polygons(bool value) {
  if (!_internal_has_polygons()) {
    clear_has_polygons();
    set_has_polygons();
  }
  has_polygons_.polygons_ = value;
}
inline bool Options::polygons() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.polygons)
  return _internal_polygons();
}
inline void Options::set_polygons(bool value) {
  _internal_set_polygons(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.polygons)
}

// float denoise = 24;
inline bool Options::_internal_has_denoise() const {
  return has_denoise_case() == kDenoise;
}
inline bool Options::has_denoise() const {
  return _internal_has_denoise();
}
inline void Options::set_has_denoise() {
  _oneof_case_[9] = kDenoise;
}
inline void Options::clear_denoise() {
  if (_internal_has_denoise()) {
    has_denoise_.denoise_ = 0;
    clear_has_has_denoise();
  }
}
inline float Options::_internal_denoise() const {
  if (_internal_has_denoise()) {
    return has_denoise_.denoise_;
  }
  return 0;
}
inline void Options::_internal_set_denoise(float value) {
  if (!_internal_has_denoise()) {
    clear_has_denoise();
    set_has_denoise();
  }
  has_denoise_.denoise_ = value;
}
inline float Options::denoise() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.denoise)
  return _internal_denoise();
}
inline void Options::set_denoise(float value) {
  _internal_set_denoise(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.denoise)
}

// float generalize = 25;
inline bool Options::_internal_has_generalize() const {
  return has_generalize_case() == kGeneralize;
}
inline bool Options::has_generalize() const {
  return _internal_has_generalize();
}
inline void Options::set_has_generalize() {
  _oneof_case_[10] = kGeneralize;
}
inline void Options::clear_generalize() {
  if (_internal_has_generalize()) {
    has_generalize_.generalize_ = 0;
    clear_has_has_generalize();
  }
}
inline float Options::_internal_generalize() const {
  if (_internal_has_generalize()) {
    return has_generalize_.generalize_;
  }
  return 0;
}
inline void Options::_internal_set_generalize(float value) {
  if (!_internal_has_generalize()) {
    clear_has_generalize();
    set_has_generalize();
  }
  has_generalize_.generalize_ = value;
}
inline float Options::generalize() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.generalize)
  return _internal_generalize();
}
inline void Options::set_generalize(float value) {
  _internal_set_generalize(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.generalize)
}

// bool show_locations = 26;
inline bool Options::_internal_has_show_locations() const {
  return has_show_locations_case() == kShowLocations;
}
inline bool Options::has_show_locations() const {
  return _internal_has_show_locations();
}
inline void Options::set_has_show_locations() {
  _oneof_case_[11] = kShowLocations;
}
inline void Options::clear_show_locations() {
  if (_internal_has_show_locations()) {
    has_show_locations_.show_locations_ = false;
    clear_has_has_show_locations();
  }
}
inline bool Options::_internal_show_locations() const {
  if (_internal_has_show_locations()) {
    return has_show_locations_.show_locations_;
  }
  return false;
}
inline void Options::_internal_set_show_locations(bool value) {
  if (!_internal_has_show_locations()) {
    clear_has_show_locations();
    set_has_show_locations();
  }
  has_show_locations_.show_locations_ = value;
}
inline bool Options::show_locations() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.show_locations)
  return _internal_show_locations();
}
inline void Options::set_show_locations(bool value) {
  _internal_set_show_locations(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.show_locations)
}

// repeated .valhalla.Location trace = 27;
inline int Options::_internal_trace_size() const {
  return trace_.size();
}
inline int Options::trace_size() const {
  return _internal_trace_size();
}
inline ::valhalla::Location* Options::mutable_trace(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.trace)
  return trace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_trace() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.trace)
  return &trace_;
}
inline const ::valhalla::Location& Options::_internal_trace(int index) const {
  return trace_.Get(index);
}
inline const ::valhalla::Location& Options::trace(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.trace)
  return _internal_trace(index);
}
inline ::valhalla::Location* Options::_internal_add_trace() {
  return trace_.Add();
}
inline ::valhalla::Location* Options::add_trace() {
  ::valhalla::Location* _add = _internal_add_trace();
  // @@protoc_insertion_point(field_add:valhalla.Options.trace)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::trace() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.trace)
  return trace_;
}

// .valhalla.ShapeMatch shape_match = 28;
inline void Options::clear_shape_match() {
  shape_match_ = 0;
}
inline ::valhalla::ShapeMatch Options::_internal_shape_match() const {
  return static_cast< ::valhalla::ShapeMatch >(shape_match_);
}
inline ::valhalla::ShapeMatch Options::shape_match() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_match)
  return _internal_shape_match();
}
inline void Options::_internal_set_shape_match(::valhalla::ShapeMatch value) {
  
  shape_match_ = value;
}
inline void Options::set_shape_match(::valhalla::ShapeMatch value) {
  _internal_set_shape_match(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_match)
}

// float gps_accuracy = 30;
inline bool Options::_internal_has_gps_accuracy() const {
  return has_gps_accuracy_case() == kGpsAccuracy;
}
inline bool Options::has_gps_accuracy() const {
  return _internal_has_gps_accuracy();
}
inline void Options::set_has_gps_accuracy() {
  _oneof_case_[12] = kGpsAccuracy;
}
inline void Options::clear_gps_accuracy() {
  if (_internal_has_gps_accuracy()) {
    has_gps_accuracy_.gps_accuracy_ = 0;
    clear_has_has_gps_accuracy();
  }
}
inline float Options::_internal_gps_accuracy() const {
  if (_internal_has_gps_accuracy()) {
    return has_gps_accuracy_.gps_accuracy_;
  }
  return 0;
}
inline void Options::_internal_set_gps_accuracy(float value) {
  if (!_internal_has_gps_accuracy()) {
    clear_has_gps_accuracy();
    set_has_gps_accuracy();
  }
  has_gps_accuracy_.gps_accuracy_ = value;
}
inline float Options::gps_accuracy() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.gps_accuracy)
  return _internal_gps_accuracy();
}
inline void Options::set_gps_accuracy(float value) {
  _internal_set_gps_accuracy(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.gps_accuracy)
}

// float search_radius = 31;
inline bool Options::_internal_has_search_radius() const {
  return has_search_radius_case() == kSearchRadius;
}
inline bool Options::has_search_radius() const {
  return _internal_has_search_radius();
}
inline void Options::set_has_search_radius() {
  _oneof_case_[13] = kSearchRadius;
}
inline void Options::clear_search_radius() {
  if (_internal_has_search_radius()) {
    has_search_radius_.search_radius_ = 0;
    clear_has_has_search_radius();
  }
}
inline float Options::_internal_search_radius() const {
  if (_internal_has_search_radius()) {
    return has_search_radius_.search_radius_;
  }
  return 0;
}
inline void Options::_internal_set_search_radius(float value) {
  if (!_internal_has_search_radius()) {
    clear_has_search_radius();
    set_has_search_radius();
  }
  has_search_radius_.search_radius_ = value;
}
inline float Options::search_radius() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.search_radius)
  return _internal_search_radius();
}
inline void Options::set_search_radius(float value) {
  _internal_set_search_radius(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.search_radius)
}

// float turn_penalty_factor = 32;
inline bool Options::_internal_has_turn_penalty_factor() const {
  return has_turn_penalty_factor_case() == kTurnPenaltyFactor;
}
inline bool Options::has_turn_penalty_factor() const {
  return _internal_has_turn_penalty_factor();
}
inline void Options::set_has_turn_penalty_factor() {
  _oneof_case_[14] = kTurnPenaltyFactor;
}
inline void Options::clear_turn_penalty_factor() {
  if (_internal_has_turn_penalty_factor()) {
    has_turn_penalty_factor_.turn_penalty_factor_ = 0;
    clear_has_has_turn_penalty_factor();
  }
}
inline float Options::_internal_turn_penalty_factor() const {
  if (_internal_has_turn_penalty_factor()) {
    return has_turn_penalty_factor_.turn_penalty_factor_;
  }
  return 0;
}
inline void Options::_internal_set_turn_penalty_factor(float value) {
  if (!_internal_has_turn_penalty_factor()) {
    clear_has_turn_penalty_factor();
    set_has_turn_penalty_factor();
  }
  has_turn_penalty_factor_.turn_penalty_factor_ = value;
}
inline float Options::turn_penalty_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.turn_penalty_factor)
  return _internal_turn_penalty_factor();
}
inline void Options::set_turn_penalty_factor(float value) {
  _internal_set_turn_penalty_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.turn_penalty_factor)
}

// .valhalla.FilterAction filter_action = 33;
inline void Options::clear_filter_action() {
  filter_action_ = 0;
}
inline ::valhalla::FilterAction Options::_internal_filter_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_action_);
}
inline ::valhalla::FilterAction Options::filter_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_action)
  return _internal_filter_action();
}
inline void Options::_internal_set_filter_action(::valhalla::FilterAction value) {
  
  filter_action_ = value;
}
inline void Options::set_filter_action(::valhalla::FilterAction value) {
  _internal_set_filter_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_action)
}

// repeated string filter_attributes = 34;
inline int Options::_internal_filter_attributes_size() const {
  return filter_attributes_.size();
}
inline int Options::filter_attributes_size() const {
  return _internal_filter_attributes_size();
}
inline void Options::clear_filter_attributes() {
  filter_attributes_.Clear();
}
inline std::string* Options::add_filter_attributes() {
  std::string* _s = _internal_add_filter_attributes();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Options.filter_attributes)
  return _s;
}
inline const std::string& Options::_internal_filter_attributes(int index) const {
  return filter_attributes_.Get(index);
}
inline const std::string& Options::filter_attributes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_attributes)
  return _internal_filter_attributes(index);
}
inline std::string* Options::mutable_filter_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.filter_attributes)
  return filter_attributes_.Mutable(index);
}
inline void Options::set_filter_attributes(int index, const std::string& value) {
  filter_attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, std::string&& value) {
  filter_attributes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, const char* value, size_t size) {
  filter_attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.filter_attributes)
}
inline std::string* Options::_internal_add_filter_attributes() {
  return filter_attributes_.Add();
}
inline void Options::add_filter_attributes(const std::string& value) {
  filter_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(std::string&& value) {
  filter_attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value, size_t size) {
  filter_attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Options.filter_attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Options::filter_attributes() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.filter_attributes)
  return filter_attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Options::mutable_filter_attributes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.filter_attributes)
  return &filter_attributes_;
}

// float breakage_distance = 36;
inline bool Options::_internal_has_breakage_distance() const {
  return has_breakage_distance_case() == kBreakageDistance;
}
inline bool Options::has_breakage_distance() const {
  return _internal_has_breakage_distance();
}
inline void Options::set_has_breakage_distance() {
  _oneof_case_[15] = kBreakageDistance;
}
inline void Options::clear_breakage_distance() {
  if (_internal_has_breakage_distance()) {
    has_breakage_distance_.breakage_distance_ = 0;
    clear_has_has_breakage_distance();
  }
}
inline float Options::_internal_breakage_distance() const {
  if (_internal_has_breakage_distance()) {
    return has_breakage_distance_.breakage_distance_;
  }
  return 0;
}
inline void Options::_internal_set_breakage_distance(float value) {
  if (!_internal_has_breakage_distance()) {
    clear_has_breakage_distance();
    set_has_breakage_distance();
  }
  has_breakage_distance_.breakage_distance_ = value;
}
inline float Options::breakage_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.breakage_distance)
  return _internal_breakage_distance();
}
inline void Options::set_breakage_distance(float value) {
  _internal_set_breakage_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.breakage_distance)
}

// bool use_timestamps = 37;
inline bool Options::_internal_has_use_timestamps() const {
  return has_use_timestamps_case() == kUseTimestamps;
}
inline bool Options::has_use_timestamps() const {
  return _internal_has_use_timestamps();
}
inline void Options::set_has_use_timestamps() {
  _oneof_case_[16] = kUseTimestamps;
}
inline void Options::clear_use_timestamps() {
  if (_internal_has_use_timestamps()) {
    has_use_timestamps_.use_timestamps_ = false;
    clear_has_has_use_timestamps();
  }
}
inline bool Options::_internal_use_timestamps() const {
  if (_internal_has_use_timestamps()) {
    return has_use_timestamps_.use_timestamps_;
  }
  return false;
}
inline void Options::_internal_set_use_timestamps(bool value) {
  if (!_internal_has_use_timestamps()) {
    clear_has_use_timestamps();
    set_has_use_timestamps();
  }
  has_use_timestamps_.use_timestamps_ = value;
}
inline bool Options::use_timestamps() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.use_timestamps)
  return _internal_use_timestamps();
}
inline void Options::set_use_timestamps(bool value) {
  _internal_set_use_timestamps(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.use_timestamps)
}

// .valhalla.ShapeFormat shape_format = 38;
inline void Options::clear_shape_format() {
  shape_format_ = 0;
}
inline ::valhalla::ShapeFormat Options::_internal_shape_format() const {
  return static_cast< ::valhalla::ShapeFormat >(shape_format_);
}
inline ::valhalla::ShapeFormat Options::shape_format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_format)
  return _internal_shape_format();
}
inline void Options::_internal_set_shape_format(::valhalla::ShapeFormat value) {
  
  shape_format_ = value;
}
inline void Options::set_shape_format(::valhalla::ShapeFormat value) {
  _internal_set_shape_format(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_format)
}

// uint32 alternates = 39;
inline bool Options::_internal_has_alternates() const {
  return has_alternates_case() == kAlternates;
}
inline bool Options::has_alternates() const {
  return _internal_has_alternates();
}
inline void Options::set_has_alternates() {
  _oneof_case_[17] = kAlternates;
}
inline void Options::clear_alternates() {
  if (_internal_has_alternates()) {
    has_alternates_.alternates_ = 0u;
    clear_has_has_alternates();
  }
}
inline uint32_t Options::_internal_alternates() const {
  if (_internal_has_alternates()) {
    return has_alternates_.alternates_;
  }
  return 0u;
}
inline void Options::_internal_set_alternates(uint32_t value) {
  if (!_internal_has_alternates()) {
    clear_has_alternates();
    set_has_alternates();
  }
  has_alternates_.alternates_ = value;
}
inline uint32_t Options::alternates() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.alternates)
  return _internal_alternates();
}
inline void Options::set_alternates(uint32_t value) {
  _internal_set_alternates(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.alternates)
}

// float interpolation_distance = 40;
inline bool Options::_internal_has_interpolation_distance() const {
  return has_interpolation_distance_case() == kInterpolationDistance;
}
inline bool Options::has_interpolation_distance() const {
  return _internal_has_interpolation_distance();
}
inline void Options::set_has_interpolation_distance() {
  _oneof_case_[18] = kInterpolationDistance;
}
inline void Options::clear_interpolation_distance() {
  if (_internal_has_interpolation_distance()) {
    has_interpolation_distance_.interpolation_distance_ = 0;
    clear_has_has_interpolation_distance();
  }
}
inline float Options::_internal_interpolation_distance() const {
  if (_internal_has_interpolation_distance()) {
    return has_interpolation_distance_.interpolation_distance_;
  }
  return 0;
}
inline void Options::_internal_set_interpolation_distance(float value) {
  if (!_internal_has_interpolation_distance()) {
    clear_has_interpolation_distance();
    set_has_interpolation_distance();
  }
  has_interpolation_distance_.interpolation_distance_ = value;
}
inline float Options::interpolation_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.interpolation_distance)
  return _internal_interpolation_distance();
}
inline void Options::set_interpolation_distance(float value) {
  _internal_set_interpolation_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.interpolation_distance)
}

// bool guidance_views = 41;
inline bool Options::_internal_has_guidance_views() const {
  return has_guidance_views_case() == kGuidanceViews;
}
inline bool Options::has_guidance_views() const {
  return _internal_has_guidance_views();
}
inline void Options::set_has_guidance_views() {
  _oneof_case_[19] = kGuidanceViews;
}
inline void Options::clear_guidance_views() {
  if (_internal_has_guidance_views()) {
    has_guidance_views_.guidance_views_ = false;
    clear_has_has_guidance_views();
  }
}
inline bool Options::_internal_guidance_views() const {
  if (_internal_has_guidance_views()) {
    return has_guidance_views_.guidance_views_;
  }
  return false;
}
inline void Options::_internal_set_guidance_views(bool value) {
  if (!_internal_has_guidance_views()) {
    clear_has_guidance_views();
    set_has_guidance_views();
  }
  has_guidance_views_.guidance_views_ = value;
}
inline bool Options::guidance_views() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.guidance_views)
  return _internal_guidance_views();
}
inline void Options::set_guidance_views(bool value) {
  _internal_set_guidance_views(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.guidance_views)
}

// uint32 height_precision = 43;
inline bool Options::_internal_has_height_precision() const {
  return has_height_precision_case() == kHeightPrecision;
}
inline bool Options::has_height_precision() const {
  return _internal_has_height_precision();
}
inline void Options::set_has_height_precision() {
  _oneof_case_[20] = kHeightPrecision;
}
inline void Options::clear_height_precision() {
  if (_internal_has_height_precision()) {
    has_height_precision_.height_precision_ = 0u;
    clear_has_has_height_precision();
  }
}
inline uint32_t Options::_internal_height_precision() const {
  if (_internal_has_height_precision()) {
    return has_height_precision_.height_precision_;
  }
  return 0u;
}
inline void Options::_internal_set_height_precision(uint32_t value) {
  if (!_internal_has_height_precision()) {
    clear_has_height_precision();
    set_has_height_precision();
  }
  has_height_precision_.height_precision_ = value;
}
inline uint32_t Options::height_precision() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.height_precision)
  return _internal_height_precision();
}
inline void Options::set_height_precision(uint32_t value) {
  _internal_set_height_precision(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.height_precision)
}

// bool roundabout_exits = 44;
inline bool Options::_internal_has_roundabout_exits() const {
  return has_roundabout_exits_case() == kRoundaboutExits;
}
inline bool Options::has_roundabout_exits() const {
  return _internal_has_roundabout_exits();
}
inline void Options::set_has_roundabout_exits() {
  _oneof_case_[21] = kRoundaboutExits;
}
inline void Options::clear_roundabout_exits() {
  if (_internal_has_roundabout_exits()) {
    has_roundabout_exits_.roundabout_exits_ = false;
    clear_has_has_roundabout_exits();
  }
}
inline bool Options::_internal_roundabout_exits() const {
  if (_internal_has_roundabout_exits()) {
    return has_roundabout_exits_.roundabout_exits_;
  }
  return false;
}
inline void Options::_internal_set_roundabout_exits(bool value) {
  if (!_internal_has_roundabout_exits()) {
    clear_has_roundabout_exits();
    set_has_roundabout_exits();
  }
  has_roundabout_exits_.roundabout_exits_ = value;
}
inline bool Options::roundabout_exits() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.roundabout_exits)
  return _internal_roundabout_exits();
}
inline void Options::set_roundabout_exits(bool value) {
  _internal_set_roundabout_exits(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.roundabout_exits)
}

// bool linear_references = 45;
inline bool Options::_internal_has_linear_references() const {
  return has_linear_references_case() == kLinearReferences;
}
inline bool Options::has_linear_references() const {
  return _internal_has_linear_references();
}
inline void Options::set_has_linear_references() {
  _oneof_case_[22] = kLinearReferences;
}
inline void Options::clear_linear_references() {
  if (_internal_has_linear_references()) {
    has_linear_references_.linear_references_ = false;
    clear_has_has_linear_references();
  }
}
inline bool Options::_internal_linear_references() const {
  if (_internal_has_linear_references()) {
    return has_linear_references_.linear_references_;
  }
  return false;
}
inline void Options::_internal_set_linear_references(bool value) {
  if (!_internal_has_linear_references()) {
    clear_has_linear_references();
    set_has_linear_references();
  }
  has_linear_references_.linear_references_ = value;
}
inline bool Options::linear_references() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.linear_references)
  return _internal_linear_references();
}
inline void Options::set_linear_references(bool value) {
  _internal_set_linear_references(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.linear_references)
}

// repeated .valhalla.Costing recostings = 46;
inline int Options::_internal_recostings_size() const {
  return recostings_.size();
}
inline int Options::recostings_size() const {
  return _internal_recostings_size();
}
inline void Options::clear_recostings() {
  recostings_.Clear();
}
inline ::valhalla::Costing* Options::mutable_recostings(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.recostings)
  return recostings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Costing >*
Options::mutable_recostings() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.recostings)
  return &recostings_;
}
inline const ::valhalla::Costing& Options::_internal_recostings(int index) const {
  return recostings_.Get(index);
}
inline const ::valhalla::Costing& Options::recostings(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.recostings)
  return _internal_recostings(index);
}
inline ::valhalla::Costing* Options::_internal_add_recostings() {
  return recostings_.Add();
}
inline ::valhalla::Costing* Options::add_recostings() {
  ::valhalla::Costing* _add = _internal_add_recostings();
  // @@protoc_insertion_point(field_add:valhalla.Options.recostings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Costing >&
Options::recostings() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.recostings)
  return recostings_;
}

// repeated .valhalla.Ring exclude_polygons = 47;
inline int Options::_internal_exclude_polygons_size() const {
  return exclude_polygons_.size();
}
inline int Options::exclude_polygons_size() const {
  return _internal_exclude_polygons_size();
}
inline void Options::clear_exclude_polygons() {
  exclude_polygons_.Clear();
}
inline ::valhalla::Ring* Options::mutable_exclude_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.exclude_polygons)
  return exclude_polygons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Ring >*
Options::mutable_exclude_polygons() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.exclude_polygons)
  return &exclude_polygons_;
}
inline const ::valhalla::Ring& Options::_internal_exclude_polygons(int index) const {
  return exclude_polygons_.Get(index);
}
inline const ::valhalla::Ring& Options::exclude_polygons(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.exclude_polygons)
  return _internal_exclude_polygons(index);
}
inline ::valhalla::Ring* Options::_internal_add_exclude_polygons() {
  return exclude_polygons_.Add();
}
inline ::valhalla::Ring* Options::add_exclude_polygons() {
  ::valhalla::Ring* _add = _internal_add_exclude_polygons();
  // @@protoc_insertion_point(field_add:valhalla.Options.exclude_polygons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Ring >&
Options::exclude_polygons() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.exclude_polygons)
  return exclude_polygons_;
}

// bool prioritize_bidirectional = 48;
inline bool Options::_internal_has_prioritize_bidirectional() const {
  return has_prioritize_bidirectional_case() == kPrioritizeBidirectional;
}
inline bool Options::has_prioritize_bidirectional() const {
  return _internal_has_prioritize_bidirectional();
}
inline void Options::set_has_prioritize_bidirectional() {
  _oneof_case_[23] = kPrioritizeBidirectional;
}
inline void Options::clear_prioritize_bidirectional() {
  if (_internal_has_prioritize_bidirectional()) {
    has_prioritize_bidirectional_.prioritize_bidirectional_ = false;
    clear_has_has_prioritize_bidirectional();
  }
}
inline bool Options::_internal_prioritize_bidirectional() const {
  if (_internal_has_prioritize_bidirectional()) {
    return has_prioritize_bidirectional_.prioritize_bidirectional_;
  }
  return false;
}
inline void Options::_internal_set_prioritize_bidirectional(bool value) {
  if (!_internal_has_prioritize_bidirectional()) {
    clear_has_prioritize_bidirectional();
    set_has_prioritize_bidirectional();
  }
  has_prioritize_bidirectional_.prioritize_bidirectional_ = value;
}
inline bool Options::prioritize_bidirectional() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.prioritize_bidirectional)
  return _internal_prioritize_bidirectional();
}
inline void Options::set_prioritize_bidirectional(bool value) {
  _internal_set_prioritize_bidirectional(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.prioritize_bidirectional)
}

// .valhalla.Options.Action expansion_action = 49;
inline bool Options::_internal_has_expansion_action() const {
  return has_expansion_action_case() == kExpansionAction;
}
inline bool Options::has_expansion_action() const {
  return _internal_has_expansion_action();
}
inline void Options::set_has_expansion_action() {
  _oneof_case_[24] = kExpansionAction;
}
inline void Options::clear_expansion_action() {
  if (_internal_has_expansion_action()) {
    has_expansion_action_.expansion_action_ = 0;
    clear_has_has_expansion_action();
  }
}
inline ::valhalla::Options_Action Options::_internal_expansion_action() const {
  if (_internal_has_expansion_action()) {
    return static_cast< ::valhalla::Options_Action >(has_expansion_action_.expansion_action_);
  }
  return static_cast< ::valhalla::Options_Action >(0);
}
inline ::valhalla::Options_Action Options::expansion_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.expansion_action)
  return _internal_expansion_action();
}
inline void Options::_internal_set_expansion_action(::valhalla::Options_Action value) {
  if (!_internal_has_expansion_action()) {
    clear_has_expansion_action();
    set_has_expansion_action();
  }
  has_expansion_action_.expansion_action_ = value;
}
inline void Options::set_expansion_action(::valhalla::Options_Action value) {
  _internal_set_expansion_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.expansion_action)
}

// bool skip_opposites = 50;
inline bool Options::_internal_has_skip_opposites() const {
  return has_skip_opposites_case() == kSkipOpposites;
}
inline bool Options::has_skip_opposites() const {
  return _internal_has_skip_opposites();
}
inline void Options::set_has_skip_opposites() {
  _oneof_case_[25] = kSkipOpposites;
}
inline void Options::clear_skip_opposites() {
  if (_internal_has_skip_opposites()) {
    has_skip_opposites_.skip_opposites_ = false;
    clear_has_has_skip_opposites();
  }
}
inline bool Options::_internal_skip_opposites() const {
  if (_internal_has_skip_opposites()) {
    return has_skip_opposites_.skip_opposites_;
  }
  return false;
}
inline void Options::_internal_set_skip_opposites(bool value) {
  if (!_internal_has_skip_opposites()) {
    clear_has_skip_opposites();
    set_has_skip_opposites();
  }
  has_skip_opposites_.skip_opposites_ = value;
}
inline bool Options::skip_opposites() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.skip_opposites)
  return _internal_skip_opposites();
}
inline void Options::set_skip_opposites(bool value) {
  _internal_set_skip_opposites(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.skip_opposites)
}

// repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
inline int Options::_internal_expansion_properties_size() const {
  return expansion_properties_.size();
}
inline int Options::expansion_properties_size() const {
  return _internal_expansion_properties_size();
}
inline void Options::clear_expansion_properties() {
  expansion_properties_.Clear();
}
inline ::valhalla::Options_ExpansionProperties Options::_internal_expansion_properties(int index) const {
  return static_cast< ::valhalla::Options_ExpansionProperties >(expansion_properties_.Get(index));
}
inline ::valhalla::Options_ExpansionProperties Options::expansion_properties(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.expansion_properties)
  return _internal_expansion_properties(index);
}
inline void Options::set_expansion_properties(int index, ::valhalla::Options_ExpansionProperties value) {
  expansion_properties_.Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.Options.expansion_properties)
}
inline void Options::_internal_add_expansion_properties(::valhalla::Options_ExpansionProperties value) {
  expansion_properties_.Add(value);
}
inline void Options::add_expansion_properties(::valhalla::Options_ExpansionProperties value) {
  _internal_add_expansion_properties(value);
  // @@protoc_insertion_point(field_add:valhalla.Options.expansion_properties)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Options::expansion_properties() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.expansion_properties)
  return expansion_properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Options::_internal_mutable_expansion_properties() {
  return &expansion_properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Options::mutable_expansion_properties() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.expansion_properties)
  return _internal_mutable_expansion_properties();
}

// .valhalla.PbfFieldSelector pbf_field_selector = 52;
inline bool Options::_internal_has_pbf_field_selector() const {
  return this != internal_default_instance() && pbf_field_selector_ != nullptr;
}
inline bool Options::has_pbf_field_selector() const {
  return _internal_has_pbf_field_selector();
}
inline void Options::clear_pbf_field_selector() {
  if (GetArenaForAllocation() == nullptr && pbf_field_selector_ != nullptr) {
    delete pbf_field_selector_;
  }
  pbf_field_selector_ = nullptr;
}
inline const ::valhalla::PbfFieldSelector& Options::_internal_pbf_field_selector() const {
  const ::valhalla::PbfFieldSelector* p = pbf_field_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::PbfFieldSelector&>(
      ::valhalla::_PbfFieldSelector_default_instance_);
}
inline const ::valhalla::PbfFieldSelector& Options::pbf_field_selector() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.pbf_field_selector)
  return _internal_pbf_field_selector();
}
inline void Options::unsafe_arena_set_allocated_pbf_field_selector(
    ::valhalla::PbfFieldSelector* pbf_field_selector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pbf_field_selector_);
  }
  pbf_field_selector_ = pbf_field_selector;
  if (pbf_field_selector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Options.pbf_field_selector)
}
inline ::valhalla::PbfFieldSelector* Options::release_pbf_field_selector() {
  
  ::valhalla::PbfFieldSelector* temp = pbf_field_selector_;
  pbf_field_selector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::PbfFieldSelector* Options::unsafe_arena_release_pbf_field_selector() {
  // @@protoc_insertion_point(field_release:valhalla.Options.pbf_field_selector)
  
  ::valhalla::PbfFieldSelector* temp = pbf_field_selector_;
  pbf_field_selector_ = nullptr;
  return temp;
}
inline ::valhalla::PbfFieldSelector* Options::_internal_mutable_pbf_field_selector() {
  
  if (pbf_field_selector_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::PbfFieldSelector>(GetArenaForAllocation());
    pbf_field_selector_ = p;
  }
  return pbf_field_selector_;
}
inline ::valhalla::PbfFieldSelector* Options::mutable_pbf_field_selector() {
  ::valhalla::PbfFieldSelector* _msg = _internal_mutable_pbf_field_selector();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.pbf_field_selector)
  return _msg;
}
inline void Options::set_allocated_pbf_field_selector(::valhalla::PbfFieldSelector* pbf_field_selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pbf_field_selector_;
  }
  if (pbf_field_selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::PbfFieldSelector>::GetOwningArena(pbf_field_selector);
    if (message_arena != submessage_arena) {
      pbf_field_selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pbf_field_selector, submessage_arena);
    }
    
  } else {
    
  }
  pbf_field_selector_ = pbf_field_selector;
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.pbf_field_selector)
}

// bool reverse = 53;
inline void Options::clear_reverse() {
  reverse_ = false;
}
inline bool Options::_internal_reverse() const {
  return reverse_;
}
inline bool Options::reverse() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.reverse)
  return _internal_reverse();
}
inline void Options::_internal_set_reverse(bool value) {
  
  reverse_ = value;
}
inline void Options::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.reverse)
}

// uint32 matrix_locations = 54;
inline void Options::clear_matrix_locations() {
  matrix_locations_ = 0u;
}
inline uint32_t Options::_internal_matrix_locations() const {
  return matrix_locations_;
}
inline uint32_t Options::matrix_locations() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.matrix_locations)
  return _internal_matrix_locations();
}
inline void Options::_internal_set_matrix_locations(uint32_t value) {
  
  matrix_locations_ = value;
}
inline void Options::set_matrix_locations(uint32_t value) {
  _internal_set_matrix_locations(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.matrix_locations)
}

inline bool Options::has_has_language() const {
  return has_language_case() != HAS_LANGUAGE_NOT_SET;
}
inline void Options::clear_has_has_language() {
  _oneof_case_[0] = HAS_LANGUAGE_NOT_SET;
}
inline bool Options::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void Options::clear_has_has_id() {
  _oneof_case_[1] = HAS_ID_NOT_SET;
}
inline bool Options::has_has_jsonp() const {
  return has_jsonp_case() != HAS_JSONP_NOT_SET;
}
inline void Options::clear_has_has_jsonp() {
  _oneof_case_[2] = HAS_JSONP_NOT_SET;
}
inline bool Options::has_has_encoded_polyline() const {
  return has_encoded_polyline_case() != HAS_ENCODED_POLYLINE_NOT_SET;
}
inline void Options::clear_has_has_encoded_polyline() {
  _oneof_case_[3] = HAS_ENCODED_POLYLINE_NOT_SET;
}
inline bool Options::has_has_range() const {
  return has_range_case() != HAS_RANGE_NOT_SET;
}
inline void Options::clear_has_has_range() {
  _oneof_case_[4] = HAS_RANGE_NOT_SET;
}
inline bool Options::has_has_verbose() const {
  return has_verbose_case() != HAS_VERBOSE_NOT_SET;
}
inline void Options::clear_has_has_verbose() {
  _oneof_case_[5] = HAS_VERBOSE_NOT_SET;
}
inline bool Options::has_has_date_time() const {
  return has_date_time_case() != HAS_DATE_TIME_NOT_SET;
}
inline void Options::clear_has_has_date_time() {
  _oneof_case_[6] = HAS_DATE_TIME_NOT_SET;
}
inline bool Options::has_has_resample_distance() const {
  return has_resample_distance_case() != HAS_RESAMPLE_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_resample_distance() {
  _oneof_case_[7] = HAS_RESAMPLE_DISTANCE_NOT_SET;
}
inline bool Options::has_has_polygons() const {
  return has_polygons_case() != HAS_POLYGONS_NOT_SET;
}
inline void Options::clear_has_has_polygons() {
  _oneof_case_[8] = HAS_POLYGONS_NOT_SET;
}
inline bool Options::has_has_denoise() const {
  return has_denoise_case() != HAS_DENOISE_NOT_SET;
}
inline void Options::clear_has_has_denoise() {
  _oneof_case_[9] = HAS_DENOISE_NOT_SET;
}
inline bool Options::has_has_generalize() const {
  return has_generalize_case() != HAS_GENERALIZE_NOT_SET;
}
inline void Options::clear_has_has_generalize() {
  _oneof_case_[10] = HAS_GENERALIZE_NOT_SET;
}
inline bool Options::has_has_show_locations() const {
  return has_show_locations_case() != HAS_SHOW_LOCATIONS_NOT_SET;
}
inline void Options::clear_has_has_show_locations() {
  _oneof_case_[11] = HAS_SHOW_LOCATIONS_NOT_SET;
}
inline bool Options::has_has_gps_accuracy() const {
  return has_gps_accuracy_case() != HAS_GPS_ACCURACY_NOT_SET;
}
inline void Options::clear_has_has_gps_accuracy() {
  _oneof_case_[12] = HAS_GPS_ACCURACY_NOT_SET;
}
inline bool Options::has_has_search_radius() const {
  return has_search_radius_case() != HAS_SEARCH_RADIUS_NOT_SET;
}
inline void Options::clear_has_has_search_radius() {
  _oneof_case_[13] = HAS_SEARCH_RADIUS_NOT_SET;
}
inline bool Options::has_has_turn_penalty_factor() const {
  return has_turn_penalty_factor_case() != HAS_TURN_PENALTY_FACTOR_NOT_SET;
}
inline void Options::clear_has_has_turn_penalty_factor() {
  _oneof_case_[14] = HAS_TURN_PENALTY_FACTOR_NOT_SET;
}
inline bool Options::has_has_breakage_distance() const {
  return has_breakage_distance_case() != HAS_BREAKAGE_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_breakage_distance() {
  _oneof_case_[15] = HAS_BREAKAGE_DISTANCE_NOT_SET;
}
inline bool Options::has_has_use_timestamps() const {
  return has_use_timestamps_case() != HAS_USE_TIMESTAMPS_NOT_SET;
}
inline void Options::clear_has_has_use_timestamps() {
  _oneof_case_[16] = HAS_USE_TIMESTAMPS_NOT_SET;
}
inline bool Options::has_has_alternates() const {
  return has_alternates_case() != HAS_ALTERNATES_NOT_SET;
}
inline void Options::clear_has_has_alternates() {
  _oneof_case_[17] = HAS_ALTERNATES_NOT_SET;
}
inline bool Options::has_has_interpolation_distance() const {
  return has_interpolation_distance_case() != HAS_INTERPOLATION_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_interpolation_distance() {
  _oneof_case_[18] = HAS_INTERPOLATION_DISTANCE_NOT_SET;
}
inline bool Options::has_has_guidance_views() const {
  return has_guidance_views_case() != HAS_GUIDANCE_VIEWS_NOT_SET;
}
inline void Options::clear_has_has_guidance_views() {
  _oneof_case_[19] = HAS_GUIDANCE_VIEWS_NOT_SET;
}
inline bool Options::has_has_height_precision() const {
  return has_height_precision_case() != HAS_HEIGHT_PRECISION_NOT_SET;
}
inline void Options::clear_has_has_height_precision() {
  _oneof_case_[20] = HAS_HEIGHT_PRECISION_NOT_SET;
}
inline bool Options::has_has_roundabout_exits() const {
  return has_roundabout_exits_case() != HAS_ROUNDABOUT_EXITS_NOT_SET;
}
inline void Options::clear_has_has_roundabout_exits() {
  _oneof_case_[21] = HAS_ROUNDABOUT_EXITS_NOT_SET;
}
inline bool Options::has_has_linear_references() const {
  return has_linear_references_case() != HAS_LINEAR_REFERENCES_NOT_SET;
}
inline void Options::clear_has_has_linear_references() {
  _oneof_case_[22] = HAS_LINEAR_REFERENCES_NOT_SET;
}
inline bool Options::has_has_prioritize_bidirectional() const {
  return has_prioritize_bidirectional_case() != HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}
inline void Options::clear_has_has_prioritize_bidirectional() {
  _oneof_case_[23] = HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}
inline bool Options::has_has_expansion_action() const {
  return has_expansion_action_case() != HAS_EXPANSION_ACTION_NOT_SET;
}
inline void Options::clear_has_has_expansion_action() {
  _oneof_case_[24] = HAS_EXPANSION_ACTION_NOT_SET;
}
inline bool Options::has_has_skip_opposites() const {
  return has_skip_opposites_case() != HAS_SKIP_OPPOSITES_NOT_SET;
}
inline void Options::clear_has_has_skip_opposites() {
  _oneof_case_[25] = HAS_SKIP_OPPOSITES_NOT_SET;
}
inline Options::HasLanguageCase Options::has_language_case() const {
  return Options::HasLanguageCase(_oneof_case_[0]);
}
inline Options::HasIdCase Options::has_id_case() const {
  return Options::HasIdCase(_oneof_case_[1]);
}
inline Options::HasJsonpCase Options::has_jsonp_case() const {
  return Options::HasJsonpCase(_oneof_case_[2]);
}
inline Options::HasEncodedPolylineCase Options::has_encoded_polyline_case() const {
  return Options::HasEncodedPolylineCase(_oneof_case_[3]);
}
inline Options::HasRangeCase Options::has_range_case() const {
  return Options::HasRangeCase(_oneof_case_[4]);
}
inline Options::HasVerboseCase Options::has_verbose_case() const {
  return Options::HasVerboseCase(_oneof_case_[5]);
}
inline Options::HasDateTimeCase Options::has_date_time_case() const {
  return Options::HasDateTimeCase(_oneof_case_[6]);
}
inline Options::HasResampleDistanceCase Options::has_resample_distance_case() const {
  return Options::HasResampleDistanceCase(_oneof_case_[7]);
}
inline Options::HasPolygonsCase Options::has_polygons_case() const {
  return Options::HasPolygonsCase(_oneof_case_[8]);
}
inline Options::HasDenoiseCase Options::has_denoise_case() const {
  return Options::HasDenoiseCase(_oneof_case_[9]);
}
inline Options::HasGeneralizeCase Options::has_generalize_case() const {
  return Options::HasGeneralizeCase(_oneof_case_[10]);
}
inline Options::HasShowLocationsCase Options::has_show_locations_case() const {
  return Options::HasShowLocationsCase(_oneof_case_[11]);
}
inline Options::HasGpsAccuracyCase Options::has_gps_accuracy_case() const {
  return Options::HasGpsAccuracyCase(_oneof_case_[12]);
}
inline Options::HasSearchRadiusCase Options::has_search_radius_case() const {
  return Options::HasSearchRadiusCase(_oneof_case_[13]);
}
inline Options::HasTurnPenaltyFactorCase Options::has_turn_penalty_factor_case() const {
  return Options::HasTurnPenaltyFactorCase(_oneof_case_[14]);
}
inline Options::HasBreakageDistanceCase Options::has_breakage_distance_case() const {
  return Options::HasBreakageDistanceCase(_oneof_case_[15]);
}
inline Options::HasUseTimestampsCase Options::has_use_timestamps_case() const {
  return Options::HasUseTimestampsCase(_oneof_case_[16]);
}
inline Options::HasAlternatesCase Options::has_alternates_case() const {
  return Options::HasAlternatesCase(_oneof_case_[17]);
}
inline Options::HasInterpolationDistanceCase Options::has_interpolation_distance_case() const {
  return Options::HasInterpolationDistanceCase(_oneof_case_[18]);
}
inline Options::HasGuidanceViewsCase Options::has_guidance_views_case() const {
  return Options::HasGuidanceViewsCase(_oneof_case_[19]);
}
inline Options::HasHeightPrecisionCase Options::has_height_precision_case() const {
  return Options::HasHeightPrecisionCase(_oneof_case_[20]);
}
inline Options::HasRoundaboutExitsCase Options::has_roundabout_exits_case() const {
  return Options::HasRoundaboutExitsCase(_oneof_case_[21]);
}
inline Options::HasLinearReferencesCase Options::has_linear_references_case() const {
  return Options::HasLinearReferencesCase(_oneof_case_[22]);
}
inline Options::HasPrioritizeBidirectionalCase Options::has_prioritize_bidirectional_case() const {
  return Options::HasPrioritizeBidirectionalCase(_oneof_case_[23]);
}
inline Options::HasExpansionActionCase Options::has_expansion_action_case() const {
  return Options::HasExpansionActionCase(_oneof_case_[24]);
}
inline Options::HasSkipOppositesCase Options::has_skip_opposites_case() const {
  return Options::HasSkipOppositesCase(_oneof_case_[25]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::Costing_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_Units> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_Format> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_Action> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_DateTimeType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_ExpansionProperties> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::ShapeMatch> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::FilterAction> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::ShapeFormat> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_options_2eproto
